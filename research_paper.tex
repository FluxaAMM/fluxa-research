% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\newcounter{none} % for unnumbered tables
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage[]{biblatex}
\addbibresource{references.bib}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

\section{Logarithmic Number Representation for Decentralized Exchange
Systems}\label{logarithmic-number-representation-for-decentralized-exchange-systems}

\textbf{Srivatsav Erramilli}

\emph{Independent Researcher}

srivatsaverramilli@gmail.com

December 2025 \textbar{} Version 1.0

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Abstract}\label{abstract}

Decentralized exchanges face a fundamental tension between price
representation precision, computational efficiency, and the unification
of heterogeneous trading mechanisms. Current approaches---whether
tick-based concentrated liquidity market makers (CLMMs) or fixed-point
arithmetic systems---impose architectural constraints that fragment
liquidity across separate spot, limit order, and derivatives venues,
while struggling to achieve centralized exchange-grade numerical
precision. This paper introduces a \textbf{logarithmic number
representation} for on-chain price coordinates, replacing traditional
linear or tick-based encodings with a continuous log-sqrt-price axis
\(l = \log_2 \sqrt{P}\) that serves as the sole source of truth for all
price-dependent operations.

We develop a \textbf{three-layer architecture}: Layer 0 provides a
continuous mathematical model where CLMM liquidity is a
piecewise-constant density and limit orders are atomic measures on the
same \(l\)-axis; Layer 1 defines a global slot lattice for efficient
on-chain indexing without constraining economic prices; and Layer 2
constructs adaptive, trade-specific meshes that include all liquidity
boundaries and order prices as nodes, enabling exact segment-wise
integration of CLMM dynamics. This architecture naturally extends to a
\textbf{spot-anchored derivative layer} where perpetual swaps, futures,
and options derive all pricing from the unified spot process
\(P(l(t)) = 2^{2l(t)}\), eliminating basis risk and the need for funding
rate mechanisms.

We establish rigorous \textbf{fixed-point specifications} with provable
error bounds: the total numerical error in token deltas is bounded by
\(C(\frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}})\),
where \(\sigma = 2^F\) is the log-scaling precision, and the
approximation errors can be made arbitrarily small by increasing
fractional bit-lengths. With \(F = 48\) and Q64.64 formats, global
relative price errors reach \(O(10^{-14})\)---comparable to IEEE 754
double precision. We prove that the spot-anchored mark price is the
\textbf{unique no-arbitrage choice}, that protocol-level delta hedging
achieves bounded residual risk under discrete execution, and that
liquidations respect monotone price paths with non-negative reserves.
Additional results include deterministic compositionality of concurrent
liquidations, insurance fund solvency conditions, and leverage
constraints that provably prevent unbounded liquidation cascades.

The unified semantics---where CLMM liquidity, central limit order book
depth, and derivative positions all evolve on a single log-price
coordinate with deterministic node execution ordering---enables
precision and capital efficiency comparable to modern centralized
exchange engines, while preserving the transparency and composability of
decentralized systems.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{1. Introduction}\label{introduction}

\subsubsection{1.1 Motivation}\label{motivation}

The architecture of decentralized exchanges has evolved rapidly over the
past several years. Constant-product automated market makers (AMMs)
\autocite{adams2020uniswap} gave way to concentrated liquidity market
makers (CLMMs), exemplified by Uniswap v3 \autocite{adams2021uniswap},
which allow liquidity providers to allocate capital to specific price
ranges rather than the entire \((0, \infty)\) interval. Concurrently,
on-chain central limit order books (CLOBs) \autocite{openbook2022} have
emerged on high-throughput chains, offering price-time priority matching
familiar from traditional finance. Most recently, perpetual swap
protocols \autocite{bitmex2016perpetual} have brought leveraged
derivatives on-chain, complete with margin systems, funding rates, and
liquidation engines.

These three paradigms---CLMMs, CLOBs, and perpetuals---currently exist
as largely separate systems, each with its own price representation,
execution logic, and liquidity pools. A trader wishing to execute a
large order may need to route across multiple venues; a liquidity
provider must choose between providing to an AMM pool, posting limit
orders, or supplying collateral to a perp market. This fragmentation
imposes capital inefficiency, increases smart contract complexity, and
makes formal reasoning about system-wide behavior difficult.

At the heart of this fragmentation lies a representation problem. CLMMs
typically encode prices via ``ticks''---discrete points on a logarithmic
scale chosen for computational convenience rather than mathematical
elegance. CLOBs store limit order prices in various fixed-point formats.
Perpetual protocols maintain separate ``mark prices'' derived from spot
via funding rate mechanisms designed to keep perp prices anchored. Each
system makes different tradeoffs between precision, gas cost, and
expressiveness, and the interfaces between them are inherently lossy.

\subsubsection{1.2 Problem Statement}\label{problem-statement}

Existing decentralized exchange designs suffer from several interrelated
limitations:

\textbf{Ad-hoc discretization.} Tick-based systems (e.g., Uniswap v3's
tick spacing \autocite{adams2021uniswap}) impose a rigid grid that does
not arise from any principled continuous model. The relationship between
tick indices, sqrt-price values, and actual prices involves
protocol-specific constants (e.g., 1.0001 as the tick base) and implicit
rounding that obscure error analysis.

\textbf{Opaque fixed-point arithmetic.} On-chain implementations rely on
fixed-point representations (e.g., Uniswap v3's \texttt{sqrtPriceX96}
\autocite{adams2021uniswap}) with precision choices made for historical
or gas-optimization reasons. The propagation of rounding errors through
CLMM formulas, CLOB matching, and derivative valuations is rarely
analyzed formally.

\textbf{Fragmented liquidity and execution.} Because CLMMs, CLOBs, and
perps use incompatible price representations, unifying them requires
conversion layers that introduce additional error and complexity. There
is no single ``source of truth'' price that all components reference.

\textbf{Derivative basis and funding complexity.} Traditional on-chain
perpetuals define a separate ``perp price'' distinct from spot,
necessitating funding rate mechanisms to keep them aligned. This
introduces basis risk, funding arbitrage, and additional state variables
that complicate both implementation and formal analysis.

\textbf{Lack of formal guarantees.} Perhaps most critically, existing
systems provide no rigorous bounds on numerical error, no formal
specification of execution semantics across liquidity types, and no
proofs that the discrete on-chain implementation converges to any
well-defined continuous model.

\subsubsection{1.3 Key Idea}\label{key-idea}

This paper proposes a unified framework based on a single
\textbf{log-sqrt-price axis}:

\[
l = \log_2 S = \log_2 \sqrt{P} = \frac{1}{2} \log_2 P
\]

where \(P\) is the spot price and \(S = \sqrt{P}\) is the sqrt-price.
All prices, liquidity distributions, limit orders, and derivative
valuations are expressed as functions of this one-dimensional coordinate
\(l \in \mathbb{R}\).

We organize the system into \textbf{three layers}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Layer 0 (Continuous):} A purely mathematical model where the
  log-sqrt-price \(l\) takes values in \(\mathbb{R}\), CLMM liquidity is
  a piecewise-constant density \(\lambda(l)\), and CLOB orders are point
  masses (Dirac measures) on the \(l\)-axis. This layer defines the
  ``true'' economic semantics independent of any discretization.
\item
  \textbf{Layer 1 (Global Slots):} A persistent lattice
  \(\{l_s = l_{\mathrm{ref}} + s \cdot \Delta l : s \in \mathbb{Z}\}\)
  used for on-chain indexing. Liquidity provider positions and limit
  orders are mapped to slot indices for efficient storage and lookup,
  but their exact \(l\)-coordinates are preserved. The slot grid is an
  implementation convenience that does not constrain economic prices.
\item
  \textbf{Layer 2 (Local Mesh):} For each trade, we construct an
  adaptive mesh over the relevant price interval, including all LP band
  boundaries and limit order prices as nodes. Execution proceeds
  segment-by-segment with exact CLMM integration on each segment and
  deterministic CLOB matching at each node.
\end{enumerate}

On top of this spot architecture, we define a \textbf{spot-anchored
derivative layer} where perpetuals, futures, and options derive all
pricing from the unified spot process \(P(l(t)) = 2^{2l(t)}\). There is
no separate ``perp price,'' no basis, and no funding rate---the
derivative layer is economically equivalent to holding (or shorting) the
underlying, with leverage and margin handled as pure accounting.

Finally, we provide a \textbf{formal fixed-point specification} showing
that the on-chain implementation converges to the continuous model with
explicit error bounds that can be made arbitrarily small by increasing
numerical precision.

\subsubsection{1.4 Contributions}\label{contributions}

This paper makes the following contributions:

\begin{itemize}
\item
  \textbf{A continuous log-sqrt-price formulation} that places CLMM
  liquidity, CLOB orders, and perpetual positions on a single
  mathematical axis \(l \in \mathbb{R}\), with CLMM dynamics expressed
  as explicit differential equations \(dA(l), dB(l)\) in the
  log-coordinate.
\item
  \textbf{A three-layer architecture} with precise semantics: Layer 0
  defines the continuous economic model; Layer 1 provides global
  slot-based indexing for on-chain storage; Layer 2 constructs
  trade-specific adaptive meshes that preserve all structural points
  (band boundaries, order prices) and enable exact piecewise
  integration.
\item
  \textbf{Unified execution semantics} specifying deterministic
  interaction between CLMM and CLOB liquidity: at each mesh node, all
  marketable CLOB volume is consumed before the price moves into the
  adjacent CLMM segment, ensuring no arbitrage between order types at
  the same price level.
\item
  \textbf{Fixed-point and numerical error analysis} with global
  convergence bounds. We prove that the total error in token deltas is
  bounded by
  \(C(\frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}})\),
  where \(\sigma = 2^F\) is the log-scaling precision and the
  \(\varepsilon\) terms capture exp/log approximation and arithmetic
  rounding. With practical parameters (\(F = 48\), Q64.64 formats),
  global relative price errors reach \(O(10^{-14})\).
\item
  \textbf{A spot-anchored derivative layer} in which perpetual swaps
  have mark price identically equal to spot price, eliminating basis and
  funding rates by construction. We prove this is the unique
  no-arbitrage choice and show that protocol-level delta hedging
  achieves bounded residual risk.
\item
  \textbf{Formal guarantees for the derivative layer}, including:
  uniqueness of spot-anchored mark price under no-arbitrage; bounded
  residual hedging error under discrete execution; monotone and
  reserve-preserving liquidation execution; deterministic
  compositionality of concurrent liquidations; insurance fund solvency
  conditions; and leverage constraints that provably prevent unbounded
  liquidation cascades.
\item
  \textbf{LP risk isolation}: we prove that liquidity providers in the
  spot layer do not warehouse derivative directional risk---from their
  perspective, derivative activity appears only as additional spot order
  flow, and their wealth depends solely on the spot price path and
  aggregate order flow.
\end{itemize}

\subsubsection{1.5 Paper Roadmap}\label{paper-roadmap}

The remainder of this paper is organized as follows:

\textbf{Section 2} introduces the basic setup and notation, defining the
token pair, spot price, sqrt-price, and the log-sqrt-price coordinate
that will serve as our fundamental representation.

\textbf{Section 3} develops the logarithmic representation in its
continuous, idealized form, explaining the choice of base-2 logarithms
and the relationship between log-sqrt-price and economic price.

\textbf{Section 4} specifies the fixed-point encoding of log-sqrt-price,
including scaling factors, encode/decode maps, and the Q-format
conventions used throughout.

\textbf{Section 5} presents the three-layer architecture in detail:
Layer 0's continuous model with CLMM liquidity density and CLOB order
measure; Layer 1's global slot lattice for indexing; Layer 2's adaptive
local mesh construction; and the CLMM dynamics expressed in
log-coordinates with explicit finite-move formulas.

\textbf{Section 6} provides the formal fixed-point specification,
including abstract specifications of \(\exp_2\) and \(\log_2\) routines,
monotonicity requirements, error propagation analysis, and the main
convergence theorem showing that on-chain execution approaches the
continuous model as precision increases.

\textbf{Section 7} defines unified execution semantics for CLMM, CLOB,
and perpetuals on the log-axis, including the deterministic node
execution ordering rule, price path continuity, and the formal treatment
of crossing CLOB orders.

\textbf{Section 8} introduces the spot-anchored derivative layer,
covering perpetual swap definitions, mark-to-market equity, the
elimination of funding rates, protocol-level delta hedging, LP exposure
analysis, and margin/liquidation mechanics.

\textbf{Section 9} establishes formal guarantees for the derivative
layer: no-arbitrage uniqueness of spot-anchored marks, residual hedging
risk bounds, execution validity under hedge flow, liquidation
correctness, fee allocation invariants, computational complexity,
funding-rate elimination theorem, margin dynamics, insurance fund
solvency, compositionality of concurrent liquidations, and dynamic
stability under leverage constraints.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Figure 1: Fragmented vs.~Unified DEX Architecture}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                        CURRENT: FRAGMENTED ARCHITECTURE                     │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                │}
\NormalTok{│   │    CLMM     │      │    CLOB     │      │   PERPS     │                │}
\NormalTok{│   │   (Spot)    │      │   (Spot)    │      │(Derivatives)│                │}
\NormalTok{│   ├─────────────┤      ├─────────────┤      ├─────────────┤                │}
\NormalTok{│   │ Price: √P   │      │ Price: P    │      │ Mark ≠ Spot │                │}
\NormalTok{│   │ Ticks: 1bp  │      │ Discrete    │      │ Funding ≠ 0 │                │}
\NormalTok{│   │ Liquidity A │      │ Liquidity B │      │ Liquidity C │                │}
\NormalTok{│   └──────┬──────┘      └──────┬──────┘      └──────┬──────┘                │}
\NormalTok{│          │                    │                    │                       │}
\NormalTok{│          └────────────────────┼────────────────────┘                       │}
\NormalTok{│                               ▼                                            │}
\NormalTok{│                    ╔═══════════════════╗                                   │}
\NormalTok{│                    ║ PRICE CONVERSIONS ║  ◄── Arbitrage gaps               │}
\NormalTok{│                    ║ FRAGMENTED DEPTH  ║  ◄── Capital inefficiency         │}
\NormalTok{│                    ╚═══════════════════╝                                   │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                        PROPOSED: UNIFIED ARCHITECTURE                       │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│                    ╔═════════════════════════════════╗                     │}
\NormalTok{│                    ║   SINGLE LOG{-}SQRT{-}PRICE AXIS    ║                     │}
\NormalTok{│                    ║         l = log₂(√P)            ║                     │}
\NormalTok{│                    ╚═════════════════════════════════╝                     │}
\NormalTok{│                                   │                                        │}
\NormalTok{│              ┌────────────────────┼────────────────────┐                   │}
\NormalTok{│              ▼                    ▼                    ▼                   │}
\NormalTok{│      ┌─────────────┐      ┌─────────────┐      ┌─────────────┐            │}
\NormalTok{│      │    CLMM     │      │    CLOB     │      │   PERPS     │            │}
\NormalTok{│      │  λ(l) dl    │      │  μ(dl)      │      │ Mark = Spot │            │}
\NormalTok{│      │ Continuous  │      │ Atomic      │      │ Funding = 0 │            │}
\NormalTok{│      └─────────────┘      └─────────────┘      └─────────────┘            │}
\NormalTok{│              │                    │                    │                   │}
\NormalTok{│              └────────────────────┴────────────────────┘                   │}
\NormalTok{│                                   │                                        │}
\NormalTok{│                                   ▼                                        │}
\NormalTok{│                         ┌─────────────────┐                                │}
\NormalTok{│                         │ UNIFIED DEPTH   │ ◄── Single liquidity pool      │}
\NormalTok{│                         │ SHARED PRICING  │ ◄── No arbitrage gaps          │}
\NormalTok{│                         │ ATOMIC HEDGING  │ ◄── Delta{-}neutral perps        │}
\NormalTok{│                         └─────────────────┘                                │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 1: Comparison of current fragmented DEX architecture (top)
versus our proposed unified log-domain architecture (bottom). The
fragmented approach requires price conversions between incompatible
representations and splits liquidity across isolated venues. Our unified
approach places all trading activity---CLMM, CLOB, and derivatives---on
a single log-sqrt-price axis, enabling shared liquidity, atomic hedging,
and elimination of basis/funding.}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{2. Background and Notation}\label{background-and-notation}

Throughout this paper, we consider a market for two tokens, which we
denote \(A\) and \(B\). We write the spot price of \(B\) in terms of
\(A\) as:

\[
P = P_{A,B} > 0
\]

so that \(1\) unit of \(B\) is worth \(P\) units of \(A\).

\subsubsection{2.1 Square-root Price}\label{square-root-price}

Define the square-root price:

\[
S = \sqrt P = P^{1/2} > 0
\]

This is analogous to Uniswap v3's
\textbf{\(sqrtPriceX64 / sqrtPriceX96\)} \autocite{adams2021uniswap},
but we are not committing to any particular scaling yet.

The standard CLMM formulas are usually written in terms of \(S\), not
\(P\). We are going to change the \textbf{representation} of \(S\).

\subsubsection{2.2 Notation Summary}\label{notation-summary}

For reference, we summarize the principal symbols used throughout this
paper:

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1868}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.6923}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1209}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Symbol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Section
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(P\) & Spot price of token \(B\) in terms of token \(A\) & 2 \\
\(S = \sqrt{P}\) & Square-root price & 2.1 \\
\(l = \log_2 S\) & Log-Sqrt-Price (continuous) & 3.1 \\
\(L\) & Fixed-point integer encoding of \(l\) & 4.1 \\
\(\sigma = 2^F\) & Scaling factor for fixed-point encoding (\(F\) =
fractional bits) & 4.1 \\
\(\lambda(l)\) & CLMM liquidity density function at log-price \(l\) &
5.1.2 \\
\(L_i\) & Liquidity amount for CLMM position \(i\) & 5.1.2 \\
\(q_j\) & Quantity for CLOB order \(j\) & 5.1.3 \\
\(q_m\), \(q_i\) & Signed perp position size for account \(m\) or \(i\)
& 7.4.1, 9.12 \\
\(M_i\) & Margin balance for account \(i\) & 9.12.1 \\
\(E_i\) & Equity (net account value) for account \(i\) & 9.12.1 \\
\(\ell_i\) & Effective leverage for account \(i\) & 9.15.1 \\
\(\mathfrak{L}(l)\) & Aggregate leverage measure & 9.15.1 \\
\(Q_S\), \(Q_P\) & Fractional bits in Q-format for \(S\), \(P\)
(fixed-point notation) & 6.2 \\
\end{longtable}
}

\textbf{Notation conventions:}

\begin{itemize}
\tightlist
\item
  \(L\) (no subscript) is the fixed-point integer encoding of
  log-sqrt-price \(l\).
\item
  \(L_i\) (with subscript) denotes CLMM liquidity amounts per position;
  \(q_i\) denotes perp position sizes.
\item
  \(\lambda(l)\) is the aggregate liquidity density (sum of per-position
  \(L_i\)); \(\ell_i(l)\) is per-account leverage; \(\mathfrak{L}(l)\)
  is aggregate leverage.
\item
  In Section 6, \(Q_S\), \(Q_P\), \(Q_Q\) follow standard Q-format
  notation for fixed-point fractional bits, unrelated to liquidity or
  positions.
\end{itemize}

\subsection{3. Logarithmic Representation (Continuous,
Idealized)}\label{logarithmic-representation-continuous-idealized}

Instead of storing \(S\) directly, we store its \textbf{logarithm}.

We choose \textbf{\(base 2\)} for implementation convenience and to
match binary integer arithmetic.

\subsubsection{3.1 Log-Sqrt-Price
(Continuous)}\label{log-sqrt-price-continuous}

Define the \textbf{log-sqrt-price coordinate:}

\[
l = \log_2 S = \log_2 \sqrt P
\]

Since \(S > 0\), we have \(l \in \mathbb{R}\).

Equivalently, in terms of price \(P\):

\[
l = \frac{1}{2} \log_2 P
\]

and conversely:

\[
S = 2^l, \quad P = S^2 = 2^{2l}
\]

So, the ``true'' economic price is recovered by:

\[
P(l) = 2^{2l}
\]

This is the \textbf{continuous} log-domain representation of the
square-root price.

\textbf{Figure 2: Log-Sqrt-Price Coordinate Transformation}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    PRICE COORDINATE TRANSFORMATION                          │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  STEP 1: Spot Price → Sqrt{-}Price        STEP 2: Sqrt{-}Price → Log{-}Sqrt{-}Price│}
\NormalTok{│                                                                             │}
\NormalTok{│       P ──────────────► S                    S ──────────────► l            │}
\NormalTok{│           S = √P                                 l = log₂(S)                │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  EXAMPLE: Price doubling in each coordinate system                          │}
\NormalTok{│                                                                             │}
\NormalTok{│  Linear Price (P):     $100 ────────► $200 ────────► $400                  │}
\NormalTok{│                              ×2            ×2                               │}
\NormalTok{│                                                                             │}
\NormalTok{│  Sqrt{-}Price (S):       10 ─────────► 14.14 ────────► 20                    │}
\NormalTok{│                             ×√2           ×√2                               │}
\NormalTok{│                                                                             │}
\NormalTok{│  Log{-}Sqrt{-}Price (l):   3.32 ───────► 3.82 ─────────► 4.32                  │}
\NormalTok{│                             +0.5          +0.5                              │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  KEY INSIGHT: Multiplicative changes become ADDITIVE in log{-}space          │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │     P{-}axis (linear):   |{-}{-}{-}{-}×4{-}{-}{-}{-}|{-}{-}{-}{-}×4{-}{-}{-}{-}|{-}{-}{-}{-}×4{-}{-}{-}{-}|          │   │}
\NormalTok{│  │                        $25       $100      $400     $1600          │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │     l{-}axis (log):      |{-}{-}{-}{-}+1{-}{-}{-}{-}|{-}{-}{-}{-}+1{-}{-}{-}{-}|{-}{-}{-}{-}+1{-}{-}{-}{-}|          │   │}
\NormalTok{│  │                       2.32      3.32      4.32      5.32           │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │     Equal intervals in l ⟺ Equal percentage changes in P           │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                                                                             │}
\NormalTok{│  FORMULAS:                                                                  │}
\NormalTok{│    Forward:   l = ½ log₂(P) = log₂(√P)                                     │}
\NormalTok{│    Inverse:   P = 2\^{}(2l)    = (2\^{}l)²                                        │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 2: The log-sqrt-price transformation converts
multiplicative price changes into additive movements on the l-axis. A
doubling of price P corresponds to adding 0.5 to the log-sqrt-price l.
This property makes percentage-based operations (like fee tiers,
slippage tolerances, and tick spacing) uniform across all price levels.}

\subsection{4. Fixed-Point Encoding of
Log-Sqrt-Price}\label{fixed-point-encoding-of-log-sqrt-price}

On-chain, we don't store real numbers, only integers. So we encode \(l\)
as a fixed-point integer.

\subsubsection{4.1 Scaling Factor}\label{scaling-factor}

Pick a positive scaling factor \(\sigma \in \mathbb{R_{>0}}\). In
practice, \(\sigma\) will be a power of \(2\) to facilitate
bit-shifting.

\begin{itemize}
\tightlist
\item
  \(\sigma = 2^F\) for some integer \(F > 0\) (number of fractional
  bits) (e.g.~\(F = 32\), \(F = 48\), \(F = 64\) or \(F = 96\))
\end{itemize}

We define the \textbf{fixed-point representation} of \(l\)
(log-sqrt-price):

\[
L \in \mathbb{Z}
\]

with the interpretation:

\[
l = \frac{L}{\sigma}
\]

So:

\begin{itemize}
\tightlist
\item
  \(L\) is the \textbf{on-chain integer representation} of the
  log-sqrt-price
\item
  \(l\) is the \textbf{ideal real-valued log-sqrt-price}
\item
  The mapping is determined by the scaling factor \(\sigma\)
\end{itemize}

\subsubsection{4.2 Encode and Decode Maps}\label{encode-and-decode-maps}

Formally, define:

\begin{itemize}
\tightlist
\item
  \textbf{Encode (real \(\to\) integer)}:
\end{itemize}

\[
\text{encodeLogSqrtPrice}(S) = L = \lfloor \sigma \cdot \log_2 S \rceil
\]

where \(\lfloor . \rceil\) denotes some rounding rule (e.g.~round to
nearest, round down, round up)

\begin{itemize}
\tightlist
\item
  \textbf{Decode (integer \(\to\) approximate real sqrt price)}:
\end{itemize}

\[
\text{decodeLogSqrtPrice}(L) = \hat{S} = 2^{L / \sigma}
\]

The approximate price decoded from \(L\) is:

\[
\hat{P} = \hat{S}^2 = 2^{2L / \sigma}
\]

In exact math, you can treat:

\[
l = \frac{L}{\sigma} \implies P = 2^{2l} = 2^{2L / \sigma}
\]

In implementation, computing \(2^{L / \sigma}\) exactly may not be
possible, so we use approximations efficiently.

\textbf{Figure 3: Fixed-Point Encoding Pipeline}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                     FIXED{-}POINT ENCODING / DECODING                         │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  ENCODING (Continuous → Integer):                                           │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────┐    log₂    ┌─────────┐    ×σ     ┌─────────┐   round   ┌─────┐│}
\NormalTok{│  │ Real S  │ ─────────► │ Real l  │ ────────► │ Real L\textquotesingle{} │ ────────► │  L  ││}
\NormalTok{│  │ (√price)│            │ (cont.) │           │ (scaled)│           │(int)││}
\NormalTok{│  └─────────┘            └─────────┘           └─────────┘           └─────┘│}
\NormalTok{│       │                      │                     │                   │   │}
\NormalTok{│       │                      │                     │                   │   │}
\NormalTok{│       ▼                      ▼                     ▼                   ▼   │}
\NormalTok{│   S = √P              l = log₂(S)           L\textquotesingle{} = σ·l            L = ⌊L\textquotesingle{}⌉  │}
\NormalTok{│                                                                             │}
\NormalTok{│                              ERROR INJECTION POINT: ≤ 1/(2σ)               │}
\NormalTok{│                                                    └─────────────┘          │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  DECODING (Integer → Continuous):                                           │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────┐    ÷σ     ┌─────────┐   exp2fp   ┌─────────┐   ÷2\^{}Qs   ┌─────────┐│}
\NormalTok{│  │  L  │ ────────► │ Approx  │ ─────────► │  S\_fp   │ ────────► │ Approx  ││}
\NormalTok{│  │(int)│           │   l̂     │            │ (fixed) │           │   Ŝ     ││}
\NormalTok{│  └─────┘           └─────────┘            └─────────┘           └─────────┘│}
\NormalTok{│       │                 │                      │                     │     │}
\NormalTok{│       │                 │                      │                     │     │}
\NormalTok{│       ▼                 ▼                      ▼                     ▼     │}
\NormalTok{│   L ∈ ℤ            l̂ = L/σ              S\_fp = exp2fp(L)      Ŝ = S\_fp/2\^{}Qs│}
\NormalTok{│                                                                             │}
\NormalTok{│              ERROR: ≤1/(2σ)        ERROR: ≤ε\_exp2·S              TOTAL     │}
\NormalTok{│              └──────────┘          └────────────────┘          ERROR ≤ ε   │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  ROUND{-}TRIP ERROR BOUND:                                                    │}
\NormalTok{│                                                                             │}
\NormalTok{│    |Ŝ {-} S|     1                                                           │}
\NormalTok{│    ─────── ≤ ───── · ln(2) + ε\_exp2  →  0  as σ → ∞                        │}
\NormalTok{│      S        2σ                                                            │}
\NormalTok{│                                                                             │}
\NormalTok{│  With σ = 2\^{}64:  relative error \textless{} 10\^{}{-}19 (comparable to 128{-}bit float)     │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 3: The fixed-point encoding pipeline transforms continuous
sqrt-price S into an integer L via logarithm, scaling by σ = 2\^{}F, and
rounding. Decoding reverses the process using a fixed-point exp₂
approximation. Error is introduced at the rounding step (bounded by
1/2σ) and the exponential approximation (bounded by ε\_exp2). Total
error vanishes as precision increases.}

\subsection{5. Three-Layer Representation
Architecture}\label{three-layer-representation-architecture}

We define a three-layer price representation architecture:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Layer 0 (Continuous):} A real-valued log-sqrt-price axis
  \(l \in \mathbb{R}\) which is the sole ``source of truth'' for prices
  in the economic model.
\item
  \textbf{Layer 1 (Global Slots):} A fixed discrete lattice in
  \(l\)-space used for on-chain storage and indexing of positions and
  orders.
\item
  \textbf{Layer 2 (Local Mesh):} A trade-specific discretization of a
  bounded interval of \(l\)-space used during execution. This mesh can
  be dynamically adapted per trade to optimize accuracy and performance.
\end{enumerate}

All three layers refer to the same underlying price coordinate \(l\);
layers differ only in how they discretize and organize that axis.

\textbf{Figure 4: Three-Layer Representation Architecture}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    THREE{-}LAYER PRICE REPRESENTATION                         │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  LAYER 0: CONTINUOUS (Mathematical Model)                    [PERSISTENT]   │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     l ∈ ℝ (log{-}sqrt{-}price axis)                                            │}
\NormalTok{│     ──────────────────────────────────────────────────────────────────►    │}
\NormalTok{│                                                                             │}
\NormalTok{│     λ(l): CLMM liquidity density (piecewise constant)                      │}
\NormalTok{│     ┌───┐     ┌───────────┐           ┌─────┐                              │}
\NormalTok{│     │   │     │           │           │     │                              │}
\NormalTok{│     │ L₁│     │    L₂     │           │ L₃  │          λ(l)                │}
\NormalTok{│     │   │     │           │           │     │                              │}
\NormalTok{│     ┴───┴─────┴───────────┴───────────┴─────┴──────────────────►  l        │}
\NormalTok{│                                                                             │}
\NormalTok{│     μ(dl): CLOB orders as Dirac measures                                   │}
\NormalTok{│              ↑         ↑              ↑                                    │}
\NormalTok{│              │q₁       │q₂            │q₃     (atomic at l₀,ⱼ)             │}
\NormalTok{│     ─────────┴─────────┴──────────────┴────────────────────────►  l        │}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  LAYER 1: GLOBAL SLOTS (On{-}Chain Storage)                    [PERSISTENT]   │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     Discrete lattice: lₛ = l\_ref + s · Δl,  s ∈ ℤ                          │}
\NormalTok{│                                                                             │}
\NormalTok{│         s={-}2    s={-}1    s=0     s=1     s=2     s=3     s=4                │}
\NormalTok{│     ─────┼───────┼───────┼───────┼───────┼───────┼───────┼─────►  l        │}
\NormalTok{│          │       │       │       │       │       │       │                 │}
\NormalTok{│          └───────┴───────┴───────┴───────┴───────┴───────┘                 │}
\NormalTok{│                         Δl (slot spacing)                                   │}
\NormalTok{│                                                                             │}
\NormalTok{│     • Each slot stores: LP bands overlapping it, orders nearest to it      │}
\NormalTok{│     • Enables O(1) lookup of relevant liquidity near current price         │}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  LAYER 2: LOCAL MESH (Per{-}Trade Execution)                   [TRANSIENT]    │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     Adaptive mesh for price path [l*, l\_target]:                           │}
\NormalTok{│                                                                             │}
\NormalTok{│     l*        l₁    l₂       l₃  l₄         l₅           l\_target          │}
\NormalTok{│     ●─────────▲─────○────────▲───○──────────▲────────────●                 │}
\NormalTok{│     │         │     │        │   │          │            │                 │}
\NormalTok{│     │ L\_AMM,0 │     │L\_AMM,2 │   │          │  L\_AMM,5   │                 │}
\NormalTok{│     │         │     │        │   │          │            │                 │}
\NormalTok{│     └─────────┴─────┴────────┴───┴──────────┴────────────┘                 │}
\NormalTok{│                                                                             │}
\NormalTok{│     Legend:  ● = endpoints   ▲ = LP boundaries   ○ = CLOB order prices     │}
\NormalTok{│              L\_AMM,k = segment liquidity (constant per segment)             │}
\NormalTok{│                                                                             │}
\NormalTok{│     • Built fresh for each trade, discarded after execution                │}
\NormalTok{│     • Contains all structural points needed for exact execution            │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│  INFORMATION FLOW:                                                          │}
\NormalTok{│                                                                             │}
\NormalTok{│    Layer 0  ──────►  Layer 1  ──────►  Layer 2                             │}
\NormalTok{│    (defines         (indexes for      (executes trade                      │}
\NormalTok{│     economics)       fast lookup)      with precision)                     │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 4: The three-layer architecture separates concerns: Layer 0
defines the continuous economic model with CLMM liquidity density λ(l)
and CLOB atomic measures μ(dl). Layer 1 provides persistent on-chain
indexing via a global slot lattice for efficient state lookup. Layer 2
constructs a transient, trade-specific mesh that captures all structural
points (LP boundaries, order prices, endpoints) needed for exact
execution. Layers 0 and 1 persist between trades; Layer 2 is rebuilt for
each execution.}

\subsubsection{5.1 Layer 0: Continuous Log-Sqrt-Price
Axis}\label{layer-0-continuous-log-sqrt-price-axis}

\paragraph{5.1.1 Price coordinate}\label{price-coordinate}

Let:

\begin{itemize}
\tightlist
\item
  \(P > 0\) be the spot price of token \(B\) in terms of token \(A\).
\item
  \(S = \sqrt P > 0\) be the square-root price.
\item
  \(l = \log_2 S = \frac{1}{2} \log_2 P \in \mathbb{R}\) be the
  continuous log-sqrt-price coordinate.
\end{itemize}

Then:

\[
S = 2^l, \quad P = S^2 = 2^{2l}
\]

We treat \(l \in \mathbb{R}\) as the \textbf{fundamental price
coordinate}. All other quantities (spot price, sqrt price) are derived
functions of \(l\):

\[
S(l) = 2^l, \quad P(l) = 2^{2l}
\]

\paragraph{5.1.2 CLMM liquidity as a piecewise constant
density}\label{clmm-liquidity-as-a-piecewise-constant-density}

Consider a finite or countable family of CLMM positions indexed by
\(i \in I\), each specified by:

\begin{itemize}
\tightlist
\item
  Liquidity amount \(L_i > 0\),
\item
  Lower and upper log-sqrt bounds
  \(l_{lower,i}, l_{upper,i} \in \mathbb{R}\) with
  \(l_{lower,i} < l_{upper,i}\).
\end{itemize}

Position \(i\) contributes constant liquidity \(L_i\) on the interval
\([l_{lower,i}, l_{upper,i}]\) and zero outside.

Define the \textbf{liquidity density function}:

\[
\lambda : \mathbb{R} \to [0, \infty), \quad \lambda(l) = \sum_{i \in I} L_i \cdot 1_{[l_{lower,i}, l_{upper,i}]}(l)
\]

\textbf{Intuitively}, \(\lambda(l)\) tells us ``how much liquidity is
available at log-price \(l\).'' Each LP contributes their liquidity
\(L_i\) only within their chosen range; outside that range, they
contribute nothing. The total liquidity at any price is simply the sum
of all LPs who have ``turned on'' their liquidity at that price.

Here \(1_I\) is the indicator function of interval \(I\):

\[
1_I(l) = \begin{cases}1, & \ l \in I \\ 0, & \ l \notin I \end{cases}
\]

Assumption: we implicitly assume the family
\({(l_{lower,i}, l_{upper,i})}_{i \in I}\) is such that for every
compact interval \(K \subset \mathbb{R}\), the sum
\(\sum_{i \in I} L_i \cdot 1_{[l_{lower,i}, l_{upper,i}]}(l)\) is finite
for all \(l \in K\) (i.e.~locally finite liquidity). This ensures
\(\lambda(l)\) is well-defined and finite on any bounded region of
interest.

Property:

\begin{itemize}
\tightlist
\item
  \(\lambda\) is a \textbf{piecewise constant} with jumps only at the
  endpoints of the intervals \(l_{lower,i}, l_{upper,i}\).
\end{itemize}

At any \(l\), the total \textbf{active CLMM liquidity} in Layer 0
(Section 5.1) is \(\lambda(l)\).

\textbf{Figure 5: CLMM Liquidity Density Function}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    CLMM LIQUIDITY AS PIECEWISE CONSTANT DENSITY             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  Individual LP Positions (each contributes Lᵢ on [l\_lower,i, l\_upper,i]):  │}
\NormalTok{│                                                                             │}
\NormalTok{│  LP₁:           ┌───────────┐                                              │}
\NormalTok{│  (L₁=100)       │           │                                              │}
\NormalTok{│                 └───────────┘                                              │}
\NormalTok{│                                                                             │}
\NormalTok{│  LP₂:      ┌─────────────────────────┐                                     │}
\NormalTok{│  (L₂=150)  │                         │                                     │}
\NormalTok{│            └─────────────────────────┘                                     │}
\NormalTok{│                                                                             │}
\NormalTok{│  LP₃:                    ┌─────────────────┐                               │}
\NormalTok{│  (L₃=80)                 │                 │                               │}
\NormalTok{│                          └─────────────────┘                               │}
\NormalTok{│                                                                             │}
\NormalTok{│  ─────────┴─────┴────────┴─────┴───────────┴─────────────────────────► l   │}
\NormalTok{│         l₁,low  l₂,low  l₁,up l₃,low     l₂,up  l₃,up                      │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  Aggregate Liquidity λ(l) = Σᵢ Lᵢ · 𝟙[l\_lower,i, l\_upper,i](l):            │}
\NormalTok{│                                                                             │}
\NormalTok{│  λ(l)                                                                       │}
\NormalTok{│   ▲                                                                         │}
\NormalTok{│   │                                                                         │}
\NormalTok{│ 330├─────────────────┬─────┐                                               │}
\NormalTok{│   │                 │     │  L₁+L₂+L₃ = 330                                │}
\NormalTok{│ 250├──────────┬─────┘     │                                                │}
\NormalTok{│   │          │           │  L₁+L₂ = 250                                    │}
\NormalTok{│ 150├──┬──────┘           └─────┐                                           │}
\NormalTok{│   │  │                        │  L₂ = 150                                  │}
\NormalTok{│  80│  │                        └────────┐                                  │}
\NormalTok{│   │  │                                  │  L₃ = 80                         │}
\NormalTok{│   0└──┴──────────────────────────────────┴──────────────────────────► l    │}
\NormalTok{│      │   │        │    │            │        │                              │}
\NormalTok{│    l₂,low l₁,low  l₁,up l₃,low     l₂,up   l₃,up                           │}
\NormalTok{│                                                                             │}
\NormalTok{│  KEY: λ(l) jumps only at LP band boundaries (l\_lower,i or l\_upper,i)       │}
\NormalTok{│       λ(l) is constant between consecutive boundaries                       │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 5: CLMM liquidity is modeled as a piecewise constant
density function λ(l). Each LP position i contributes constant liquidity
Lᵢ within its range {[}l\_lower,i, l\_upper,i{]}. The aggregate
liquidity at any point l is the sum of all LP contributions active at
that point. Jumps in λ(l) occur only at LP band boundaries, which become
mandatory mesh nodes in Layer 2.}

\paragraph{\texorpdfstring{5.1.3 CLOB orders as an atomic measure on
\(l\)}{5.1.3 CLOB orders as an atomic measure on l}}\label{clob-orders-as-an-atomic-measure-on-l}

A single limit order \(j\) is given by:

\begin{itemize}
\tightlist
\item
  Side \(side_j \in \{buy, sell\}\)
\item
  Target price \(P_{0,j} > 0\), equivalently target sqrt price
  \(S_{0,j} = \sqrt{P_{0,j}}\)
\item
  Corresponding log-sqrt-price:
\end{itemize}

\[
l_{0,j} = \log_2 S_{0,j} = \frac{1}{2} \log_2 P_{0,j}
\]

\begin{itemize}
\tightlist
\item
  Quantity \(q_j > 0\) (measured in some canonical unit, e.g.~quantity
  of \(B\) for buy orders and quantity of \(A\) or \(B\) for sell
  orders; the precise convention can be defined later).
\end{itemize}

We model CLOB orders as an \textbf{atomic measure} (a sum of point
masses, where each limit order contributes a Dirac delta at its price
level) on \(\mathbb{R}\) (the \(l\)-axis):

Define the signed or vector-valued measure (depending on side
conventions) by:

\[
\mu(dl) = \sum_j q_j \cdot \delta_{l_{0,j}}(dl - l_{0,j})
\]

where \(\delta(\cdot - l_0)\) denotes the Dirac measure at point
\(l_0\).

For a Borel set \(A \subset \mathbb{R}\):

\[
\mu(A) = \sum_{j: l_{0,j} \in A} q_j
\]

At a specific \(l \in \mathbb{R}\), the ``point depth'' of the order
book is:

\[
\mu(\{l\}) = \sum_{j: l_{0,j} = l} q_j
\]

Note:

\begin{itemize}
\tightlist
\item
  In practice, exact equality \(l_{0,j} = l\) is rare; for execution we
  will work with local neighborhoods and local mesh (Section 5.3, Layer
  2). The formal model here treats them as exact points for mathematical
  clarity.
\end{itemize}

\paragraph{5.1.4 Combined liquidity and
depth}\label{combined-liquidity-and-depth}

At Layer 0, the complete economic state along the \(l\)-axis is
characterized by:

\begin{itemize}
\tightlist
\item
  The \textbf{CLMM liquidity density} \(\lambda(l)\),
\item
  The \textbf{CLOB order measure} \(\mu\).
\end{itemize}

These can be combined (conceptually) into a generalized ``liquidity
measure'' consisting of:

\begin{itemize}
\tightlist
\item
  A \textbf{continuous (piecewise constant) part} given by
  \(\lambda(l)\),
\item
  A \textbf{purely atomic part} given by \(\mu\).
\end{itemize}

Perpetuals and risk logic reference the same axis \(l\) for:

\begin{itemize}
\tightlist
\item
  mark price \(P(l)\),
\item
  margin requirements,
\item
  liquidation thresholds, etc.
\end{itemize}

Layer 0 is purely continuous and independent of discretization.

\subsubsection{5.2 Layer 1: Global Log-Price Slots (Persistent
Grid)}\label{layer-1-global-log-price-slots-persistent-grid}

Layer 1 introduces a \textbf{global regular grid} on \(l\)-space to
organize on-chain state. This grid is \textbf{implementation specific}
and does not change the economics from Layer 0 (Section 5.1).

\paragraph{5.2.1 Slot Lattice and
Anchors}\label{slot-lattice-and-anchors}

Fix two real constants:

\begin{itemize}
\tightlist
\item
  A base origin \(l_{ref} \in \mathbb{R}\),
\item
  A positive step \(\Delta l > 0\) (slot spacing in log-sqrt space).
\end{itemize}

Define \textbf{slot indices}:

\[
s \in \mathbb{Z}
\]

and associate to each slot \(s\) an anchor:

\[
l_s = l_{ref} + s \cdot \Delta l
\]

Thus:

\[
\{ l_s : s \in \mathbb{Z} \} = l_{ref} + \Delta l \cdot \mathbb{Z}
\]

is a regular lattice in \(\mathbb{R}\).

If desired, we may also define an \textbf{integer encoding} of \(l_s\)
using the fixed-point scaling factor \(\sigma\) from Section 4.1:

\begin{itemize}
\tightlist
\item
  Recall: log-sqrt-price encode/decode:
\end{itemize}

\[
L = round(\sigma \cdot l) \in \mathbb{Z}, \quad \hat l = \frac{L}{\sigma}
\]

Then for slot \(s\):

\[
L_s = round(\sigma \cdot l_s) = round(\sigma \cdot (l_{ref} + s \cdot \Delta l)) \in \mathbb{Z}
\]

This gives an integer representation of the slot anchors suitable for
on-chain storage and arithmetic. This is an implementation detail;
mathematically, Layer 1 is defined in terms of real anchors \(l_s\).

\paragraph{5.2.2 Slot index of an arbitrary log
price}\label{slot-index-of-an-arbitrary-log-price}

Given any \(l \in \mathbb{R}\), define its \textbf{slot index} by a
chosen rounding rule.

Typical choices:

\begin{itemize}
\tightlist
\item
  \textbf{Floor slot}:
\end{itemize}

\[
s_{\lfloor \cdot \rfloor}(l) = \left\lfloor \frac{l - l_{ref}}{\Delta l} \right\rfloor
\]

so that:

\[
l_{s_{\lfloor \cdot \rfloor}(l)} \leq l < l_{s_{\lfloor \cdot \rfloor}(l) + 1}
\]

\begin{itemize}
\tightlist
\item
  \textbf{Nearest slot}:
\end{itemize}

\[
s_{\text{round}}(l) = \text{round}\left( \frac{l - l_{ref}}{\Delta l} \right)
\]

so that:

\[
\left| l - l_{s_{\text{round}}(l)} \right| \leq \frac{\Delta l}{2}
\]

We will use:

\begin{itemize}
\tightlist
\item
  Floor for \textbf{interval coverage} (LP bands),
\item
  Nearest for \textbf{point-based indexing} (limit orders).
\end{itemize}

\paragraph{5.2.3 Slot indexing for LP
bands}\label{slot-indexing-for-lp-bands}

Consider a position \(i\) with band \([l_{lower,i}, l_{upper,i}]\) in
Layer 0.

Define its \textbf{slot coverage indices}:

\[
s_{lower,i} = \left\lfloor \frac{l_{lower,i} - l_{ref}}{\Delta l} \right\rfloor , \quad s_{upper,i} = \left\lceil \frac{l_{upper,i} - l_{ref}}{\Delta l} \right\rceil
\]

Then we have:

\[
l_{s_{lower,i}} \leq l_{lower,i}, \quad l_{upper,i} \leq l_{s_{upper,i}}
\]

and the band \([l_{lower,i}, l_{upper,i}]\) is contained in the
\textbf{slot interval}:

\[
[l_{s_{lower,i}}, l_{s_{upper,i}}] = [l_{ref} + s_{lower,i} \Delta l, \ l_{ref} + s_{upper,i} \Delta l]
\]

We say that position \(i\) \textbf{spans slots}:

\[
[s_{lower,i}, s_{upper,i}] \cap \mathbb{Z}
\]

On-chain, we can maintain, for each slot index \(s\), a list of
positions \(i\) such that:

\[
s \in [s_{lower,i}, s_{upper,i}]
\]

i.e.~positions whose bands intersect the slot's anchor region. This
allows us to discover candidate LP positions near a given price by
searching slots in a small neighborhood of the current slot.

Formally, define the per-slot LP set:

\[
\mathcal{I}_s = \{ i \in I : s_{lower,i} \leq s \leq s_{upper,i} \}
\]

Then for any \(l\) such that \(l \in [l_s, l_{s+1})\), we know any band
covering \(l\) is included in some \(\mathcal{I}_{s'}\) with
\(s' \in \{s-1, s, s+1\}\) (depending on how you define coverage).
Implementation can refine the exact window.

\paragraph{5.2.4 Slot indexing of limit
orders}\label{slot-indexing-of-limit-orders}

Let order \(j\) have log-sqrt-price \(l_{0,j}\).

Define its \textbf{slot index} via nearest-slot rounding:

\[
s_j = \text{round}\left( \frac{l_{0,j} - l_{ref}}{\Delta l} \right)
\]

By construction:

\[
\left| l_{0,j} - l_{s_j} \right| \leq \frac{\Delta l}{2}
\]

On-chain, we store order IDs in per-slot order lists \(\mathcal{J}_s\),
where:

\[
\mathcal{J}_s = \{ j : s_j = s \}
\]

Crucially:

\begin{itemize}
\tightlist
\item
  We store the \textbf{exact} \(l_{0,j}\) (or exact encoded price)
  inside the order's record.
\item
  The slot index \(s_j\) is a \textbf{pure indexing hint} used to
  quickly discover orders whose prices are near the current price.
\end{itemize}

Approximation property:

\begin{itemize}
\tightlist
\item
  If at current log-price \(l_*\) we want to find all orders with
  \(\left| l_{0,j} - l_* \right| \leq \mathbb{R}\), we can search slots:
\end{itemize}

\[
s \in \left[ s_{\text{round}}(l_* - \mathbb{R}), \ s_{\text{round}}(l_* + \mathbb{R}) \right]
\]

and then filter by the exact \(l_{0,j}\) in each slot's list.

\paragraph{5.2.5 Layer 1 as an implementation
layer}\label{layer-1-as-an-implementation-layer}

Summary of Layer 1 (Section 5.2):

\begin{itemize}
\tightlist
\item
  The pair \((l_{ref}, \Delta l)\) defines a \textbf{global grid
  resolution} in log-sqrt space.
\item
  Each LP band and each CLOB order is mapped to \textbf{integer slot
  indices} for storage:

  \begin{itemize}
  \tightlist
  \item
    LP positions: interval of slots \([s_{lower,i}, s_{upper,i}]\),
  \item
    CLOB orders: single slot \(s_j\).
  \end{itemize}
\item
  This mapping is \textbf{many-to-one}: many LPs and orders can live in
  the same slot; a single band may span multiple slots.
\item
  \(\Delta l\) is an implementation parameter; it does not constrain
  Layer-0 prices, which remain fully continuous in \(l\).
\end{itemize}

\subsubsection{5.3 Layer 2: Local Execution Mesh (Adaptive
Discretization)}\label{layer-2-local-execution-mesh-adaptive-discretization}

Layer 2 defines a \textbf{trade-specific discretization} over a bounded
interval of \(l\)-space. Conceptually:

\begin{itemize}
\tightlist
\item
  Layer 2 takes the continuous data (\(\lambda\), \(\mu\)) from Layer 0
  (Section 5.1),
\item
  Restricts it to a price path interval,
\item
  and approximates it by a finite number of \textbf{nodes} and
  \textbf{segments}.
\end{itemize}

This local mesh is built transiently for each execution and discarded
afterward.

\paragraph{5.3.1 Price path interval}\label{price-path-interval}

Let:

\begin{itemize}
\tightlist
\item
  \(l_* \in \mathbb{R}\) be the current log-sqrt-price,
\item
  \(l_{target} \in \mathbb{R}\) be a predicted or upper bound on the
  final log-sqrt-price the trade may reach. The exact \(l_{target}\) may
  be derived from trade size estimates, user price limits, or a bounding
  interval for execution.
\end{itemize}

Define the \textbf{price path interval} \(I_{path}\) as:

\[
I_{path} = \begin{cases}
[l_*, l_{target}], & \text{if } l_{target} \ge l_* \\
[l_{target}, l_*], & \text{if } l_{target} < l_*
\end{cases}
\]

By definition, \(I_{path}\) is a compact interval in \(\mathbb{R}\).

Define:

\begin{itemize}
\tightlist
\item
  \(LP\_set(I_{path}) = \{ i : [l_{lower,i}, l_{upper,i}] \cap I_{path} \neq \emptyset \}\):
  LPs that intersect the path,
\item
  \(ORD\_set(I_{path}) = \{ j : l_{0,j} \in I_{path} \}\): orders whose
  prices lie in the path.
\end{itemize}

These sets are \textbf{finite} under reasonable assumptions (finite
state per pair, bounded book near current price).

\paragraph{5.3.2 Structural Mesh Points}\label{structural-mesh-points}

We define a preliminary set of \textbf{structural points} in
\(I_{path}\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{LP boundaries inside the path.}

  For each \(i \in LP\_ set(I_{path})\), include:

  \begin{itemize}
  \tightlist
  \item
    \(l_{lower,i}\) if \(l_{lower,i}\) \(\in I_{path}\),
  \item
    \(l_{upper,i}\) if \(l_{upper,i}\) \(\in I_{path}\).
  \end{itemize}

  Denote this set:

  \[
  \mathcal{B}_{LP} = \{ l_{lower,i} : i \in LP\_ set(I_{path}), l_{lower,i} \in I_{path} \} \cup \{ l_{upper,i} : i \in LP\_ set(I_{path}), l_{upper,i} \in I_{path} \}
  \]
\item
  \textbf{Limit order prices inside the path.}

  For each \(j \in ORD\_ set(I_{path})\), include \(l_{0,j}\).

  Denote this set:

  \[
  \mathcal{B}_{ORD} = \{ l_{0,j} : j \in ORD\_ set(I_{path}) \}
  \]
\item
  \textbf{Endpoints of the path.}
\end{enumerate}

Always include \(l_*\) and \(l_{target}\):

\[
\mathcal{B}_{END} = \{ l_*, l_{target} \}
\]

Define the set of \textbf{mandatory mesh nodes}:

\[
\mathcal{B} = \mathcal{B}_{LP} \cup \mathcal{B}_{ORD} \cup \mathcal{B}_{END}
\]

By construction:

\begin{itemize}
\tightlist
\item
  \(\mathcal{B}\) is a finite (assuming finite LP/ORD in a bounded
  region),
\item
  \(\mathcal{B} \subset I_{path}\),
\item
  \(\mathcal{B}\) contains all LP band boundaries and order prices
  within the path.
\end{itemize}

\paragraph{5.3.3 Optional refinement
points}\label{optional-refinement-points}

To control numerical error and microstructure granularity, the protocol
may add \textbf{refinement points} inside sub-intervals.

\textbf{Figure 6: Local Mesh Construction for Trade Execution}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                      LAYER 2: LOCAL MESH CONSTRUCTION                        │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  INPUTS:                                                                    │}
\NormalTok{│  • Current price l* and target l\_target define I\_path = [l*, l\_target]     │}
\NormalTok{│  • LP bands intersecting I\_path: \{(l\_lower,i, l\_upper,i, Lᵢ)\}              │}
\NormalTok{│  • CLOB orders in I\_path: \{(l₀,ⱼ, qⱼ)\}                                      │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  STEP 1: Collect Mandatory Structural Points                               │}
\NormalTok{│                                                                             │}
\NormalTok{│      l*                                                 l\_target            │}
\NormalTok{│      │                                                      │               │}
\NormalTok{│      ▼                                                      ▼               │}
\NormalTok{│  ────■──────────────────────────────────────────────────────■────► l       │}
\NormalTok{│      │         │         │    │     │         │             │               │}
\NormalTok{│      │    l\_lower,1  l\_upper,1 │  l\_lower,2  l\_upper,2      │               │}
\NormalTok{│      │         ▼         ▼    │     ▼         ▼             │               │}
\NormalTok{│  ────■─────────▲─────────▲────●─────▲─────────▲─────────────■────► l       │}
\NormalTok{│                                    │                                        │}
\NormalTok{│                              l₀,ⱼ (order)                                   │}
\NormalTok{│                                                                             │}
\NormalTok{│  Legend:  ■ = endpoints (B\_END)                                            │}
\NormalTok{│           ▲ = LP boundaries (B\_LP)                                         │}
\NormalTok{│           ● = CLOB order prices (B\_ORD)                                    │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  STEP 2: (Optional) Add Refinement Points                                  │}
\NormalTok{│                                                                             │}
\NormalTok{│      ■─────────▲────·────▲────●────·▲─────────▲─────────────■               │}
\NormalTok{│                     ·              ·                                        │}
\NormalTok{│                   refinement points (for numerical precision)               │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  STEP 3: Sort and Deduplicate → Final Mesh M                               │}
\NormalTok{│                                                                             │}
\NormalTok{│      l₀      l₁      l₂     l₃    l₄     l₅      l₆      l₇                │}
\NormalTok{│      ■───────▲───────·──────▲─────●──────▲───────▲───────■                  │}
\NormalTok{│      │       │       │      │     │      │       │       │                  │}
\NormalTok{│      └───┬───┴───┬───┴──┬───┴──┬──┴──┬───┴───┬───┴───┬───┘                  │}
\NormalTok{│          │       │      │      │     │       │       │                      │}
\NormalTok{│       L\_AMM,0  L\_AMM,1 L\_AMM,2 L\_AMM,3 L\_AMM,4 L\_AMM,5 L\_AMM,6              │}
\NormalTok{│                                                                             │}
\NormalTok{│      Each segment [lₖ, lₖ₊₁] has constant liquidity L\_AMM,k                │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  PROPERTIES:                                                                │}
\NormalTok{│  ✓ M = \{l₀ \textless{} l₁ \textless{} ... \textless{} lₙ\} is finite and ordered                         │}
\NormalTok{│  ✓ All LP boundaries in I\_path appear as mesh nodes                        │}
\NormalTok{│  ✓ All CLOB order prices in I\_path appear as mesh nodes                    │}
\NormalTok{│  ✓ λ(l) is constant on each open segment (lₖ, lₖ₊₁)                        │}
\NormalTok{│  ✓ Segment formulas apply exactly with L = L\_AMM,k                         │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 6: Layer 2 constructs a local mesh M by collecting all
structural points within the trade's price path interval: LP band
boundaries, CLOB order prices, and path endpoints. Optional refinement
points may be added for numerical precision. The resulting sorted mesh
partitions I\_path into segments, each with constant CLMM liquidity,
enabling exact application of the segment execution formulas.}

To keep the mesh size tractable while improving accuracy, we may add
refinement points according to the following strategies:

Let \(\mathcal{R} \subset I_{path}\) be a finite set of additional
points determined by some rule, e.g.:

\begin{itemize}
\tightlist
\item
  Subdivision by a fixed log-step \(\delta l_{refine} > 0\),
\item
  Adaptive subdivision where \(\left | \lambda(l) \right|\) is large,
\item
  Points chosen to satisfy specific error bounds on CLMM integrals.
\end{itemize}

We require:

\begin{itemize}
\tightlist
\item
  \(\mathcal{R}\) is finite,
\item
  \(\mathcal{R}\) does not duplicate points in \(\mathcal{B}\) (or we
  can deduplicate later).
\end{itemize}

The final \textbf{mesh node set} is:

\[
\mathcal{M} = \mathcal{B} \cup \mathcal{R} \subset I_{path}
\]

Define \(\mathcal{M}\) sorted in strictly increasing order:

\[
\mathcal{M} = \{ l_0 < l_1 < \ldots < l_{N} \}, \quad {l_0 < l_1 < \ldots < l_{N}}
\]

By construction:

\begin{itemize}
\tightlist
\item
  \(l_0 = \min(I_{path})\), \(l_{N} = \max(I_{path})\),
\item
  Every LP boundary and order price in \(I_{path}\) appears as some
  \(l_k\).
\end{itemize}

The mesh partitions the path:

\[
I_{path} = \bigcup_{k=0}^{N-1} [l_k, l_{k+1}]
\]

with pairwise disjoint interiors.

\paragraph{5.3.4 Local discretization of AMM
liquidity}\label{local-discretization-of-amm-liquidity}

On each segment \([l_k, l_{k+1}]\) we approximate the continuous
liquidity density \(\lambda(l)\) from Layer 0 by a \textbf{segment-wise
constant} effective liquidity \(L_{AMM,k}\).

Possible choices:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Midpoint sampling:}

  Let

  \[
  \bar{l}_k = \frac{l_k + l_{k+1}}{2}
  \]

  Define:

  \[
  L_{AMM,k} = \lambda(\bar{l}_k)
  \]
\item
  \textbf{Exact average}:

  If we want an exact match to the integral of \(\lambda\) over the
  segment:

  \[
  L_{AMM,k} = \frac{1}{l_{k+1} - l_k} \int_{l_k}^{l_{k+1}} \lambda(l) \ dl
  \]

  Since \(\lambda\) is piecewise constant in \(l\), this integral is
  trivial to compute exactly from the bands.
\end{enumerate}

In either case, define the \textbf{segment liquidity approximation}:

\[
\lambda_{k}(l) = \begin{cases} L_{AMM,k}, & l \in [l_k, l_{k+1}] \\ 0, & \text{otherwise} \end{cases}
\]

and the \textbf{mesh-based liquidity density}:

\[
\lambda^{(\mathcal{M})} (l) = \sum_{k=0}^{N-1} L_{AMM,k} \cdot 1_{[l_k, l_{k+1}]}(l)
\]

Error remark:

\begin{itemize}
\tightlist
\item
  As the \textbf{mesh diameter} \(max_{k} (l_{k+1} - l_k) \to 0\) and
  sampling/averaging is chosen appropriately,
  \(\lambda^{(\mathcal{M})}(l) \to \lambda(l)\) almost everywhere.
\item
  For piecewise constant \(\lambda\), if mesh boundaries include all
  band boundaries, the exact choice \(L_{AMM,k}= \lambda(\bar{l}_k)\)
  yields \textbf{zero error} almost everywhere; the only differences can
  occur at endpoints, which are measure-zero for integrals.
\end{itemize}

\paragraph{5.3.5 Local discretization of CLOB
depth}\label{local-discretization-of-clob-depth}

On the mesh nodes \{\(l_k\)\}, we attach the CLOB atomic measure:

For each node \(l_k\), define the set of orders at that node:

\[
\mathcal{J}_k = \{ j : l_{0,j} = l_k \}
\]

For each \(k\), the total quantity at \(l_k\) is:

\[
Q_{CLOB,k} = \sum_{j \in \mathcal{J}_k} q_j
\]

In the ideal continuous model, many orders may have prices not exactly
equal to the chosen \(l_k\). In practice, the mesh construction would:

\begin{itemize}
\tightlist
\item
  either include \(l_{0,j}\) as a mesh node if
  \(j \in ORD\_ set(I_{path})\) (which we already do in
  \(\mathcal{B}_{ORD}\)),
\item
  or approximate price levels if you choose to snap them.
\end{itemize}

In our formal construction above (Section 5.3.2), we \textbf{included
every} \(l_{0,j}\) in \(\mathcal{M}\), so:

\begin{itemize}
\tightlist
\item
  For any \(j \in ORD\_ set(I_{path})\), there exists a unique \(k\)
  such that \(l_k = l_{0,j}\),
\item
  Therefore, every order in the path is represented exactly at some
  node.
\end{itemize}

Layer-2 ``CLOB structure'' on the mesh is then:

\begin{itemize}
\tightlist
\item
  A finite set of nodes with attached order queues (buys/sells) and
  total depth \(Q_{CLOB,k}\).
\end{itemize}

\paragraph{5.3.6 Execution along the local
mesh}\label{execution-along-the-local-mesh}

Given a trade (swap, market order, liquidation, etc.), we proceed as
follows (at a high level).

Let:

\begin{itemize}
\item
  \(l_{curr} = l_*\) be the starting node (there is some index \(k_*\)
  such that \(l_{k_*} = l_{curr}\); if not, we can treat \(l_*\) as
  lying within a segment and start from that segment),
\item
  A trade direction (e.g.~buy \(B\) with \(A\) or vice versa) determines
  the direction in \(l\)-space:

  \begin{itemize}
  \tightlist
  \item
    e.g.~buying \(B\) with \(A\) might push price up, so we move from
    low \(l\) to high \(l\),
  \item
    selling \(B\) might push price down, so we move from high \(l\) to
    low \(l\).
  \end{itemize}
\end{itemize}

The execution algorithm:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Initialization.}

  \begin{itemize}
  \tightlist
  \item
    Determine direction of price movement and thus whether to traverse
    nodes \(k_*, k_*+1, k_*+2, \ldots\) or \(k_*, k_*-1, k_*-2, \ldots\)
  \item
    Initialize remaining trade size (quantity to buy/sell).
  \end{itemize}
\item
  \textbf{CLOB matching at current node.}

  At node \(l_{k}\):

  \begin{itemize}
  \tightlist
  \item
    Identify opposing orders in \(\mathcal{J}_k\) (depending on trade
    side).
  \item
    Match the trade against these orders up to:

    \begin{itemize}
    \tightlist
    \item
      the node's total quantity \(Q_{CLOB,k}\),
    \item
      or until the remaining trade quantity is exhausted.
    \item
      or until a user-defined or protocol-defined price/size limit is
      reached.
    \end{itemize}
  \item
    Update order book state and trader balances accordingly.
  \end{itemize}
\item
  \textbf{AMM execution on the next segment.}

  If there is remaining trade quantity after CLOB matching at \(l_k\),
  we consider the adjacent segment in the direction of price movement:

  \begin{itemize}
  \tightlist
  \item
    If moving up: segment \([l_k, l_{k+1}]\) with liquidity
    \(L_{AMM,k}\),
  \item
    If moving down: segment \([l_{k-1}, l_k]\) with liquidity
    \(L_{AMM,k-1}\).
  \end{itemize}

  We then apply the CLMM invariant over that segment, using the
  approximated constant liquidity \(L_{AMM,k}\) and the mapping
  \(P(l) = 2^{2l}\) to compute:

  \begin{itemize}
  \tightlist
  \item
    The \textbf{maximum tradable amount} on that segment before reaching
    the boundary \(l_{k+1}\) (or \(l_{k-1}\)),
  \item
    the resulting change in \(l\) if we execute only a partial portion
    of the segment capacity.
  \end{itemize}

  Let:

  \begin{itemize}
  \tightlist
  \item
    \(\Delta qty_k^{max}\) = maximum quantity the AMM can offer on that
    segment,
  \item
    \(\Delta qty_{needed}\) = remaining quantity for the trade.
  \end{itemize}

  If \(\Delta qty_{needed} \leq \Delta qty_k^{max}\), we:

  \begin{itemize}
  \tightlist
  \item
    Compute the final log-price \(l_{final} \in [l_k, l_{k+1}]\),
    consistent with the invariant and the consumed amount,
  \item
    Update balances and terminate the trade.
  \end{itemize}

  If \(\Delta qty_{needed} > \Delta qty_k^{max}\), we:

  \begin{itemize}
  \tightlist
  \item
    Consume the entire segment capacity, moving price to the boundary
    \(l_{k+1}\) (or \(l_{k-1}\)),
  \item
    Update balances and remaining trade amount,
  \item
    Move to the next node and repeat from step 2.
  \end{itemize}
\item
  \textbf{Termination conditions.}

  Execution terminates when:

  \begin{itemize}
  \tightlist
  \item
    The trade is fully filled (remaining quantity = 0),
  \item
    The path endpoint \(l_{target}\) is reached,
  \item
    Liquidity is exhausted (no more CLMM liquidity or CLOB orders in the
    direction),
  \item
    or some risk/user constraint (max slippage, oracle bounds, etc.) is
    hit.
  \end{itemize}
\end{enumerate}

From a mathematical perspective, this is equivalent to integrating the
continuous CLMM liquidity and CLOB atoms along the path with a
\textbf{piecewise constant} approximation \(\lambda^{(\mathcal{M})}\)
and exact CLOB points at nodes.

\paragraph{5.3.7 Convergence to the continuous
model}\label{convergence-to-the-continuous-model}

Let \(\mathcal{M}_n\) be a sequence of meshes on \(I_{path}\) such that:

\begin{itemize}
\tightlist
\item
  All band boundaries and order prices are always included in
  \(\mathcal{M}_n\),
\item
  The mesh \textbf{diameter}
  \(\delta_n = \max_{k} (l_{k+1}^{(n)} - l_k^{(n)}) \to 0\) as
  \(n \to \infty\).
\item
  The segment liquidity approximations \(L_{AMM,k}^{(n)}\) is chosen via
  midpoint or average sampling.
\end{itemize}

Then:

\begin{itemize}
\tightlist
\item
  The mesh-based liquidity density \(\lambda^{(\mathcal{M}_n)}\)
  converges to \(\lambda\) almost everywhere,
\item
  The integrated quantities (e.g.~total amount of token traded along the
  path) computed by the mesh-based execution converge to those of the
  ideal continuous model, assuming the CLMM differential equations in
  \(l\) are well-posed and Lipschitz in the relevant region.
\end{itemize}

Intuitively: as segments get finer, the discrete stepwise execution
becomes indistinguishable (within numerical precision) from integrating
the continuous dynamics of the underlying AMM + CLOB along \(l\).

\subsubsection{5.4 CLMM Dynamics in Log-Sqrt-Price
Coordinates}\label{clmm-dynamics-in-log-sqrt-price-coordinates}

We keep the token notation from Section 1:

\begin{itemize}
\tightlist
\item
  Tokens: \(A\) and \(B\),
\item
  Price of \(B\) in terms of \(A\): \(P > 0\),
\item
  Square-root price: \(S = \sqrt P > 0\),
\item
  Log-sqrt-price: \(l = \log_2 S = \frac{1}{2} \log_2 P\), so
  \(S = 2^l\), \(P = 2^{2l}\).
\end{itemize}

We consider the CLMM part of the system with \textbf{instantaneous
aggregate liquidity} \(\lambda(l)\) as defined in Layer 0 (Section
5.1.2):

\[
\lambda(l) = \sum_{i \in I} L_i \cdot 1_{[l_{lower,i}, l_{upper,i}]}(l)
\]

On any open interval where \(\lambda\) is constant, the CLMM behaves
like a classical concentrated liquidity AMM with \textbf{constant
liquidity} over that price region.

\paragraph{5.4.1 CLMM Differential in Sqrt-price
(S)}\label{clmm-differential-in-sqrt-price-s}

On an interval where the \textbf{aggregate liquidity} is constant and
equal to some value \(L > 0\), the standard Uniswap v3-style CLMM
formulas \autocite{adams2021uniswap} for moving the square-root price
from \(S\) to \(S + dS\) are:

\begin{itemize}
\tightlist
\item
  Pool's infinitesimal change in token \(A\) reserves:
\end{itemize}

\[
\frac{dA}{dS} = - \frac{L}{S^2}
\]

\begin{itemize}
\tightlist
\item
  Pool's infinitesimal change in token \(B\) reserves:
\end{itemize}

\[
\frac{dB}{dS} = L
\]

These differential relations integrate to the familiar finite formulas
for constant liquidity \(L\) over a price move from \(S_a\) to \(S_b\):

\[
\Delta A = L \left( \frac{1}{S_a} - \frac{1}{S_b} \right), \quad \Delta B = L (S_b - S_a)
\]

where \(\Delta A, \Delta B\) are the pool's reserve changes (the
trader's changes are \(-\Delta A, -\Delta B\)).

The signs are determined by the direction of \(S\):

\begin{itemize}
\tightlist
\item
  If \(S_b > S_a\), then \(\Delta B > 0\) and \(\Delta A < 0\),
\item
  If \(S_b < S_a\), then \(\Delta B < 0\) and \(\Delta A > 0\).
\end{itemize}

We will keep this orientation and simply regard \(\Delta A, \Delta B\)
as \textbf{pool deltas} as a function of the ordered pair
\((S_a, S_b)\).

\paragraph{\texorpdfstring{5.4.2 Change of Variables to Log-Sqrt-Price
(\(l\))}{5.4.2 Change of Variables to Log-Sqrt-Price (l)}}\label{change-of-variables-to-log-sqrt-price-l}

We now express everything in terms of \(l\).

Recall:

\[
S = 2^l, \quad \frac{dS}{dl} = (\ln 2) \cdot 2^l = (\ln 2) \cdot S
\]

so:

\[
dS = (\ln 2) \cdot S \ dl
\]

On an interval where the aggregate liquidity equals some constant \(L\),
we have:

\[
\frac{dA}{dl} = \frac{dA}{dS} \cdot \frac{dS}{dl} = -\frac{L}{S^2} \cdot (\ln 2) \cdot S = - L (\ln 2) \cdot \frac{1}{S}
\]

Similarly:

\[
\frac{dB}{dl} = \frac{dB}{dS} \cdot \frac{dS}{dl} = L \cdot (\ln 2) \cdot S
\]

Using \(S = 2^l\) and \(\frac{1}{S} = 2^{-l}\), we can write:

\[
\frac{dA}{dl} = - L (\ln 2) \cdot 2^{-l}, \quad \frac{dB}{dl} = L (\ln 2) \cdot 2^{l}
\]

Thus, in \textbf{log-sqrt-price coordinates} \(l\), the CLMM
differential system for a constant-liquidity region is:

\[
\boxed{
dA(l) = - L (\ln 2) \cdot 2^{-l} \ dl
, \quad
dB(l) = L (\ln 2) \cdot 2^{l} \ dl
}
\]

\textbf{Intuitively}, as the price moves up (\(dl > 0\)), the pool gains
token \(B\) and loses token \(A\)---this is because buyers are
purchasing \(B\) with \(A\). The factors \(2^{-l}\) and \(2^l\) capture
how the same percentage price move requires different absolute token
amounts at different price levels: at higher prices, each tick costs
more \(A\) but fewer \(B\).

Again, these are \textbf{pool-level differentials}; the trader's
infinitesimal changes are the negatives.

\paragraph{\texorpdfstring{5.4.3 Integrated Form in \(l\): Finite
Moves}{5.4.3 Integrated Form in l: Finite Moves}}\label{integrated-form-in-l-finite-moves}

Suppose we move log-sqrt-price from \(l_a\) to \(l_b\) with
\(l_b \neq l_a\), in a region where liquidity is constant and equal to
\(L\).

Define the pool deltas:

\[
\Delta A (l_a \to l_b; L) := A(l_b) - A(l_a), \quad \Delta B (l_a \to l_b; L) = B(l_b) - B(l_a)
\]

Integrate the differentials:

\[
\Delta A (l_a \to l_b; L) = \int_{l_a}^{l_b} dA(l) = -L (\ln 2) \int_{l_a}^{l_b} 2^{-l} \ dl
\]

But:

\[
\int 2^{-l} \ dl = \frac{2^{-l}}{-\ln 2} + C
\]

so:

\[
\Delta A (l_a \to l_b; L) = -L (\ln 2) \left[ \frac{2^{-l}}{-\ln 2} \right]_{l_a}^{l_b} = L \left[ 2^{-l} \right]_{l_a}^{l_b} = L (2^{-l_b} - 2^{-l_a})
\]

Similarly:

\[
\Delta B (l_a \to l_b; L) = \int_{l_a}^{l_b} dB(l) = L (\ln 2) \int_{l_a}^{l_b} 2^{l} \ dl
\]

And:

\[
\int 2^{l} \ dl = \frac{2^{l}}{\ln 2} + C
\]

so:

\[
\Delta B (l_a \to l_b; L) = L (\ln 2) \left[ \frac{2^{l}}{\ln 2} \right]_{l_a}^{l_b} = L \left[ 2^{l} \right]_{l_a}^{l_b} = L (2^{l_b} - 2^{l_a})
\]

Hence the exact \textbf{finite-move formulas} in terms of \(l\) are:

\[
\boxed{
\Delta A (l_a \to l_b; L) = L (2^{-l_b} - 2^{-l_a}), \quad \Delta B (l_a \to l_b; L) = L (2^{l_b} - 2^{l_a})
}
\]

\textbf{Intuitively}, these formulas give the exact token amounts
exchanged when price moves from \(l_a\) to \(l_b\). If price goes up
(\(l_b > l_a\)), then \(\Delta B > 0\) (pool receives \(B\)) and
\(\Delta A < 0\) (pool pays out \(A\)). The liquidity parameter \(L\)
acts as a multiplier: more liquidity means larger trades are needed to
move the price by the same amount.

These are equivalent to the classical CLMM formulas expressed in terms
of \(S\):

\begin{itemize}
\tightlist
\item
  Since \(S_a = 2^{l_a}\) and \(S_b = 2^{l_b}\), we have:
\end{itemize}

\[
2^{-l_a} = \frac{1}{S_a}, \quad 2^{-l_b} = \frac{1}{S_b}
\]

Thus:

\[
\Delta A (l_a \to l_b; L) = L \left( \frac{1}{S_b} - \frac{1}{S_a} \right), \quad \Delta B (l_a \to l_b; L) = L (S_b - S_a)
\]

which matches the known CLMM expressions.

\paragraph{\texorpdfstring{5.4.4 Extension to General Liquidity Density
\(\lambda(l)\)}{5.4.4 Extension to General Liquidity Density \textbackslash lambda(l)}}\label{extension-to-general-liquidity-density-lambdal}

In the continuous Layer-0 model (Section 5.1), aggregate liquidity can
vary with \(l\):

\[
\lambda(l) = \sum_{i \in I} L_i \cdot 1_{[l_{lower,i}, l_{upper,i}]}(l)
\]

On any open interval where \(\lambda\) is constant (no band endpoints
inside), we can set \(L = \lambda(l)\) and apply the previous formulas.
At \textbf{band boundaries} where \(\lambda\) jumps, the differential
equations still hold away from the point, and finite moves are obtained
by piecewise integration across the intervals.

In differential form, for arbitrary \(\lambda(l)\), we can write:

\[
\boxed{
dA(l) = - \lambda(l) (\ln 2) \cdot 2^{-l} \ dl
, \quad
dB(l) = \lambda(l) (\ln 2) \cdot 2^{l} \ dl
}
\]

Integrating from \(l_a\) to \(l_b\):

\[
\Delta A (l_a \to l_b) = - (\ln 2) \int_{l_a}^{l_b} \lambda(l) \cdot 2^{-l} \ dl, \quad \Delta B (l_a \to l_b) = (\ln 2) \int_{l_a}^{l_b} \lambda(l) \cdot 2^{l} \ dl
\]

In our setting, \(\lambda(l)\) is piecewise constant and we will
deliberately choose the local mesh to have nodes at all jump points
(band boundaries). That allows us to treat \(\lambda\) as constant on
each segment (\(l_k, l_{k+1}\)), which leads directly into the
segment-wise execution formulas (Section 5.5).

\textbf{Remark (Custom Liquidity Densities):} The formalism above
applies to \textbf{arbitrary} \(\lambda(l)\), not only piecewise
constant bands. This allows future extensions such as: (1) Gaussian or
smooth density profiles concentrated around active prices, (2)
volatility-responsive liquidity adjustments based on market conditions,
and (3) risk-optimized LP strategies that minimize impermanent loss
{[}9, 10{]}. Such distributions can be represented exactly in the
Layer-0 continuous model (Section 5.1) and approximated via adaptive
mesh refinement in Layer 2 (Section 5.3), enabling capital-efficient
strategies beyond traditional uniform CLMM bands.

\paragraph{5.4.5 Alternative Invariants}\label{alternative-invariants}

Throughout this subsection we have used the standard constant-product
CLMM as a canonical example, leading to the familiar \(x y = k\)-style
behavior when expressed in suitable coordinates. However, the Layer-0 /
Layer-2 machinery developed in Sections 4.1--4.3 does not depend on this
particular invariant. The only structural requirements are that the AMM
admit:

\begin{itemize}
\tightlist
\item
  a well-defined price process that can be parameterized as a monotone
  function of the log-sqrt coordinate \(l\), and
\item
  well-defined infinitesimal token-flow differentials \((dA(l), dB(l))\)
  along that price process.
\end{itemize}

Any CFMM whose invariant can be written in this form can be represented
as a dynamics on \(l\) and then discretized on the local mesh exactly as
in Section 5.5, with liquidity summarized in an aggregate density
\(\lambda(l)\). In particular, ``log-based'' invariants defined directly
in the log-price or log-sqrt-price domain --- rather than via an
underlying \((x,y)\) polynomial --- are a natural direction for further
research and can be incorporated into the same framework by specifying
their associated price map and differentials.

\subsubsection{5.5 Segment-wise CLMM Execution on the Local
Mesh}\label{segment-wise-clmm-execution-on-the-local-mesh}

We now plug the \textbf{segment liquidity} \(L_{AMM,k}\) from Layer 2
(Section 5.3) into the above CLMM differential (Section 5.4) to obtain
explicit \textbf{per-segment execution math}.

Recall from the local mesh construction:

\begin{itemize}
\tightlist
\item
  We have an ordered mesh:
\end{itemize}

\[
\mathcal{M} = \{ l_0 < l_1 < \ldots < l_{N} \}
\]

\begin{itemize}
\tightlist
\item
  The price path interval is partitioned as:
\end{itemize}

\[
I_{path} = \bigcup_{k=0}^{N-1} [l_k, l_{k+1}]
\]

\begin{itemize}
\tightlist
\item
  On each segment \([l_k, l_{k+1}]\), we have defined an effective
  liquidity \(L_{AMM,k} > 0\), intended to approximate (and in our
  piecewise-constant case, equal) the continuous \(\lambda(l)\) on that
  segment.
\end{itemize}

Under the usual construction (all band boundaries included in
\(\mathcal{M}\)), \(\lambda(l)\) is constant on each open segment
\((l_k, l_{k+1})\), so we may choose:

\[
L_{AMM,k} = \lambda(\bar{l}_k), \quad \bar{l}_k \in (l_k, l_{k+1})
\]

and this gives \textbf{exact} equality \(\lambda(l) = L_{AMM,k}\) for
all \(l \in (l_k, l_{k+1})\). Thus, per segment we can use the
constant-liquidity formulas with \(L = L_{AMM,k}\).

\paragraph{\texorpdfstring{5.5.1 Per-segment CLMM Deltas in
\(l\)-space}{5.5.1 Per-segment CLMM Deltas in l-space}}\label{per-segment-clmm-deltas-in-l-space}

Fix a segment index \(k \in \{0, \ldots, N-1\}\). On the segment
\([l_k, l_{k+1}]\), define:

\begin{itemize}
\tightlist
\item
  \(L_k := L_{AMM,k}\) (for brevity),
\item
  \(l_{min} = l_k\),
\item
  \(l_{max} = l_{k+1}\).
\end{itemize}

For any two log-sqrt-prices \(l_a, l_b \in [l_{min}, l_{max}]\), we
define the \textbf{segment CLMM deltas}:

\[
\Delta A_k (l_a \to l_b) = L_k (2^{-l_b} - 2^{-l_a}), \quad \Delta B_k (l_a \to l_b) = L_k (2^{l_b} - 2^{l_a})
\]

These are exactly the finite formulas from before, applied with
liquidity \(L = L_k\).

Remarks:

\begin{itemize}
\tightlist
\item
  If \(l_b > l_a\), then:

  \begin{itemize}
  \tightlist
  \item
    \(2^{l_b} > 2^{l_a}\), so \(\Delta B_k > 0\)
  \item
    \(2^{-l_b} < 2^{-l_a}\), so \(\Delta A_k < 0\).
  \end{itemize}
\item
  If \(l_b < l_a\), the signs are reversed.
\end{itemize}

These signs encode the direction of reserves flow for the AMM; the
trader's deltas are \(-\Delta A_k\) and \(-\Delta B_k\).

If we prefer to express these in terms of sqrt-prices, let:

\[
S_a = 2^{l_a}, \quad S_b = 2^{l_b}
\]

Then:

\[
2^{-l_a} = \frac{1}{S_a}, \quad 2^{-l_b} = \frac{1}{S_b}
\]

and we recover:

\[
\Delta A_k (l_a \to l_b) = L_k \left( \frac{1}{S_b} - \frac{1}{S_a} \right), \quad \Delta B_k (l_a \to l_b) = L_k (S_b - S_a)
\]

with the understanding that \(S_a, S_b \in [2^{l_k}, 2^{l_{k+1}}]\).

\paragraph{5.5.2 Per-segment Capacity}\label{per-segment-capacity}

For a given segment \(k\), we can define the \textbf{maximum CLMM
capacity} of that segment in terms of token flows if the price traverses
the \textbf{full segment}.

Assume we move from the lower node \(l_k\) to the upper node
\(l_{k+1}\). Then:

\[
\text{Full-segment deltas:} \Delta A_k^{max, \uparrow} = L_k (2^{-l_{k+1}} - 2^{-l_k}), \quad \Delta B_k^{max, \uparrow} = L_k (2^{l_{k+1}} - 2^{l_k})
\]

Similarly, moving from the upper node down to the lower:

\[
\Delta A_k^{max, \downarrow} = L_k (2^{-l_k} - 2^{-l_{k+1}}) = -\Delta A_k^{max, \uparrow}, \quad \Delta B_k^{max, \downarrow} = L_k (2^{l_k} - 2^{l_{k+1}}) = -\Delta B_k^{max, \uparrow}
\]

In absolute value, the segment provides:

\[
\left| \Delta A_k^{max} \right| = L_k \left| 2^{-l_{k+1}} - 2^{-l_k} \right|, \quad \left| \Delta B_k^{max} \right| = L_k \left| 2^{l_{k+1}} - 2^{l_k} \right|
\]

These quantities are exactly what you need for:

\begin{itemize}
\tightlist
\item
  deciding whether the trade can traverse the entire segment,
\item
  or whether it will \textbf{terminate inside} the segment.
\end{itemize}

\paragraph{\texorpdfstring{5.5.3 Partial Usage of a Segment: Solving for
\(l_{end}\)}{5.5.3 Partial Usage of a Segment: Solving for l\_\{end\}}}\label{partial-usage-of-a-segment-solving-for-l_end}

In practice, while executing a swap, you often know:

\begin{itemize}
\tightlist
\item
  current log-price \(l_{curr}\),
\item
  segment liquidity \(L_k\),
\item
  remaining amount of one token to trade (e.g.~an amount of token \(A\)
  in or an amount of token \(B\) out),
\end{itemize}

and you want to determine:

\begin{itemize}
\tightlist
\item
  the \textbf{new log-price} \(l_{next}\) \textbf{within the same
  segment} that corresponds to consuming exactly that amount, provided
  it lies inside the segment bounds.
\end{itemize}

We now write the \textbf{inverse formulas} for \(l_{next}\) given
\(\Delta A\) or \(\Delta B\).

Let \(l_{curr} \in [l_k, l_{k+1}]\) be the starting point in segment
\(k\), and let \(\Delta A, \Delta B\) denote the desired
\textbf{pool-level} deltas on that segment (sign included).

\subparagraph{\texorpdfstring{5.5.3.1 Solving from
\(\Delta B\)}{5.5.3.1 Solving from \textbackslash Delta B}}\label{solving-from-delta-b}

From the per-segment formula:

\[
\Delta B = \Delta B_k (l_{curr} \to l_{next}) = L_k (2^{l_{next}} - 2^{l_{curr}})
\]

Rearrange to solve for \(2^{l_{next}}\):

\[
2^{l_{next}} = 2^{l_{curr}} + \frac{\Delta B}{L_k}
\]

Assuming the right-hand side is positive (which is necessary since
\(2^l >0\)), we get:

\[
l_{next} = \log_2 \left( 2^{l_{curr}} + \frac{\Delta B}{L_k} \right)
\]

To remain within the segment, we require:

\[
l_{min} \leq l_{next} \leq l_{max} \quad (\text{i.e. } l_k \leq l_{next} \leq l_{k+1})
\]

If the computed \(l_{next}\) lies outside \([l_k, l_{k+1}]\), it means
the requested \(\Delta B\) exceeds the segment's capacity in that
direction; in that case, the actual move will stop at the boundary
\(l_k\) or \(l_{k+1}\), and the segment is fully consumed.

\subparagraph{\texorpdfstring{5.5.3.2 Solving from
\(\Delta A\)}{5.5.3.2 Solving from \textbackslash Delta A}}\label{solving-from-delta-a}

From the per-segment formula:

\[
\Delta A = \Delta A_k (l_{curr} \to l_{next}) = L_k (2^{-l_{next}} - 2^{-l_{curr}})
\]

Rearrange to solve for \(2^{-l_{next}}\):

\[
2^{-l_{next}} = 2^{-l_{curr}} + \frac{\Delta A}{L_k}
\]

We require the right-hand side to be positive (since \(2^{-l} > 0\)):

\[
2^{-l_{curr}} + \frac{\Delta A}{L_k} > 0
\]

Then:

\[
l_{next} = -\log_2 \left( 2^{-l_{curr}} + \frac{\Delta A}{L_k} \right)
\]

Again, to remain within the segment:

\[
l_{k} \leq l_{next} \leq l_{k+1}
\]

If the computed \(l_{next}\) lies outside this interval, the requested
\(\Delta A\) cannot be fully realized in this segment; the execution
moves to the boundary and the segment is fully consumed.

\paragraph{5.5.4 Composition Across
Segments}\label{composition-across-segments}

For a complete trade along the price path:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start at initial node \(l_{ast} = l_{k_{ast}}\) (or possibly an
  interior point in some segment)
\item
  For each step:

  \begin{itemize}
  \tightlist
  \item
    Compute full-segment capacities
    \(\Delta A_k^{max}, \Delta B_k^{max}\) on the next segment in the
    direction of price movement.
  \item
    Compare remaining trade amount with this capacity.
  \item
    Either:

    \begin{itemize}
    \tightlist
    \item
      Consume the entire segment and move to the next node, or
    \item
      Use the inverse formulas above to find \(l_{final}\) inside the
      segment and stop.
    \end{itemize}
  \end{itemize}
\item
  At each node \(l_k\), interleave CLMM segment execution with CLOB
  matching at that node, as described in the previous sections.
\end{enumerate}

Mathematically, the total CLMM deltas along the path are the \textbf{sum
of per-segment contributions}:

If the actual price path visits nodes
\(l_{k_0} = l_*, l_{k_1}, \ldots, l_{k_m} = l_{final}\) in order, then:

\[
\Delta A_{total} = \sum_{r=0}^{m-1} \Delta A_{k_r} (l_{k_r} \to l_{k_{r+1}}), \quad \Delta B_{total} = \sum_{r=0}^{m-1} \Delta B_{k_r} (l_{k_r} \to l_{k_{r+1}})
\]

with the last segment possibly ending at an interior point of
\([l_{k_{m}}, l_{k_m+1}]\). This is exactly the piecewise integral of
the overall differential system:

\[
dA(l) = - \lambda(l) (\ln 2) \cdot 2^{-l} \ dl, \quad dB(l) = \lambda(l) (\ln 2) \cdot 2^{l} \ dl
\]

approximated (and, with our choice of mesh, \textbf{exactly realized})
by segment-wise constant liquidity \(L_{AMM,k}\).

\textbf{Figure 7: Segment-wise CLMM Execution Flowchart}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    SEGMENT{-}WISE EXECUTION ALGORITHM                          │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│                        ┌─────────────────────┐                              │}
\NormalTok{│                        │   START at node lₖ  │                              │}
\NormalTok{│                        │   Remaining: Δq\_rem │                              │}
\NormalTok{│                        └──────────┬──────────┘                              │}
\NormalTok{│                                   │                                         │}
\NormalTok{│                                   ▼                                         │}
\NormalTok{│                    ┌──────────────────────────────┐                         │}
\NormalTok{│                    │  CLOB orders at node lₖ?     │                         │}
\NormalTok{│                    │  (opposing side to trade)    │                         │}
\NormalTok{│                    └──────────────┬───────────────┘                         │}
\NormalTok{│                                   │                                         │}
\NormalTok{│                      ┌────────────┴────────────┐                            │}
\NormalTok{│                      │ YES                     │ NO                         │}
\NormalTok{│                      ▼                         ▼                            │}
\NormalTok{│         ┌────────────────────────┐   ┌─────────────────────┐               │}
\NormalTok{│         │ Match CLOB orders at   │   │                     │               │}
\NormalTok{│         │ price P(lₖ)            │   │                     │               │}
\NormalTok{│         │ Update: Δq\_rem {-}= Δq   │   │                     │               │}
\NormalTok{│         └───────────┬────────────┘   │                     │               │}
\NormalTok{│                     │                │                     │               │}
\NormalTok{│                     └────────────────┴─────────┐           │               │}
\NormalTok{│                                                │           │               │}
\NormalTok{│                                                ▼           │               │}
\NormalTok{│                              ┌───────────────────────────┐ │               │}
\NormalTok{│                              │   Δq\_rem = 0 ?            │ │               │}
\NormalTok{│                              └─────────────┬─────────────┘ │               │}
\NormalTok{│                                            │               │               │}
\NormalTok{│                               ┌────────────┴───────────┐   │               │}
\NormalTok{│                               │ YES                    │ NO│               │}
\NormalTok{│                               ▼                        ▼   │               │}
\NormalTok{│              ┌─────────────────────┐    ┌──────────────────┴──────────┐    │}
\NormalTok{│              │       DONE          │    │  Enter CLMM segment         │    │}
\NormalTok{│              │  Trade complete at  │    │  [lₖ, lₖ₊₁] with L\_AMM,k   │    │}
\NormalTok{│              │  final price P(l)   │    └──────────────┬──────────────┘    │}
\NormalTok{│              └─────────────────────┘                   │                   │}
\NormalTok{│                                                        ▼                   │}
\NormalTok{│                              ┌───────────────────────────────────────┐     │}
\NormalTok{│                              │  Compute segment capacity:            │     │}
\NormalTok{│                              │  ΔBₖᵐᵃˣ = L\_AMM,k · (2\^{}lₖ₊₁ {-} 2\^{}lₖ)   │     │}
\NormalTok{│                              └───────────────────┬───────────────────┘     │}
\NormalTok{│                                                  │                         │}
\NormalTok{│                                                  ▼                         │}
\NormalTok{│                              ┌───────────────────────────────────────┐     │}
\NormalTok{│                              │  |Δq\_rem| ≤ |ΔBₖᵐᵃˣ| ?               │     │}
\NormalTok{│                              └───────────────────┬───────────────────┘     │}
\NormalTok{│                                                  │                         │}
\NormalTok{│                                ┌─────────────────┴──────────────┐          │}
\NormalTok{│                                │ YES                            │ NO       │}
\NormalTok{│                                ▼                                ▼          │}
\NormalTok{│              ┌─────────────────────────────┐  ┌────────────────────────┐   │}
\NormalTok{│              │  Solve for l\_final:         │  │  Consume full segment  │   │}
\NormalTok{│              │  2\^{}l\_final = 2\^{}lₖ +Δq\_rem/L │  │  Δq\_rem {-}= ΔBₖᵐᵃˣ      │   │}
\NormalTok{│              │  Δq\_rem = 0                 │  │  Move to node lₖ₊₁     │   │}
\NormalTok{│              │                             │  │  k = k + 1             │   │}
\NormalTok{│              └─────────────┬───────────────┘  └───────────┬────────────┘   │}
\NormalTok{│                            │                              │                │}
\NormalTok{│                            ▼                              │                │}
\NormalTok{│              ┌─────────────────────────┐                  │                │}
\NormalTok{│              │         DONE            │                  │                │}
\NormalTok{│              │  Final price: P(l\_final)│                  │                │}
\NormalTok{│              └─────────────────────────┘                  │                │}
\NormalTok{│                                                           │                │}
\NormalTok{│                              ┌────────────────────────────┘                │}
\NormalTok{│                              │                                             │}
\NormalTok{│                              └─────────────► (loop back to CLOB check)     │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 7: The segment-wise execution algorithm processes trades by
alternating between CLOB matching at mesh nodes and CLMM traversal
through segments. At each node lₖ, opposing CLOB orders are matched
first at price P(lₖ). If trade remains, the algorithm enters the
adjacent CLMM segment, either consuming it fully (moving to the next
node) or partially (solving for the final interior price). This
continues until the trade is complete.}

\subsubsection{5.6 Relationship Between
Layers}\label{relationship-between-layers}

We summarize the roles and relationships of the three layers formally.

\paragraph{\texorpdfstring{5.6.1 Layer 0 \(\to\) Layer 1 (Projection to
Slots)}{5.6.1 Layer 0 \textbackslash to Layer 1 (Projection to Slots)}}\label{layer-0-to-layer-1-projection-to-slots}

Given:

\begin{itemize}
\tightlist
\item
  A set of CLMM bands \(\{(l_{lower,i}, l_{upper,i}, L_i)\}_{i \in I}\),
\item
  A set of orders \(\{(l_{0,j}, q_j)\}_{j \in J}\),
\item
  Slot parameters \((l_{ref}, \Delta l)\),
\end{itemize}

Layer 1 defines the maps:

\begin{itemize}
\tightlist
\item
  \textbf{LP band slot projection}:
\end{itemize}

\[
\Pi_{LP}: I \to \mathbb{Z} \times \mathbb{Z}, \quad \Pi_{LP}(i) = (s_{lower,i}, s_{upper,i})
\]

\begin{itemize}
\tightlist
\item
  \textbf{Order slot projection}:
\end{itemize}

\[
\Pi_{ORD}: J \to \mathbb{Z}, \quad \Pi_{ORD}(j) = s_j
\]

These maps are \textbf{many-to-one} and lossless with respect to the
economic parameters (we will store the original \(l\)-values for each
object; the slots are auxiliary indices).

Given a current log-price \(l_*\), we can find a ``relevant'' set of LPs
and orders by:

\begin{itemize}
\tightlist
\item
  Computing the current slot \(s_* = s_{\text{round}}(l_*)\),
\item
  Searching in a window \([s_* - R, s_* + R]\) for some small radius
  \(R\), and then filtering by the exact \(l\)-conditions.
\end{itemize}

\paragraph{\texorpdfstring{5.6.2 Layer 0 + Layer 1 \(\to\) Layer 2
(Local Mesh
Construction)}{5.6.2 Layer 0 + Layer 1 \textbackslash to Layer 2 (Local Mesh Construction)}}\label{layer-0-layer-1-to-layer-2-local-mesh-construction}

Given:

\begin{itemize}
\tightlist
\item
  The continuous data \((\lambda, \mu)\) from Layer 0 (Section 5.1),
\item
  The current log-price \(l_*\) and target \(l_{target}\),
\item
  The sets of LP bands and orders intersecting \(I_{path}\), which we
  can efficiently discover via Layer 1 slots (Section 5.2),
\end{itemize}

Layer 2 (Section 5.3) constructs a finite mesh \(\mathcal{M}\) by:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Gathering all LP boundaries and order prices in \(I_{path}\),
\item
  Adding path endpoints,
\item
  Adding optional refinement points based on desired numerical criteria,
\item
  Sorting and deduplicating to obtain \{\(l_0 < l_1 < \ldots < l_N\)\}.
\end{enumerate}

From this mesh and the Layer-0 liquidity/order data, we define:

\begin{itemize}
\tightlist
\item
  Segment-wise AMM liquidity \(L_{AMM,k}\),
\item
  Node-based depth \(Q_{CLOB,k}\).
\end{itemize}

which fully specify the \textbf{local execution environment} for the
trade.

\paragraph{5.6.3 Persistence vs
Transience}\label{persistence-vs-transience}

\begin{itemize}
\item
  \textbf{Layer 0 (Section 5.1)}:

  \begin{itemize}
  \tightlist
  \item
    Logical state: band bounds \((l_{lower,i}, l_{upper,i})\), order
    prices \(l_{0,j}\), and liquidity/quantities \(L_i, q_j\).
  \item
    Conceptually persistent (though on-chain it is encoded in
    fixed-point, Section 4).
  \end{itemize}
\item
  \textbf{Layer 1 (Section 5.2)}:

  \begin{itemize}
  \tightlist
  \item
    Persistent on-chain indexing:

    \begin{itemize}
    \tightlist
    \item
      slot index ranges for LPs,
    \item
      slot index for orders.
    \end{itemize}
  \item
    Used to answer queries like ``which bands and orders are near the
    current price?''
  \end{itemize}
\item
  \textbf{Layer 2 (Section 5.3)}:

  \begin{itemize}
  \tightlist
  \item
    Constructed per trade / per execution.
  \item
    Depends on:

    \begin{itemize}
    \tightlist
    \item
      current price and target,
    \item
      discovered LPs and orders from nearby slots,
    \item
      optional refinement rules.
    \end{itemize}
  \item
    Destroyed after the trade completes; no state is persisted except
    updated balances, positions, orders back in Layer 0 + Layer 1
    structures.
  \end{itemize}
\end{itemize}

\subsubsection{5.7 Conclusion}\label{conclusion}

This three-layer architecture yields:

\begin{itemize}
\tightlist
\item
  A \textbf{continuous, unified economic model} over
  \(l \in \mathbb{R}\) (Layer 0, Section 5.1),
\item
  \textbf{Efficient indexing and storage} via global slots (Layer 1,
  Section 5.2),
\item
  \textbf{Adaptive, high-precision execution} via local meshes (Layer 2,
  Section 5.3).
\end{itemize}

while keeping prices fundamentally log-based (no global-ticks, Section
3) and allowing CLMM, CLOB, and perps to all coexist on the same axis
with consistent semantics.

\subsection{6. Formal Fixed-Point
Specification}\label{formal-fixed-point-specification}

This section specifies the precise relationship between the
\textbf{continuous} economic model in log-sqrt-price coordinates
(Section 5) and the \textbf{discrete on-chain representation} in
fixed-point integer arithmetic (Section 4). At a high level, we show
that there is a single global constant \(C\) (depending only on
liquidity and price bounds, not on implementation details) such that,
for any trade along a fixed price path, the total numerical error in the
token deltas is bounded by

\[
  C \Big( \tfrac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}} \Big),
\]

where \(\tfrac{1}{\sigma}\) is the log-encoding granularity,
\(\varepsilon_{\exp_2}\) and \(\varepsilon_{\log_2}\) control the
accuracy of the \(exp_2\) and \(log_2\) routines, and
\(\varepsilon_{\mathrm{arith}}\) captures cumulative fixed-point
rounding error. In particular, by increasing the number of fractional
bits and tightening the exp/log approximations, the on-chain execution
converges uniformly to the continuous model, independently of Layer-1
slot choices or Layer-2 mesh heuristics (as long as band boundaries and
order prices are included as mesh nodes).

More concretely, we introduce:

\begin{itemize}
\tightlist
\item
  a fixed-point encoding of the log-sqrt-price \(l\),
\item
  fixed-point formats for sqrt-price \(S\) and price \(P\), and
  liquidity \(Q\),
\item
  abstract specifications of the numerical \(exp_2\) and \(log_2\)
  routines,
\item
  and error bounds showing that on-chain execution converges to the
  continuous model.
\end{itemize}

Throughout this section, we assume all arithmetic is carried out in a
fixed-width integer domain (e.g.~256-bit signed/unsigned integers). We
model overflow at the specification level by imposing explicit bounds on
representable values and treating out-of-range states as invalid,
following standard numerical analysis methodology
\autocite{higham2002accuracy}.

\subsubsection{6.1 Fixed-Point Encoding of
Log-Sqrt-Price}\label{fixed-point-encoding-of-log-sqrt-price-1}

\paragraph{6.1.1 Integer domain and
Scaling}\label{integer-domain-and-scaling}

Let:

\begin{itemize}
\tightlist
\item
  \(F \in \mathbb{N}\) be the number of fractional log bits,
\item
  \(\sigma = 2^F > 0\) be the log scaling factor,
\item
  \(w \in \mathbb{N}\) be the bit-width of the signed integer type used
  for log-coordinates (e.g.~(w = 256)).
\end{itemize}

Define the integer domain:

\[
\mathbb{Z}_w = \{ z \in \mathbb{Z} :  -2^{w-1} \leq z \leq 2^{w-1} - 1 \}
\]

The log-sqrt-price coordinate \(l \in \mathbb{R}\) is encoded as:

\[
L \in \mathbb{Z}_w, \quad l \approx \frac{L}{\sigma}
\]

We interpret:

\begin{itemize}
\tightlist
\item
  \(L\) as the \textbf{on-chain representation}
\item
  \(l\) as the \textbf{ideal continuous log-sqrt-price}.
\end{itemize}

\paragraph{6.1.2 Rounding and Encoding
Map}\label{rounding-and-encoding-map}

We adopt \textbf{round-to-nearest with ties to even} as the canonical
rounding rule. Formally, define:

\[
\mathrm{rnd} : \mathbb{R} \to \mathbb{Z}, \quad \mathrm{rnd}(x) = \begin{cases}
\lfloor x \rfloor & \text{if } x - \lfloor x \rfloor < \frac{1}{2} \\
\lceil x \rceil & \text{if } x - \lfloor x \rfloor > \frac{1}{2} \\
\text {nearest even integer} & \text{if } x - \lfloor x \rfloor = \frac{1}{2}
\end{cases}
\]

This satisfies the usual property:

\[
|\mathrm{rnd}(x) - x| \leq \frac{1}{2}, \quad \forall x \in \mathbb{R}
\]

We define the \textbf{log-sqrt-price encoding} and \textbf{decoding}
maps as:

\begin{itemize}
\tightlist
\item
  \textbf{Encode (continuous \(\to\) integer)}:
\end{itemize}

\[
\mathrm{enc}_l : \mathbb{R} \to \mathbb{Z}_w, \quad \mathrm{enc}_l(l) = \begin{cases}
\mathrm{clip_{[L_{min}, L_{max}]}} \big (\mathrm{rnd}(l \cdot \sigma) \big), & \text{if not overflow} \\
\text{undefined (revert)}, & \text{otherwise}
\end{cases}
\]

where \(\mathrm{clip_{[a,b]}}(x) = \min(\max(x,a),b)\) and
\(L_{min}, L_{max} \in \mathbb{Z}_w\) are protocol-chosen bounds
corresponding to the minimum and maximum supported prices.

\begin{itemize}
\tightlist
\item
  \textbf{Decode (integer \(\to\) approximate log value)}:
\end{itemize}

\[
\mathrm{dec}_l : \mathbb{Z}_w \to \mathbb{R}, \quad \mathrm{dec}_l(L) = \frac{L}{\sigma}
\]

In the economic model, we treat any state that would require clipping as
\textbf{invalid} (i.e.~trades that attempt to move the price outside the
representable range are rejected). Thus, when we write
\(L = \mathrm{enc}_l(l)\), we \emph{implicitly assume}
\(L_{min} \le \mathrm{rnd}(l \cdot \sigma) \le L_{max}\).

\paragraph{6.1.3 Encoding error and induced price
error}\label{encoding-error-and-induced-price-error}

Let \(l^* \in \mathbb{R}\) be a ``true'' log-sqrt-price, and suppose the
encoding does not overflow:

\[
L^* = \mathrm{enc}_l(l^*), \quad \hat{l} = \mathrm{dec}_l(L) = \frac{L}{\sigma}
\]

Set the encoding error:

\[
\delta l := \hat{l} - l^*
\]

Then by the rounding property:

\[
|\delta l| = \left| \frac{\mathrm{rnd}(l^* \cdot \sigma)}{\sigma} - l^* \right| = \frac{|\mathrm{rnd}(l^* \cdot \sigma) - l^* \cdot \sigma|}{\sigma} \leq \frac{1}{2\sigma}
\]

The corresponding true and decoded prices are:

\[
S^* = 2^{l^*}, \quad \hat{S} = 2^{\hat{l}} = 2^{l^* + \delta l} = S^* \cdot 2^{\delta l}
\]

\[
P^* = (S^*)^2 = 2^{2l^*}, \quad \hat{P} = 2^{2\hat{l}} = 2^{2l^* + 2\delta l} = P^* \cdot 2^{2\delta l}
\]

Thus the \textbf{relative errors} satisfy:

\[
\frac{\hat{S}}{S^*} = 2^{\delta l} \in \Big[ 2^{-\frac{1}{2\sigma}}, 2^{\frac{1}{2\sigma}} \Big]
\]

\[
\frac{\hat{P}}{P^*} = 2^{2\delta l} \in \Big[ 2^{-\frac{1}{\sigma}}, 2^{\frac{1}{\sigma}} \Big]
\]

For large \(\sigma\) (many fractional bits), we can use the bound
\(|x| \leq \frac{1}{\sigma}\) and the inequality
\(|2^x - 1| \leq (\ln 2) |x| 2^{|x|}\) to obtain:

\textbf{Lemma 6.1 (Encoding-induced Price Error).}

Assume \(\sigma \geq 1\) and no overflow. Then:

\[
\left| \frac{\hat{P}}{P^*} - 1 \right| = \left| 2^{2\delta l} - 1 \right| \leq C \cdot \frac{\ln 2}{\sigma}
\]

for some absolute constant \(C \in [1, 2]\). In particular, for
\(\sigma \geq 32\), we have:

\[
\left| \frac{\hat{P}}{P^*} - 1 \right| \lesssim \frac{\ln 2}{\sigma}
\]

\textbf{\emph{Proof.}}

Using \(|\delta l| \leq \frac{1}{2\sigma}\), we have
\(|2\delta l| \leq \frac{1}{\sigma}\). By the mean value theorem applied
to \(f(x) = 2^x\) on {[}\(\frac{-1}{\sigma}, \frac{1}{\sigma}\){]},

\[
|2^{2\delta l} - 1| \leq \max_{x \in [-\frac{1}{\sigma}, \frac{1}{\sigma}]} |f'(x)| \cdot |2\delta l| = \max_{x \in [-\frac{1}{\sigma}, \frac{1}{\sigma}]} (\ln 2) 2^x \cdot |2\delta l| \leq (\ln 2) 2^{\frac{1}{\sigma}} \cdot \frac{1}{\sigma}
\]

Taking \(C = 2^{\frac{1}{\sigma}} \in [1,2]\) for all \(\sigma \geq 1\)
yields the bound. \(\blacksquare\)

This shows that increasing \(\sigma\) (the number of fractional bits in
\(L\)) reduces the \textbf{pure encoding error} of prices at rate
\(O\left(\frac{1}{\sigma}\right)\).

\subsubsection{6.2 Fixed-Point Formats for Sqrt-Price, Price, and
Liquidity}\label{fixed-point-formats-for-sqrt-price-price-and-liquidity}

We now fix the explicit integer formats for the main quantities used in
CLMM execution.

\paragraph{6.2.1 Q-Formats}\label{q-formats}

A Q-format \(Q_{I.F}\) \autocite{yates2013fixed} is a fixed-point
representation of real numbers of the form:

\[
x = \frac{X}{2^F}, \quad X \in \mathbb{Z}
\]

where:

\begin{itemize}
\tightlist
\item
  \(F \ge 0\) is the number of \textbf{fractional bits},
\item
  \(I\) is the number of \textbf{integer bits} so that
  \(|X| \leq 2^{I+F} - 1\) in a signed representation.
\end{itemize}

We denote the raw integer by \(X\) and write:

\[
x \equiv \frac{X}{2^F} \quad \text{Q}_{I.F}
\]

We assume the implementation uses sufficiently large \(I\)
(e.g.~\(I+F \leq 256\)) so that overflow is impossible within the
supported economic range. As in Section 6.1.2, we treat any operation
that would overflow as invalid in the economic model.

\paragraph{6.2.2 Fixed-point Domains}\label{fixed-point-domains}

We choose the following canonical formats:

\begin{itemize}
\tightlist
\item
  Log-sqrt-price:
\end{itemize}

\[
L \in \mathbb{Z}_w, \quad l \approx \frac{L}{\sigma}, \quad \sigma = 2^F
\]

\begin{itemize}
\tightlist
\item
  Sqrt-price:
\end{itemize}

\[
S_{\mathrm{fp}} \in \mathbb{Z}, \quad S \approx \frac{S_{\mathrm{fp}}}{2^{Q_S}}, \quad \text{Q}_{I_S.Q_S}
\]

\begin{itemize}
\tightlist
\item
  Price:
\end{itemize}

\[
P_{\mathrm{fp}} \in \mathbb{Z}, \quad P \approx \frac{P_{\mathrm{fp}}}{2^{Q_P}}, \quad \text{Q}_{I_P.Q_P}
\]

Typically, \(P\) will be derived as \(P \approx S^2\), so we require

\[
Q_P \geq 2 Q_S, \quad I_P \ge 2 I_S + 1
\]

to accommodate squaring and scaling with bounded rounding error.

\begin{itemize}
\tightlist
\item
  Liquidity:
\end{itemize}

\[
Q_{\mathrm{fp}} \in \mathbb{Z}, \quad Q \approx \frac{Q_{\mathrm{fp}}}{2^{Q_Q}}, \quad \text{Q}_{I_Q.Q_Q}
\]

All CLMM formulas are implemented by integer operations on these
fixed-point domains, followed by appropriate shifts and rounding.

\subsubsection{\texorpdfstring{6.3 Fixed-Point Exponential:
\(\operatorname{exp_2fp}\)}{6.3 Fixed-Point Exponential: \textbackslash operatorname\{exp\_2fp\}}}\label{fixed-point-exponential-operatornameexp_2fp}

We now formalize the on-chain computation of the square-root price from
the log-sqrt integer \(L\).

\paragraph{6.3.1 Abstract Specification}\label{abstract-specification}

Define:

\[
\operatorname{exp_2fp} : \mathbb{Z}_w \to \mathbb{Z}
\]

to be a function that, for each admissible \(L\), returns a fixed-point
approximation \(S_{\mathrm{fp}} = \operatorname{exp_2fp}(L)\) with the
interpretation:

\[
\hat{S}(L) := \frac{S_{\mathrm{fp}}}{2^{Q_S}}
\]

as an approximation to the true value:

\[
S(L) = 2^{\frac{L}{\sigma}}
\]

We require two properties:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Monotonicity:} For all \(L_1 < L_2\) in the domain,

  \[
  \operatorname{exp_2fp}(L_1) < \operatorname{exp_2fp}(L_2)
  \]
\item
  \textbf{Relative Error Bound:} There exists a protocol-chosen constant
  \(\varepsilon_{\exp_2} > 0\) such that for all \(L\) in the domain,
\end{enumerate}

\[
\left| \frac{\hat{S}(L)}{S(L)} - 1 \right| \leq \varepsilon_{\exp_2}
\]

Equivalently, in absolute terms:

\[
|\hat{S}(L) - S(L)| \leq \varepsilon_{\exp_2} \cdot S(L) \quad \forall L
\]

The specific implementation (polynomial, table-based, etc.) is not fixed
in the economic model; only these properties are required.

\paragraph{6.3.2 Example construction (range
reduction)}\label{example-construction-range-reduction}

One canonical construction (not normative but illustrative) follows the
standard range reduction approach for exponential functions
\autocite{muller2016elementary,tang1989exponential}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Decompose:

  \[
  \frac{L}{\sigma} = q + f, \quad q \in \mathbb{Z}, \quad f \in [0,1)
  \]

  by setting:

  \[
  q = \left\lfloor \frac{L}{\sigma} \right\rfloor, \quad r = L - q\sigma \in {0, 1, \ldots, \sigma - 1}, \quad f = \frac{r}{\sigma}
  \]
\item
  Note:

  \[
  S(L) = 2^{\frac{L}{\sigma}} = 2^{q + f} = 2^q \cdot 2^f
  \]
\item
  Implement:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \(2^q\) by exponent shifting in fixed-point: if \(S_0 = 2^{Q_S}\)
  represents 1.0, then \(2^q\) is represented by
  \(S_{q,\mathrm{fp}} = S_0 \ll q\) (left shift) for \(q \geq 0\) , or
  \(\gg |q|\) if \(q < 0\), subject to range checks.
\item
  \(2^f\) by a polynomial or table approximation on the interval
  \(f \in [0,1)\).
\end{itemize}

That is, define an approximation \(\widetilde{E}(f)\) to \(2^f\) such
that:

\[
\left| \frac{\widetilde{E}(f)}{2^f} - 1 \right| \leq \varepsilon_{\mathrm{frac}}
\]

and then set:

\[
S_{\mathrm{fp}} = \left \lfloor S_{q,\mathrm{fp}} \cdot \frac{\widetilde{E}(f)}{2^{Q_S}} \right \rceil
\]

where \(\lfloor \cdot \rceil\) denotes rounding to nearest integer.

Provided the rounding error is controlled, the composite error
\(\varepsilon_{\exp_2}\) can be bounded in terms of
\(\varepsilon_{\mathrm{frac}}\) and the fixed-point rounding error. We
do not fix \(\widetilde{E}\) at the specification level, but require
that the resulting \(\operatorname{exp_2fp}\) satisfies the monotonicity
and relative error properties above.

\paragraph{6.3.3 Error propagation to
Price}\label{error-propagation-to-price}

Given \(\hat{S}(L)\) with relative error \(\varepsilon_{\exp_2}\), the
approximate price is:

\[
\hat{P}(L) = \hat{S}(L)^2, \quad P(L) = S(L)^2 = 2^{\frac{2L}{\sigma}}
\]

Then:

\[
\frac{\hat{P}(L)}{P(L)} = \left( \frac{\hat{S}(L)}{S(L)} \right)^2
\]

Let:

\[
\delta_S (L) := \frac{\hat{S}(L)}{S(L)} - 1
\]

so that:

\[
\left| \frac{\hat{P}(L)}{P(L)} - 1 \right| = \left| \left( \frac{\hat{S}(L)}{S(L)} \right)^2 - 1 \right| = \left| \left( 1 + \delta_S \right)^2 - 1 \right| = |2\delta_S (L) + \delta_S (L)^2|
\]

where \(|\delta_S (L)| \leq \varepsilon_{\exp_2}\). Thus:

\textbf{Lemma 6.2 (\(exp_2\)-induced price error).}

If \(\operatorname{exp_2fp}\) satisfies the relative error bound
\(|\delta_S (L)| \leq \varepsilon_{\exp_2}\), then for all admissible
\(L\),

\[
\left| \frac{\hat{P}(L)}{P(L)} - 1 \right| \leq 2 \varepsilon_{\exp_2} + \varepsilon_{\exp_2}^2
\]

In particular, for \(\varepsilon_{\exp_2} \leq 10^{-4}\), the price
error satisfies:

\[
\left| \frac{\hat{P}(L)}{P(L)} - 1 \right| \leq 2.0001 \varepsilon_{\exp_2}
\]

\textbf{\emph{Proof.}} Immediate from the previous derivation.
\(\blacksquare\)

\subsubsection{\texorpdfstring{6.4 Fixed-Point Logarithm:
\(\operatorname{log_2fp}\)}{6.4 Fixed-Point Logarithm: \textbackslash operatorname\{log\_2fp\}}}\label{fixed-point-logarithm-operatornamelog_2fp}

We also require a numerical \(log_2\) routine to reconstruct
log-sqrt-price from a fixed-point representation of \(S\) (e.g.~for
oracle integration, position management, or diagnostics).

\paragraph{6.4.1 Abstract Specification}\label{abstract-specification-1}

Let \(S_{\mathrm{fp}} \in \mathbb{Z}\) be a fixed-point sqrt-price with
interpretation:

\[
S = \frac{S_{\mathrm{fp}}}{2^{Q_S}} > 0
\]

We define:

\[
\operatorname{log_2fp} : \mathbb{Z}_{>0} \to \mathbb{Z}_w
\]

such that the decoded log-sqrt-price:

\[
\hat{L} := \frac{\operatorname{log_2fp}(S_{\mathrm{fp}})}{\sigma}
\]

approximates \(\log_2 S\).

We require:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Domain and monotonicity:} For all
  \(S_{\mathrm{fp},1} < S_{\mathrm{fp},2}\),

  \[
  \operatorname{log_2fp}(S_{\mathrm{fp},1}) < \operatorname{log_2fp}(S_{\mathrm{fp},2})
  \]

  and the function is defined only for \(S_{\mathrm{fp}} > 0\).
\item
  \textbf{Absolute log error bound:} There exists
  \(\varepsilon_{\log_2} > 0\) such that for all admissible
  \(S_{\mathrm{fp}} > 0\),
\end{enumerate}

\[
\left| \hat{L} - \log_2 S \right| \leq \varepsilon_{\log_2}
\]

Equivalently:

\[
\left| \frac{\operatorname{log_2fp}(S_{\mathrm{fp}})}{\sigma} - \log_2 \left( \frac{S_{\mathrm{fp}}}{2^{Q_S}} \right) \right| \leq \varepsilon_{\log_2}
\]

Again, we leave the implementation (e.g.~range reduction + polynomial or
table) unspecified, requiring only these properties.

\paragraph{6.4.2 Example construction
(normalization)}\label{example-construction-normalization}

A canonical normalized implementation follows the standard approach for
logarithm computation \autocite{muller2016elementary,tang1990logarithm}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the integer exponent \(e\) such that:

  \[
  S_{\mathrm{fp}} = m \cdot 2^e, \quad m \in [2^{Q_S}, 2^{Q_S + 1})
  \]

  i.e.~normalize \(S\) into \([1, 2)\).
\item
  Write:

  \[
  S = \frac{S_{\mathrm{fp}}}{2^{Q_S}} = 2^{e-Q_S} \cdot \frac{m}{2^{Q_S}} = 2^{e - Q_S} \cdot (1 + \delta)
  \]

  where \(\delta \in [0, 1)\).
\item
  Then:

  \[
  \log_2 S = (e - Q_S) + \log_2 (1 + \delta)
  \]
\item
  Approximate \(\log_2 (1 + \delta)\) on \(\delta \in [0,1)\) by a
  polynomial or LUT \(\widetilde{L}(\delta)\) with bounded error, and
  define:
\end{enumerate}

\[
\hat{l} = (e - Q_S) + \widetilde{L}(\delta)
\]

Implementation details determine \(\varepsilon_{\log_2}\); at the
economic model level we only require that \(\varepsilon_{\log_2}\) be
sufficiently small and known.

\subsubsection{6.5 Monotonicity and
Safety}\label{monotonicity-and-safety}

The monotonicity of \(\operatorname{exp_2fp}\) and
\(\operatorname{log_2fp}\) is crucial to avoid non-physical artifacts
such as ``backwards'' price moves or non-monotone reconstruction of
log-prices.

\textbf{Proposition 6.3 (Monotone price map).}

Suppose \(\operatorname{exp_2fp}\) is strictly increasing in \(L\). Then
the decoded sqrt-price \(\hat{S}(L)\) and price \(\hat{P}(L)\) are
strictly increasing functions of \(L\).

\textbf{\emph{Proof.}}

If \(L_1 < L_2\), then
\(\operatorname{exp_2fp}(L_1) < \operatorname{exp_2fp}(L_2)\). Since the
decoding \(S = \frac{S_{\mathrm{fp}}}{2^{Q_S}}\) is strictly increasing
in \(S_{\mathrm{fp}}\), it follows that \(\hat{S}(L_1) < \hat{S}(L_2)\).
Squaring preserves strict monotonicity for positive arguments, so
\(\hat{P}(L_1) < \hat{P}(L_2)\). \(\square\)

\textbf{Proposition 6.4 (Monotone log reconstruction).}

Suppose \(\operatorname{log_2fp}\) is strictly increasing in
\(S_{\mathrm{fp}}\). Then the reconstructed log-sqrt-price
\(\hat{L}(S_{\mathrm{fp}})\) is strictly increasing in
\(S_{\mathrm{fp}}\).

\textbf{\emph{Proof.}}

If \(S_{\mathrm{fp},1} < S_{\mathrm{fp},2}\), then
\(\operatorname{log_2fp}(S_{\mathrm{fp},1}) < \operatorname{log_2fp}(S_{\mathrm{fp},2})\).
Dividing by the positive constant \(\sigma\) preserves strict
inequality, so
\(\hat{L}(S_{\mathrm{fp},1}) < \hat{L}(S_{\mathrm{fp},2})\). \(\square\)

These properties guarantee that:

\begin{itemize}
\tightlist
\item
  as the on-chain \(L\) increases (due to trades pushing the price up),
  the decoded price \(\hat{P}\) also increases,
\item
  reconstruction \(L\) from \(S_{\mathrm{fp}}\) cannot produce reversed
  ordering.
\end{itemize}

Thus the numerical layer preserves the qualitative ordering structure of
the continuous model.

\subsubsection{6.6 Aggregate Error Bounds and
Convergence}\label{aggregate-error-bounds-and-convergence}

We now sketch how the various numerical errors (encoding, \(exp_2\),
\(log_2\), fixed-point arithmetic, and mesh discretization) combine, and
show that they can be made arbitrarily small by tuning parameters. The
bounds in this subsection are \textbf{global} in the sense that they
hold uniformly over all trades along a fixed price path, and they are
\textbf{architecture-stable} in the sense that they do not depend on the
particular choice of Layer-1 slot spacing or Layer-2 mesh refinement
strategy, provided all band boundaries and order prices are present as
mesh nodes.

\paragraph{6.6.1 Error Sources}\label{error-sources}

We distinguish the following sources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Encoding error} from continuous \(l^*\) to integer \(L\)
  (Section 6.1.3).
\item
  \textbf{Exponential approximation error} from
  \(\operatorname{exp_2fp}\) (Section 6.3.3).
\item
  \textbf{Logarithm approximation error} from \(\operatorname{log_2fp}\)
  (Section 6.4.1).
\item
  \textbf{Fixed-point arithmetic error} in addition, multiplication,
  division, and rounding in Q-formats.
\item
  \textbf{Mesh approximation error} in Layer 2 (discretizing
  \(\lambda(l)\)).
\end{enumerate}

The first three are per-point errors; the fourth accumulates across
operations; the fifth is geometric (discretization in \(l\)-space).

\textbf{Figure 8: Error Propagation Chain in Fixed-Point Execution}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    ERROR PROPAGATION THROUGH THE SYSTEM                      │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  CONTINUOUS MODEL (exact, infinite precision)                               │}
\NormalTok{│  ════════════════════════════════════════════                               │}
\NormalTok{│                                                                             │}
\NormalTok{│      l* ────────► S* = 2\^{}l* ────────► ΔB* = L·(S*\_b {-} S*\_a)                │}
\NormalTok{│      │            │                   │                                     │}
\NormalTok{│      │ true       │ true              │ true result                         │}
\NormalTok{│      │ log{-}price  │ sqrt{-}price        │                                     │}
\NormalTok{│      │            │                   │                                     │}
\NormalTok{│      ▼            ▼                   ▼                                     │}
\NormalTok{│  ════════════════════════════════════════════════════════════════           │}
\NormalTok{│  FIXED{-}POINT IMPLEMENTATION (approximate, finite precision)                 │}
\NormalTok{│  ════════════════════════════════════════════════════════════════           │}
\NormalTok{│      │            │                   │                                     │}
\NormalTok{│      ▼            ▼                   ▼                                     │}
\NormalTok{│  ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐            │}
\NormalTok{│  │ENCODING│──►│  EXP2  │──►│  MULT  │──►│  SUB   │──►│ RESULT │            │}
\NormalTok{│  │  l→L   │   │  L→S   │   │  L·S   │   │ ΔB\_k   │   │   ΔB   │            │}
\NormalTok{│  └───┬────┘   └───┬────┘   └───┬────┘   └───┬────┘   └───┬────┘            │}
\NormalTok{│      │            │            │            │            │                  │}
\NormalTok{│      ▼            ▼            ▼            ▼            ▼                  │}
\NormalTok{│   ε\_enc       ε\_exp2       ε\_mult       ε\_sub        ε\_total               │}
\NormalTok{│   ≤1/(2σ)    ≤ε\_exp2·S    ≤δ\_op        ≤δ\_op                               │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  ERROR BOUND COMPOSITION:                                                   │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │   ε\_total  ≤  C · ( 1/(2σ) + ε\_exp2 + ε\_log2 + ε\_arith )           │   │}
\NormalTok{│  │                  \textbackslash{}\_\_\_\_\_\_\_/   \textbackslash{}\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_/                 │   │}
\NormalTok{│  │                  encoding     function approximation                │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │   where C depends on liquidity L and price range, but NOT on σ     │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                                                                             │}
\NormalTok{│  CONVERGENCE: As precision increases (σ → ∞, ε\_exp2 → 0, ε\_log2 → 0):     │}
\NormalTok{│                                                                             │}
\NormalTok{│               ε\_total → 0                                                   │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │  Precision │ σ = 2\^{}F  │  Encoding Error  │  Approx Total Error     │   │}
\NormalTok{│  │────────────┼──────────┼──────────────────┼─────────────────────────│   │}
\NormalTok{│  │  F = 32    │  \textasciitilde{}4×10⁹  │  \textasciitilde{}10⁻¹⁰          │  \textasciitilde{}10⁻⁸ (float{-}like)    │   │}
\NormalTok{│  │  F = 48    │  \textasciitilde{}3×10¹⁴ │  \textasciitilde{}10⁻¹⁵          │  \textasciitilde{}10⁻¹³                 │   │}
\NormalTok{│  │  F = 64    │  \textasciitilde{}2×10¹⁹ │  \textasciitilde{}10⁻²⁰          │  \textasciitilde{}10⁻¹⁸ (double{-}like)  │   │}
\NormalTok{│  │  F = 96    │  \textasciitilde{}8×10²⁸ │  \textasciitilde{}10⁻²⁹          │  \textasciitilde{}10⁻²⁷ (quad{-}like)    │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 8: Error propagates through the fixed-point computation
pipeline: encoding (continuous l to integer L), exponential
approximation (L to S), and arithmetic operations (multiplication,
subtraction). Each stage contributes a bounded error. The total error is
the sum of these contributions, weighted by a constant C that depends on
the economic quantities but not on precision parameters. As precision
increases (larger σ, better exp2/log2 approximations), total error
vanishes, ensuring convergence to the continuous model.}

For the arithmetic layer, it is convenient to bundle all per-operation
rounding errors into a single worst-case aggregate quantity.

\textbf{Lemma 6.5 (Fixed-point arithmetic stability).}

Consider any fixed trade along a price path interval
\([l_{\mathrm{start}}, l_{\mathrm{end}}]\) and a corresponding execution
on a mesh with segments \(k = k_0, \ldots, k_m\). Suppose each primitive
fixed-point operation (addition, subtraction, multiplication, division,
or rounding) incurs an absolute rounding error of at most
\(\delta_{\mathrm{op}}\) in the relevant Q-format, and that the total
number of such operations in the CLMM evaluation is bounded by
\(N_{\mathrm{ops}}\) (depending only on protocol configuration, not on
numerical precisions). Then the cumulative arithmetic error in any token
delta can be bounded as

\[
  |E_{\mathrm{arith}}| \le N_{\mathrm{ops}} \cdot \delta_{\mathrm{op}} =: \varepsilon_{\mathrm{arith}},
\]

where \(\varepsilon_{\mathrm{arith}}\) can be made arbitrarily small by
increasing the fractional bit-lengths \(Q_S, Q_P, Q_Q\).

\emph{Proof Sketch.} Each primitive operation perturbs its exact real
counterpart by at most \(\delta_{\mathrm{op}}\), and the full
computation is a finite composition of such operations. Bounding the
number of operations by \(N_{\mathrm{ops}}\) and summing their
contributions yields the stated worst-case bound. \(\blacksquare\)

\paragraph{\texorpdfstring{6.6.2 Segment-wise CLMM error:
\(\Delta B\)}{6.6.2 Segment-wise CLMM error: \textbackslash Delta B}}\label{segment-wise-clmm-error-delta-b}

Consider a signle mesh segment \(k\) with true log-endpoints
\(l_a, l_b\) and constant liquidity \(L_k\). The continuous model
yields:

\[
\Delta B_k = L_k (2^{l_b} - 2^{l_a})
\]

The implementation instead computes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Encoded log values:

  \[
  L_a = \mathrm{enc}_l(l_a), \quad L_b = \mathrm{enc}_l(l_b)
  \]

  with decoded logs
  \(\hat{l}_a = \frac{L_a}{\sigma}, \hat{l}_b = \frac{L_b}{\sigma}\),
  satisfying
  \(|\hat{l}_a - l_a|, |\hat{l}_b - l_b| \leq \frac{1}{2\sigma}\).
\item
  Sqrt-prices via \(\operatorname{exp_2fp}\):

  \[
  \hat{S}_a = \frac{\operatorname{exp_2fp}(L_a)}{2^{Q_S}}, \quad \hat{S}_b = \frac{\operatorname{exp_2fp}(L_b)}{2^{Q_S}}
  \]

  with relative error
  (\(|\hat{S}_x/S(\hat{l}_x) - 1| \leq \varepsilon_{\exp_2}\)) for
  \(x \in \{a,b\}\), where \(S(\hat{l}_x) = 2^{\hat{l}_x}\).
\item
  Segment delta:
\end{enumerate}

\[
\hat{\Delta B}_k = L_k \cdot (\hat{S}_b - \hat{S}_a)
\]

computed in fixed-point with a final rounding step.

Write the \textbf{total error} as:

\[
E_B := \hat{\Delta B}_k - \Delta B_k
\]

We decompose:

\[
\Delta B_k
= L_k \big( 2^{l_b} - 2^{l_a} \big)
= L_k \big( S(\hat{l}_b) 2^{l_b - \hat{l}_b} - S(\hat{l}_a)2^{l_a - \hat{l}_a} \big).
\]

We can separate:

\begin{itemize}
\tightlist
\item
  log-encoding error: \(l_x - \hat{l}_x\), bounded by
  \(\frac{1}{2\sigma}\),
\item
  exp2 approximation error: \(\hat{S}_x - S(\hat{l}_x)\), bounded
  relatively by \(\varepsilon_{\exp_2}\),
\item
  fixed-point arithmetic error in forming \(\hat{\Delta B}_k\)
\end{itemize}

A simple but useful bound is:

\textbf{Proposition 6.6 (Segment \(\Delta B\) error bound).}

Assume:

\begin{itemize}
\tightlist
\item
  encoding error \textbar{}\(\hat{l}_x - l_x\)\textbar{}
  \(\leq \frac{1}{2\sigma}\)
\item
  exp approximation error
  \textbar{}\(\hat{S}_x - S(\hat{l}_x)| \leq \varepsilon_{\exp_2} S(\hat{l}_x)\)
\item
  the multiplication and subtraction to compute \(\hat{\Delta B}_k\)
  incur a total rounding error of at most
  \(\varepsilon_{\mathrm{arith}} L_k \max(\hat{S}_a, \hat{S}_b)\).
\end{itemize}

Then:

\[
|E_B| \le C_1 L_k \max(S(l_a), S(l_b)) \left( \frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\mathrm{arith}} \right)
\]

for some constant \(C_1\) depending only on \(\ln 2\) and the maximum
log error \(\frac{1}{2\sigma}\).

\textbf{\emph{Proof Sketch.}}

Use triangle inequality:

\[
|\hat{S}_b - \hat{S}_a - (2^{l_b} - 2^{l_a})|
\le |\hat{S}_b - S(\hat{l}_b)| + |\hat{S}_a - S(\hat{l}_a)| +
|S(\hat{l}_b) - 2^{l_b}| + |S(\hat{l}_a) - 2^{l_a}| +
\text{(arith rounding)}.
\]

The first two terms are bounded by
\(\varepsilon_{\exp_2} S(\hat{l}_x)\); the next two arise from encoding
error and can be bounded via the Lipschitz constant of \(2^l\) on the
relevant interval; the last term is by assumption. Multiplying by
\(L_k\) yields the stated bound. \(\blacksquare\)

An analogous bound holds for \(\Delta A_k\).

\paragraph{6.6.3 Aggregation across
segments}\label{aggregation-across-segments}

For a full trade, we traverse segments \(k = k_0, k_1, \ldots, k_m\) and
sum segment deltas:

\[
\Delta B_{\mathrm{true}} = \sum_{r=0}^{m} \Delta B_{k_r}, \quad
\hat{\Delta B}_{\mathrm{num}} = \sum_{r=0}^{m} \hat{\Delta B}_{k_r}
\]

The total error is:

\[
E_{B,\mathrm{tot}} := \hat{\Delta B}_{\mathrm{num}} - \Delta B_{\mathrm{true}}
= \sum_{r=0}^{m} E_{B,k_r}
\]

By Proposition 6.6:

\[
|E_{B,\mathrm{tot}}|
\le \left(\max_{r} C_1 L_{k_r} \max_x S(l_x)\right) \cdot m \cdot \left( \frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\mathrm{arith}} \right)
\]

Similarly for \(\Delta A\).

Thus, for any \emph{fixed} maximum number of segments per trade (which
is bounded in practice by a protocol-configured mesh resolution), we
obtain a linear bound:

\[
|E_{B,\mathrm{tot}}| \leq C_{tot} \left( \frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\mathrm{arith}} \right)
\]

with \(C_{tot}\) depending on liquidity magnitudes, price range, and the
maximum segment count.

\paragraph{6.6.4 Mesh approximation
error}\label{mesh-approximation-error}

Recall from the main text that, in the continuous Layer-0 model,
aggregate liquidity is given by:

\[
\lambda(l) = \sum_{i \in I} L_i \cdot 1_{[l_{lower,i}, l_{upper,i})}(l)
\]

and the CLMM differentials are:

\[
dA(l) = - \lambda(l) (\ln 2) \cdot 2^{-l} \ dl
, \quad
dB(l) = \lambda(l) (\ln 2) \cdot 2^{l} \ dl
\]

In Layer 2, we construct a mesh
\(\mathcal{M} = \{ l_0 < l_1 < \ldots < l_N \}\) and define a
segment-wise constant approximation:

\[
\lambda^{(\mathcal{M})}(l) = \sum_{k=0}^{N-1} L_{\mathrm{AMM},k} \cdot 1_{[l_k,l_{k+1})}(l)
\]

with choices such as:

\begin{itemize}
\tightlist
\item
  midpoint sampling: \(L_{\mathrm{AMM},k} = \lambda(\bar{l}_k)\),
\item
  or exact average over the segment.
\end{itemize}

Because \(\lambda\) is piecewise constant with jumps only at band
boundaries, and we include all band boundaries in \(\mathcal{M}\), we
have:

\[
\lambda^{(\mathcal{M})}(l) = \lambda(l) \quad \text{for all } l \notin {l_0, \ldots, l_N}.
\]

The set of discrepancies is finite and hence of measure zero, so the
integrals

\[
\int_{l_a}^{l_b} \lambda^{(\mathcal{M})}(l)2^{\pm l} dl
\]

coincide with those of \(\lambda(l)\) for all intervals whose endpoints
are nodes in \(\mathcal{M}\). Thus:

\textbf{Proposition 6.7 (Exact mesh integrals for band-based
\(\lambda\)).}

If all CLMM band boundaries are included in \(\mathcal{M}\) and
\(L_{\mathrm{AMM},k}\) is chosen as any representative value of
\(\lambda(l)\) on \([l_k, l_{k+1})\), then for any mesh nodes
(\(l_a, l_b\)):

\[
\int_{l_a}^{l_b} \lambda^{(\mathcal{M})}(l) 2^{\pm l} dl
= \int_{l_a}^{l_b} \lambda(l) 2^{\pm l} dl.
\]

Hence the only errors in (\(\Delta A, \Delta B\)) arise from numerical
approximation, not from mesh discretization of \(\lambda\).

When additional refinement points are inserted inside segments (e.g.~to
control per-segment error or for numerical stability), the mesh is
merely partitioned further; (\(\lambda^{(\mathcal{M})}\)) remains equal
to (\(\lambda(l)\)) almost everywhere, and the exact integrals are
preserved.

In particular, the bounds in this subsection, and the convergence result
below, are \textbf{independent} of:

\begin{itemize}
\tightlist
\item
  the choice of Layer-1 global slot spacing (Section 5.2), and
\item
  any admissible Layer-2 refinement heuristic (Section 5.3),
\end{itemize}

as long as the mesh contains all band boundaries and order prices as
nodes.

\paragraph{6.6.5 Convergence to the continuous
model}\label{convergence-to-the-continuous-model-1}

We now summarize the convergence behavior.

Let:

\begin{itemize}
\tightlist
\item
  \(\sigma \to \infty\): increasing log-scaling precision,
\item
  \(\varepsilon_{\exp_2} \to 0\), \(\varepsilon_{\log_2} \to 0\):
  improving exp/log approximations,
\item
  fixed-point fractional lengths \(Q_S, Q_P, Q_Q \to \infty\): reducing
  arithmetic rounding error,
\item
  mesh diameter \(\delta = \max_k (l_{k+1} - l_k) \to 0\): refining the
  execution mesh (while still including all band boundaries and order
  prices).
\end{itemize}

Under these limits, we obtain:

\textbf{Theorem 6.8 (Numerical convergence; uniform global precision).}

Fix any price path interval \([l_{\mathrm{start}}, l_{\mathrm{end}}]\)
and any finite CLMM + CLOB state satisfying the local finiteness
assumptions of the paper. Let
(\(\Delta A_{\mathrm{true}}, \Delta B_{\mathrm{true}}\)) be the ideal
continuous CLMM deltas along this path, and let
(\(\hat{\Delta A}, \hat{\Delta B}\)) be the on-chain computed deltas
using:

\begin{itemize}
\tightlist
\item
  log encoding with scaling \(\sigma\),
\item
  (\(\operatorname{exp_2fp}\) and \(\operatorname{log_2fp}\) with error
  bounds \(\varepsilon_{\exp_2}, \varepsilon_{\log_2}\)),
\item
  Q-format arithmetic with rounding errors bounded per operation,
\item
  a mesh \(\mathcal{M}\) including all band boundaries and order prices,
  with maximum step \(\delta\).
\end{itemize}

Then there exists a constant \(C > 0\) (depending on liquidity and price
bounds but not on the numerical parameters) such that:

\[
\big| \hat{\Delta A} - \Delta A_{\mathrm{true}} \big| + \big| \hat{\Delta B} - \Delta B_{\mathrm{true}} \big|
  \le C \left( \frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}} \right)
\]

where \(\varepsilon_{\mathrm{arith}}\) captures worst-case cumulative
rounding error over all segments.

In particular, by jointly sending \(\sigma \to \infty\),
\(\varepsilon_{\exp_2} \to 0\), \(\varepsilon_{\log_2} \to 0\), and
increasing fractional bits in Q-formats, the numerical execution
converges to the continuous model:

\[
\hat{\Delta A} \to \Delta A_{\mathrm{true}}, \quad
\hat{\Delta B} \to \Delta B_{\mathrm{true}}
\]

\textbf{\emph{Proof Sketch.}}

Combine:

\begin{itemize}
\tightlist
\item
  the encoding error bound of Lemma 6.1,
\item
  the \(exp_2\)-induced price error bound of Lemma 6.2,
\item
  the arithmetic stability bound of Lemma 6.5,
\item
  the segment-wise error bound of Proposition 6.6,
\item
  linear aggregation across a finite number of segments,
\item
  and the exactness of mesh-based integrals in Proposition 6.7.
\end{itemize}

All terms are bounded by constants multiple of
(\(\frac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}}\))
for fixed liquidity and price ranges. \(\blacksquare\)

\begin{quote}
\textbf{Intuition:} Theorem 6.8 is the ``master convergence result'' for
the entire numerical system. It says: all the approximations we
make---rounding log-prices to integers, approximating \(2^x\) with
polynomials, doing fixed-point arithmetic---add up to a total error that
is proportional to our precision parameters. If you want more accuracy,
just use more bits. There's no mysterious accumulation of errors or
instability; the whole system behaves linearly in the precision you give
it. This is the payoff of working in log-space: multiplicative price
dynamics become additive, and errors compose predictably.
\end{quote}

\subsubsection{6.7 Implementation Considerations and Canonical Parameter
Choices}\label{implementation-considerations-and-canonical-parameter-choices}

The preceding subsections are stated in terms of abstract fixed-point
formats and generic error parameters
\((\sigma, \varepsilon_{\exp_2}, \varepsilon_{\log_2}, \varepsilon_{\mathrm{arith}})\).
For practical deployment, it is useful to record one concrete parameter
choice and its numerical implications. This subsection summarizes such a
choice in a platform-agnostic way; a more detailed, chain-specific
engineering specification can live in a separate whitepaper or protocol
documentation.

\paragraph{6.7.1 Log-Scaling Precision and Global Price
Resolution}\label{log-scaling-precision-and-global-price-resolution}

Recall that the log-sqrt-price is encoded as \(L \in \mathbb{Z}_w\) with
scaling \(\sigma = 2^F\) (Section 6.1), so that \(l \approx L/2^F\).
Increasing \(F\) improves the global resolution of prices in a uniform
way across the entire state space.

Two representative configurations are:

\begin{itemize}
\tightlist
\item
  \(F = 32\) (log step \(2^{-32} \approx 2.3 \times 10^{-10}\)),
\item
  \(F = 48\) (log step \(2^{-48} \approx 3.6 \times 10^{-15}\)).
\end{itemize}

From Lemma 6.1, the encoding-induced relative price error satisfies

\[
\left| \frac{\hat{P}}{P^*} - 1 \right| \lesssim C_P \cdot 2^{-F}
\]

for some constant \(C_P \in [1,2]\). Thus:

\begin{itemize}
\tightlist
\item
  For \(F = 32\), the global encoding error is \(O(10^{-10})\).
\item
  For \(F = 48\), the global encoding error is \(O(10^{-14})\),
  comparable to IEEE 754 double-precision relative error
  (\(\sim 10^{-15}\)) \autocite{higham2002accuracy}.
\end{itemize}

In both cases, the implied price range \(P \sim 2^{2l}\) is far larger
than any economically relevant region; the binding constraints in
practice come from the chosen Q-formats for \(S, P,\) and \(Q\), not
from the representable range of \(L\).

\paragraph{6.7.2 Canonical Fixed-Point
Layout}\label{canonical-fixed-point-layout}

A natural canonical layout, compatible with many modern execution
environments, is:

\begin{itemize}
\tightlist
\item
  Log-sqrt-price: \(L \in \mathbb{Z}_w\) (e.g.~signed 64-bit or wider)
  with \(F = 48\) fractional bits.
\item
  Sqrt-price: \(S_{\mathrm{fp}}\) in a Q\(64.64\) format, so that
  \(S \approx S_{\mathrm{fp}} / 2^{64}\).
\item
  Price: derived as \(P \approx S^2\) in a compatible Q-format
  (e.g.~Q\(64.64\) or Q\(96.32\)) and not necessarily stored
  persistently.
\item
  Liquidity: \(Q_{\mathrm{fp}}\) in a Q\(64.64\) (or similar) format.
\end{itemize}

With these choices, individual arithmetic operations have rounding error
of order \(2^{-64}\), and --- for realistic state bounds ---
intermediate products fit safely into 128-bit or wider accumulators.
Together with \(F = 48\), this yields global relative price errors of
order \(10^{-14}\) once the exp/log approximations are chosen
appropriately, in line with the convergence bounds of Theorem 6.8.

\paragraph{6.7.3 Integer--Fractional Decomposition for
Exponentiation}\label{integerfractional-decomposition-for-exponentiation}

On-chain computation of \(S(L) = 2^{L/\sigma}\) can be implemented by
splitting the exponent into integer and fractional parts. Writing

\[
L = q \cdot 2^F + r, \quad q \in \mathbb{Z}, \quad r \in \{0,1,\ldots,2^F - 1\},
\]

we have

\[
2^{L/2^F} = 2^{q + r/2^F} = 2^q \cdot 2^{r/2^F}.
\]

The integer factor \(2^q\) is implemented by shifts in the chosen
Q-format, while the fractional factor \(2^{r/2^F}\) is approximated on
the compact domain \([0,1)\), for example by a polynomial or table-based
routine as sketched in Section 6.3.2. By choosing a monotone
approximation on this domain and enforcing appropriate range checks, one
obtains an \(\operatorname{exp\_2fp}\) that is both strictly increasing
and has relative error bounded by a design parameter
\(\varepsilon_{\exp_2}\).

This decomposition ensures that:

\begin{itemize}
\tightlist
\item
  the ``large-scale'' dependence on price is handled by cheap integer
  shifts, and
\item
  the transcendental work is confined to a small, well-controlled
  fractional interval.
\end{itemize}

\paragraph{6.7.4 Summary}\label{summary}

The abstract error parameters in Section 6 admit concrete instantiations
where:

\begin{itemize}
\tightlist
\item
  \(F = 48\) (log scaling \(\sigma = 2^{48}\)),
\item
  Q\(64.64\) (or similar) formats are used for \(S, P,\) and \(Q\),
\item
  \(\operatorname{exp\_2fp}\) is implemented via integer--fractional
  decomposition with a monotone polynomial (or table) on \([0,1)\),
\end{itemize}

yielding global uniform relative price errors on the order of
\(10^{-14}\). The full engineering details --- including specific
polynomial coefficients, overflow policies, and platform-specific
integer widths --- are best treated in a separate implementation
specification, but the existence of such a configuration shows that the
continuous log-domain model is numerically realizable at numerical
precision comparable to centralized exchange systems.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

This section completes the bridge between the \textbf{ideal continuous
log-domain model} and the \textbf{finite-precision on-chain
realization}, showing that:

\begin{itemize}
\tightlist
\item
  the log-sqrt-price encoding is well-behaved and monotone,
\item
  the numerical exp/log routines can be abstractly specified via
  monotonicity and error bounds,
\item
  the CLMM dynamics implemented in fixed-point arithmetic converge to
  the continuous dynamics as precision is increased.
\end{itemize}

\subsection{7. Unified Execution Semantics: CLMM + CLOB +
Perpetuals}\label{unified-execution-semantics-clmm-clob-perpetuals}

We now extend the Layer-2 execution model (Section 5.3 and 5.5) to
specify \textbf{unified execution semantics} for:

\begin{itemize}
\tightlist
\item
  CLMM liquidity,
\item
  resting CLOB orders, and
\item
  perpetual futures positions (perps),
\end{itemize}

all evolving on the same log-sqrt-price axis \(l\).

Throughout this section, we fix a single trading pair (\(A, B\)), a
local mesh \(\mathcal{M} = \{ l_0 < l_1 < \ldots < l_N \}\) segment-wise
CLMM liquidity \({L_{\mathrm{AMM},k}}_{k=0}^{N-1}\) as in Section 5.5,
and CLOB order sets \({\mathcal{J}_k}_{k=0}^N\) at each mesh node
\(l_k\) as in Section 5.3.5.

We introduce:

\begin{itemize}
\tightlist
\item
  a \textbf{deterministic node execution ordering} at each \(l_k\),
\item
  a precise rule for \textbf{crossing CLOB orders} when the price path
  hits their level,
\item
  and a \textbf{perpetuals layer} whose mark prices, funding, and
  liquidations are all defined in the same coordinate \(l\), and whose
  liquidations are implemented as additional flows through the CLMM +
  CLOB execution engine.
\end{itemize}

\subsubsection{7.1 Local State and Price
Paths}\label{local-state-and-price-paths}

We first fix notation for the state on the mesh and notion of a price
path.

\paragraph{7.1.1 Node state}\label{node-state}

At a mesh node \(l_k\), we define the \textbf{\emph{local node state}}
at time \(t\) as:

\[
\mathcal{S}_k(t) = \big( A_{\mathrm{pool}}(t), B_{\mathrm{pool}}(t), {\mathcal{J}_k^{\mathrm{buy}}(t), \mathcal{J}_k^{\mathrm{sell}}(t)}, \mathcal{P}(t) \big)
\]

where:

\begin{itemize}
\tightlist
\item
  \(A_{\mathrm{pool}}(t), B_{\mathrm{pool}}(t)\) are the CLMM reserves
  at time \(t\),
\item
  \(\mathcal{J}_k^{\mathrm{buy}}(t)\) (resp.
  \(\mathcal{J}_k^{\mathrm{sell}}(t)\)) is the finite set of outstanding
  \textbf{buy} (resp. \textbf{sell}) limit orders with log-price equal
  to \(l_k\),
\item
  \(\mathcal{P}(t)\) collects any additional per-account data such as
  perp positions and margin (to be introduced in Section 7.4).
\end{itemize}

The \textbf{spot log-price} at time \(t\) is denoted by
\(l(t) \in \mathcal{M} \cup \bigcup_k (l_k, l_{k+1})\); the
corresponding spot price is

\[
P(t) = P(l(t)) = 2^{2 l(t)}
\]

\paragraph{7.1.2 Trade direction and price
path}\label{trade-direction-and-price-path}

Consider a single incoming trade, abstractly represented as a
\textbf{signed quantity} \(\Delta q\) in token \(B\) from the trader's
perspective:

\begin{itemize}
\tightlist
\item
  \(\Delta q > 0\): trader is \emph{buying} \(B\) (using \(A\) ),
  creating \textbf{upward} price pressure,
\item
  \(\Delta q < 0\): trader is \emph{selling} \(B\) (for \(A\) ),
  creating \textbf{downward} price pressure.
\end{itemize}

Given an initial log-price \(l_* = l(0)\) and a target bound
\(l_{\mathrm{target}}\) (from user limits, risk constraints, or path
planning), the \textbf{price path interval} is:

\[
I_{\mathrm{path}} =
\begin{cases}
[l_*, l_{\mathrm{target}}], & \text{if } l_{\mathrm{target}} \ge l_* \\
[l_{\mathrm{target}}, l_*], & \text{if } l_{\mathrm{target}} < l_*
\end{cases}
\]

as in Section 5.3.1. A \textbf{feasible execution path} is a continuous
function

\[
l : [0, T] \to I_{\mathrm{path}}
\]

that is piecewise monotone and respects the segment-wise CLMM dynamics
(Section 5.5) and node-wise CLOB matching rules that we now formalize.

Throughout, we assume the trade is \textbf{fully aggressive}: it
consumes any immediately marketable liquidity (CLOB or CLMM) available
along its direction until either the trade size is exhausted, the
endpoint of \(I_{\mathrm{path}}\) is reached, or no further liquidity is
available.

\subsubsection{7.2 Node Execution
Ordering}\label{node-execution-ordering}

We now specify a deterministic rule for the interaction between CLOB and
CLMM at a mesh node. Intuitively, \textbf{all executable CLOB volume at
the current node price is consumed before the price is allowed to move
into the adjacent CLMM segment}.

We first formalize ``direction'' at a node.

\paragraph{7.2.1 Direction at a node}\label{direction-at-a-node}

Let \(l(t) = l_k\) at some time \(t\), and suppose the remaining trade
quantity in token \(B\) is \(\Delta q_{\mathrm{rem}}(t)\).

\begin{itemize}
\tightlist
\item
  if \(\Delta q_{\mathrm{rem}}(t) > 0\), we say the \textbf{direction}
  at \(l_k\) is \textbf{up} (buy pressure, tending to move towards
  \(l_{k+1}\), provided \(k < N\)),
\item
  if \(\Delta q_{\mathrm{rem}}(t) < 0\), we say the \textbf{direction}
  at \(l_k\) is \textbf{down} (sell pressure, tending to move towards
  \(l_{k-1}\), provided \(k > 0\)).
\end{itemize}

At a node \(l_k\), \textbf{opposing-side} orders are those that can be
matched with the current trade direction:

\begin{itemize}
\tightlist
\item
  If direction is up (buy pressure), opposing orders are \textbf{sell}
  limit orders at \(l_k\): \(\mathcal{J}_k^{\mathrm{sell}}\).
\item
  If direction is down (sell pressure), opposing orders are \textbf{buy}
  limit orders at \(l_k\): \(\mathcal{J}_k^{\mathrm{buy}}\).
\end{itemize}

These are the orders that are \textbf{marketable} at the node's current
price \(P(l_k)\).

\paragraph{7.2.2 Deterministic node execution
rule}\label{deterministic-node-execution-rule}

We adopt the following \textbf{node execution rule}:

\textbf{Rule 7.1 (Node execution ordering).}

Let the current log-price be \(l(t) = l_k\) and remaining trade quantity
\(\Delta q_{\mathrm{rem}}(t) \neq 0\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{CLOB phase at node (l\_k).}

  \begin{itemize}
  \item
    If \(\Delta q_{\mathrm{rem}}(t) > 0\) (buy pressure), match against
    the opposing \textbf{sell} queue \(\mathcal{J}_k^{\mathrm{sell}}\)
    at \(P(l_k)\), following an internal deterministic order (e.g.,
    price-time priority \autocite{openbook2022,daian2020flash} or
    pro-rata) until either:

    \begin{itemize}
    \tightlist
    \item
      \(\mathcal{J}_k^{\mathrm{sell}}\) is empty, or
    \item
      \(\Delta q_{\mathrm{rem}}(t)\) is exhausted.
    \end{itemize}
  \item
    If \(\Delta q_{\mathrm{rem}}(t) < 0\) (sell pressure), match against
    the opposing \textbf{buy} queue \(\mathcal{J}_k^{\mathrm{buy}}\) at
    \(P(l_k)\), analogously.
  \end{itemize}

  No CLMM movement is allowed (i.e., \(l(t)\)) is held fixed at \(l_k\)
  while there remains any opposing-side volume \emph{and} remaining
  trade quantity.
\item
  \textbf{CLMM phase from node (l\_k).}

  If after step 1, we still have \(\Delta q_{\mathrm{rem}}(t) \neq 0\),
  then:

  \begin{itemize}
  \item
    If direction is up and \(k < N\), we enter the CLMM segment
    \([l_k, l_{k+1})\) with liquidity \(L_{\mathrm{AMM},k}\) and evolve
    \(l(t)\) within that segment according to the CLMM dynamics (Section
    5.5), until:

    \begin{itemize}
    \tightlist
    \item
      either the trade is fully executed (remaining quantity hits zero)
      at some interior point \(l \in (l_k, l_{k+1})\), or
    \item
      the segment boundary \(l_{k+1}\) is reached with remaining
      quantity.
    \end{itemize}
  \item
    If direction is down and \(k > 0\), we similarly enter segment
    \([l_{k-1}, l_k)\) with liquidity \(L_{\mathrm{AMM},k-1}\), moving
    towards \(l_{k-1}\).
  \end{itemize}
\item
  \textbf{Iteration across nodes.}
\end{enumerate}

\begin{itemize}
\tightlist
\item
  If a CLMM phase step ends at node \(l_{k\pm 1}\) with remaining
  quantity \(\Delta q_{\mathrm{rem}}(t) \neq 0\), we repeat the
  procedure from step 1 at the new node.
\end{itemize}

This rule imposes an unambiguous ordering between:

\begin{itemize}
\tightlist
\item
  resting CLOB liquidity at the node, and
\item
  CLMM segment-wise liquidity adjacent to the node.
\end{itemize}

In particular, at any node with opposing-side depth, \textbf{CLOB orders
at that level trade first} at the node's price \(P(l_k)\).

\textbf{Figure 9: Node Execution Ordering (Rule 7.1)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    NODE EXECUTION ORDERING: CLOB BEFORE CLMM                 │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  At each mesh node l\_k, execution follows a strict two{-}phase protocol:     │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │   ┌───────────────────────────────────────────────────────────┐    │   │}
\NormalTok{│  │   │          PHASE 1: CLOB MATCHING (price frozen)            │    │   │}
\NormalTok{│  │   └───────────────────────────────────────────────────────────┘    │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │         Incoming              At Node l\_k                          │   │}
\NormalTok{│  │         Buy Order   ───────►  ┌─────────────────────┐              │   │}
\NormalTok{│  │         (Δq \textgreater{} 0)              │  SELL orders queue  │              │   │}
\NormalTok{│  │                               │  at price P(l\_k)    │              │   │}
\NormalTok{│  │                               │  ┌───┬───┬───┬───┐  │              │   │}
\NormalTok{│  │                               │  │ S₁│ S₂│ S₃│...│  │ ◄── Match   │   │}
\NormalTok{│  │                               │  └───┴───┴───┴───┘  │     these   │   │}
\NormalTok{│  │                               └─────────────────────┘     first    │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │         • Price l(t) stays FIXED at l\_k during CLOB matching       │   │}
\NormalTok{│  │         • All fills occur at exactly P(l\_k)                        │   │}
\NormalTok{│  │         • Continue until: orders exhausted OR trade filled         │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                               │                                             │}
\NormalTok{│                               │ If Δq\_rem ≠ 0 (trade not complete)         │}
\NormalTok{│                               ▼                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │   ┌───────────────────────────────────────────────────────────┐    │   │}
\NormalTok{│  │   │          PHASE 2: CLMM SEGMENT TRAVERSAL                  │    │   │}
\NormalTok{│  │   └───────────────────────────────────────────────────────────┘    │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │         l\_k                               l\_\{k+1\}                  │   │}
\NormalTok{│  │          │                                   │                      │   │}
\NormalTok{│  │          ▼                                   ▼                      │   │}
\NormalTok{│  │          ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━●                      │   │}
\NormalTok{│  │          │◄────── CLMM segment ──────────►│                        │   │}
\NormalTok{│  │          │      liquidity = L\_AMM,k        │                        │   │}
\NormalTok{│  │          │                                 │                        │   │}
\NormalTok{│  │          │    l(t) moves continuously     │                        │   │}
\NormalTok{│  │          │    within segment as trade     │                        │   │}
\NormalTok{│  │          │    executes against AMM        │                        │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  │         • Price moves: P(l\_k) → P(l) as l increases                │   │}
\NormalTok{│  │         • Uses segment formulas: ΔB = L·(2\^{}l {-} 2\^{}l\_k)              │   │}
\NormalTok{│  │         • Stop when: segment boundary reached OR trade filled      │   │}
\NormalTok{│  │                                                                     │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                               │                                             │}
\NormalTok{│                               │ If boundary reached with Δq\_rem ≠ 0        │}
\NormalTok{│                               ▼                                             │}
\NormalTok{│                    ┌─────────────────────┐                                  │}
\NormalTok{│                    │  Move to node l\_\{k+1\}│                                 │}
\NormalTok{│                    │  Repeat from Phase 1 │                                 │}
\NormalTok{│                    └─────────────────────┘                                  │}
\NormalTok{│                                                                             │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│  KEY GUARANTEE: No arbitrage between CLOB and CLMM at same price level    │}
\NormalTok{│                 (CLOB always executes first while available)               │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 9: The node execution ordering rule ensures deterministic,
fair execution at each mesh node. Phase 1 matches all available opposing
CLOB orders at the fixed price P(l\_k) before any price movement. Phase
2 enters the adjacent CLMM segment only after CLOB depth is exhausted,
allowing price to move continuously. This two-phase protocol prevents
arbitrage between CLOB and CLMM at the same price level and provides
price-time priority for limit orders.}

\paragraph{7.2.3 No-arbitrage between CLOB and CLMM at a
node}\label{no-arbitrage-between-clob-and-clmm-at-a-node}

We now formalize that, under Rule 7.1, there is \textbf{no opportunity
to trade at different prices} at the same node between the CLMM and the
CLOB.

\textbf{Proposition 7.2 (No CLOB-CLMM arbitrage at node).}

Fix a node \(l_k\) and suppose the spot log-price \(l(t)\) equals
\(l_k\) at time \(t\). Suppose there exists opposing-side CLOB liquidity
at \(l_k\) (i.e., \(\mathcal{J}_k^{\mathrm{sell}} \neq \emptyset\) for
buy pressure, or \(\mathcal{J}_k^{\mathrm{buy}} \neq \emptyset\) for
sell pressure). Then, under Rule 7.1:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  All trades executed at time \(t\) occur at the unique price
  \(P(l_k)\), regardless of whether they consume CLOB or CLMM liquidity.
\item
  No trader can execute at a strictly better price via the CLMM while
  opposing-side CLOB liquidity remains at \(l_k\).
\end{enumerate}

\textbf{\emph{Proof.}}

Under Rule 7.1, as long as opposing-side CLOB depth is present at
\(l_k\) and the trade has remaining quantity, the CLMM phase is not
entered and the log-price \(l(t)\) is frozen at \(l_k\). Therefore:

\begin{itemize}
\tightlist
\item
  Any instantaneous CLMM differential (dA, dB) at that moment (if we
  hypothetically allowed a CLMM trade of infinitesimal size) would be
  priced at the marginal price associated with \(l_k\), namely
  \(P(l_k)\).
\item
  All actual executions during the CLOB phase occur at price \(P(l_k)\)
  by definition of the limit order price.
\end{itemize}

Since the CLMM phase is only entered after all opposing CLOB depth at
\(l_k\) is exhausted, there is no state in which:

\begin{itemize}
\tightlist
\item
  opposing CLOB at price \(P(l_k)\) remains, and
\item
  the CLMM trades at a different price.
\end{itemize}

Thus, during the CLOB phase, all trades execute at the same unique price
\(P(l_k)\), and there is no opportunity to buy cheaper or sell higher
via the CLMM as long as CLOB liquidity remains at that node. \(\square\)

\begin{quote}
\textbf{Intuition:} Proposition 7.2 ensures fair execution: when both a
limit order book and an AMM coexist at the same price level, you can't
``game'' the system by picking whichever gives you a better deal. The
rule is simple---limit orders always get filled first at their posted
price. Only after they're exhausted does the AMM kick in. Since both
execute at the same price, there's no arbitrage between them. This is
crucial for a hybrid system: it means limit-order makers get proper
priority, and takers can't exploit price discrepancies.
\end{quote}

\paragraph{7.2.4 Price continuity}\label{price-continuity}

Note that in Rule 7.1:

\begin{itemize}
\tightlist
\item
  during a CLOB phase at node \(l_k\), the price path \(l(t)\) is
  \textbf{constant} \(l(t) = l_k\),
\item
  during a CLMM phase, \(l(t)\) evolves \textbf{continuously} within a
  segment \([l_k, l_{k+1})\) under the CLMM dynamics (Section 5.5),
\item
  at the transition between segments \([l_k, l_{k+1})\) and
  \([l_{k+1}, l_{k+2})\), the endpoint \(l_{k+1}\) is shared, so the
  concatenated path is continuous.
\end{itemize}

Thus:

\textbf{Lemma 7.3 (Price path continuity).}

Under Rule 7.1, for any aggressive trade and any finite set of CLOB
orders on the mesh, the resulting price path \(l(t)\) is continuous on
\([0,T]\). CLOB executions produce \emph{jumps in reserves and order
book state} but not jumps in \(l(t)\).

\textbf{\emph{Proof.}}

Immediate from the construction: all CLOB matching occurs at fixed
\(l_k\); all CLMM movement follows continuous evolution within segments;
segment endpoints match. \(\square\)

\subsubsection{7.3 Crossing a CLOB order at a Mesh
Node}\label{crossing-a-clob-order-at-a-mesh-node}

The local mesh construction (Section 5.3.2-5.3.5) ensures that each CLOB
order price \(l_{0,j}\) appears as some mesh node \(l_k\). We now
formalize how an \textbf{incoming price path that crosses such a node}
must interact with the order.

Let \(j\) be a CLOB order with log-price \(l_{0,j}\) and quantity
\(q_j > 0\), and suppose \(l_{0,j} = l_k\) for some \(k\). Assume the
trade direction is such that the order is \emph{marketable} once the
path reaches \(l_k\) (i.e., a buy-side aggressive trade crossing a
resting sell, or vice versa).

We consider the limit behavior as the price approaches \(l_k\) from
below or above.

\paragraph{7.3.1 Crossing in log-space}\label{crossing-in-log-space}

Consider a monotone segment of the price path \(l(t)\) with direction up
or down, and suppose there exists a time \(t_0\) such that:

\[
\lim_{\epsilon \to 0^+} l(t_0 - \epsilon) = l^- \neq l_k, \quad \lim_{\epsilon \to 0^+} l(t_0 + \epsilon) = l^+
\]

with \(l^- < l_k \leq l^+\) in the case of upward motion, or
\(l^- > l_k \geq l^+\) in the case of downward motion.

We say that the path \textbf{crosses the node} \(l_k\) at time \(t_0\).
By construction of the execution algorithm, the following holds.

\textbf{Proposition 7.4 (Instantaneous consumption at order price).}

Let \(j\) be an order at node \(l_k\) that is marketable given the
direction of motion, and suppose a trade's price path crosses \(l_k\) at
time \(t_0\) as above. Then under Rule 7.1:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Immediately upon reaching \(l_k\) (i.e.~when \(l(t) = l_k\)), the
  execution enters a CLOB phase at node \(k\) and consumes order \(j\)
  (possibly partially, depending on remaining trade quantity).
\item
  The token reserves \(A_{\mathrm{pool}}, B_{\mathrm{pool}}\) are
  \textbf{discontinuous} at time \(t_0\) due to the discrete transfer
  from the resting order, but the log-price \(l(t)\) is continuous at
  \(t_0\).
\item
  If the remaining trade quantity after matching at \(l_k\) is nonzero,
  the execution then continues into the adjacent CLMM segment in the
  direction of motion.
\end{enumerate}

\textbf{\emph{Proof Sketch.}}

As soon as the path reaches \(l_k\), Rule 7.1 mandates a CLOB phase at
node \(k\) before any further CLMM movement. Since order \(j\) is
marketable (opposing-side at the node's price), it is included in the
set of orders considered in step 1 of Rule 7.1 and is either fully or
partially consumed at price \(P(l_k)\). This induces a jump in the
trader's and counterparty's balances and, if the counterparty is
external to the pool, no immediate change in pool reserves; if the CLOB
is internalized by the pool or a hybrid design, it can be represented as
a discrete jump in the pool or LP balances. In either case, the state of
the book changes discretely, while \(l(t)\) remains pinned at \(l_k\)
during the matching, hence continuous at \(t_0\).

Once no further opposing-side liquidity at \(l_k\) remains (or the trade
is fully filled), Rule 7.1 allows the execution to proceed into the
adjacent CLMM segment in the direction of the residual trade quantity,
yielding the claimed behavior. \(\square\)

The limit notation

\[
\lim_{\epsilon \to 0^+} l(t_0 \pm \epsilon) = l_{0,j}
\]

is thus compatible with the execution semantics: the price path is
continuous through \(l_{0,j}\), while the \textbf{state of reserves and
order queue} may have discrete jumps at that time.

\subsubsection{7.4 Perpetuals on the Log-Price
Axis}\label{perpetuals-on-the-log-price-axis}

We now extend the framework to include perpetual futures (perps)
\autocite{bitmex2016perpetual,dydx2023v4} whose mark price, funding, and
liquidation logic are all expressed on the same log-price axis \(l\).
This subsection describes a \textbf{generic perpetual module} that can
be layered on the log-axis, including the standard funding rate
mechanism used by most existing perpetual protocols. In Section 8, we
specialize to a \textbf{spot-anchored design} where funding is
identically zero by construction; the present subsection establishes the
general execution semantics that both designs share.

The key design goal is:

\begin{itemize}
\tightlist
\item
  perps \textbf{do not introduce a separate price notion}, but instead
  derive all price-dependent logic from \(P(l)\), and
\item
  perps \textbf{inject additional order flow} (liquidations, forced
  reductions) into the same CLMM + CLOB execution engine defined above.
\end{itemize}

\paragraph{7.4.1 Perpetual positions and mark
price}\label{perpetual-positions-and-mark-price}

We fix a \textbf{settlement token}, which without loss of generality we
take to be \(A\). A perp position for account \(m\) is specified by:

\begin{itemize}
\tightlist
\item
  a signed position size \(q_m \in \mathbb{R}\) in units of \(B\)
  (positive for long, negative for short),
\item
  a margin balance \(M_m \geq 0\) in token \(A\),
\item
  possibly additional accrued funding / fees states \(F_m\).
\end{itemize}

The \textbf{mark log-price} at time \(t\) is simply the pool log-price:

\[
l_{\mathrm{mark}}(t) := l(t)
\]

and the mark price is:

\[
P_{\mathrm{mark}}(t) := P(l_{\mathrm{mark}}(t)) = 2^{2 l(t)}.
\]

For each account \(m\), we define the \textbf{mark-to-market equity} (in
units of token \(A\)) as;

\[
E_m(t) = M_m + q_m \cdot P_{\mathrm{mark}}(t) + F_m
\]

where \(F_m\) absorbs any accumulated funding payments, realized PnL,
and fees.

This ties all perp valuation to the \textbf{same spot price process}
\(P(l(t))\) generated by CLMM + CLOB execution.

\paragraph{7.4.2 Funding rate}\label{funding-rate}

We do not commit to a particular funding scheme but assume a generic
process where a scalar \textbf{funding rate} \(f(t)\)
\autocite{bitmex2016perpetual,dydx2023v4} is derived from the
discrepancy between:

\begin{itemize}
\tightlist
\item
  the perp's implicit ``fair'' price \(P_{\mathrm{perp}}(t)\) (e.g.,
  oracle or basis-adjusted), and
\item
  the spot price \(P_{\mathrm{mark}}(t)\).
\end{itemize}

One natural choice is:

\[
P_{\mathrm{perp}}(t) = P\big(l_{\mathrm{oracle}}(t)\big)
\]

where \(l_{\mathrm{oracle}}(t)\) is an external log-price process (e.g.,
a time-weighted oracle). The \textbf{basis} in log-space is then:

\[
\Delta l_{\mathrm{basis}}(t) = l_{\mathrm{perp}}(t) - l_{\mathrm{oracle}}(t)
\]

and a funding rate function \(f : \mathbb{R} \to \mathbb{R}\)
(e.g.~linear) can be applied:

\[
f(t) = f\big( \Delta l_{\mathrm{basis}}(t) \big).
\]

Funding over a small time interval {[}\(t, t + dt\){]} updates each
account's (\(F_m\)) according to:

\[
dF_m(t) = - q_m \cdot f(t) \ dt
\]

with \(\sum_m dF_m(t) = 0\) (funding is a zero-sum transfer between
longs and shorts). The precise choice of \(f\) and oracle process
\(l_{\mathrm{oracle}}(t)\) is orthogonal to the unified execution
semantics; all that matters is that they are functions of the same
log-price axis.

\paragraph{\texorpdfstring{7.4.3 Liquidation thresholds in
\(l\)-space}{7.4.3 Liquidation thresholds in l-space}}\label{liquidation-thresholds-in-l-space}

Following standard perpetual protocol design
\autocite{bitmex2016perpetual,dydx2023v4}, each account \(m\) has:

\begin{itemize}
\tightlist
\item
  an \textbf{initial margin requirement} \(\mathrm{IM}_m(q_m)\),
\item
  a \textbf{maintenance margin requirement} \(\mathrm{MM}_m(q_m)\),
\end{itemize}

both specified as nonnegative functions of position size \(q_m\) (and
possibly volatility, portfolio composition, etc.).

An account is \textbf{eligible for liquidation} at time \(t\) when:

\[
E_m(t) \leq \mathrm{MM}_m(q_m).
\]

This inequality can be rewritten in terms of log-price \(l(t)\) via:

\[
E_m(t) = M_m + q_m \cdot 2^{2 l(t)} + F_m.
\]

For any fixed account \(m\) and fixed margin state (\(M_m, F_m, q_m\)),
this condition defines a \textbf{liquidation region in log-price space}.
In particular, if \(q_m > 0\) (long), then there exists a critical
log-price \(l_{\mathrm{liq},m}\) solving:

\[
M_m + q_m \cdot 2^{2 l_{\mathrm{liq},m}} + F_m = \mathrm{MM}_m(q_m)
\]

such that \(E_m(t) \leq \mathrm{MM}_m(q_m)\) for all
\(l(t) \leq l_{\mathrm{liq},m}\). Analogous statements hold for shorts.

Thus, \textbf{liquidation boundaries are themselves level sets in the
log-price axis}.

\paragraph{7.4.4 Liquidation as forced order flow through the
engine}\label{liquidation-as-forced-order-flow-through-the-engine}

When \(E_m(t) \leq \mathrm{MM}_m(q_m)\), the protocol may initiate a
\textbf{liquidation action} for account \(m\), which we model as an
\textbf{aggressive trade} along the same CLMM + CLOB execution
machinery.

For concreteness, consider a simple policy: fully close the position
\(q_m\) upon liquidation. The liquidator (or protocol) generates a
trade:

\begin{itemize}
\tightlist
\item
  For a long position (\(q_m > 0\)), a \textbf{sell} order of size
  \(q_{\mathrm{liq}} = q_m\) in token \(B\),
\item
  For a short position (\(q_m < 0\)), a \textbf{buy} order of size
  \(|q_m|\).
\end{itemize}

We treat this as an aggressive trade with remaining quantity
\(\Delta q_{\mathrm{rem}}(0) = - q_m\) (for closing a long) or
\(\Delta q_{\mathrm{rem}}(0) = |q_m|\) (for closing a short, consistent
with the sign convention), starting at the current log-price
\(l(0) = l_{\mathrm{mark}}(t)\). This trade is then executed by:

\begin{itemize}
\tightlist
\item
  first matching against opposing-side CLOB depth at the node,
\item
  then traversing CLMM segments if necessary,
\end{itemize}

\textbf{exactly} as in Rule 7.1.

Formally, let
(\(A_{\mathrm{pool}}^{\mathrm{pre}}, B_{\mathrm{pool}}^{\mathrm{pre}}, \mathcal{P}^{\mathrm{pre}}\))
be the state just before liquidation; let
(\(A_{\mathrm{pool}}^{\mathrm{post}}, B_{\mathrm{pool}}^{\mathrm{post}}, \mathcal{P}^{\mathrm{post}}\))
be the state immediately after the forced trade is fully executed. Then:

\begin{itemize}
\tightlist
\item
  The perp position for account \(m\) is updated to zero:
  \(q_m^{\mathrm{post}} = 0\),
\item
  The margin account \(M_m\) is debited or credited by the realized PnL
  of the closing trade (and fees),
\item
  The CLMM + CLOB state has been updated according to our usual
  dynamics,
\item
  Other accounts are unaffected except via price impact and funding
  transfers.
\end{itemize}

This yield the following structural property.

\textbf{Proposition 7.5 (Unified execution under liquidation).}

Assume liquidations are implemented as aggressive trades through the
unified CLMM + CLOB engine as above. Then:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Liquidations do not introduce any new price notion beyond \(P(l)\);
  the closing trades are executed at the same prices and along the same
  path as any other aggressive trade.
\item
  The total change in pool reserves
  \((A_{\mathrm{pool}}, B_{\mathrm{pool}})\) and the price path \(l(t)\)
  during a liquidation event are determined solely by:

  \begin{itemize}
  \tightlist
  \item
    the existing CLMM liquidity density \(\lambda(l)\),
  \item
    the CLOB order book \(\mu\),
  \item
    and the liquidation trade size, with no special cases required
  \end{itemize}
\item
  If we consider a counterfactual scenario where an external trader
  submitted an identical aggressive order at the same time, the
  resulting price path and pool reserve changes would be identical.
\end{enumerate}

\textbf{\emph{Proof Sketch.}}

In our construction, a liquidation is represented as nothing more than a
specific aggressive trade with a deterministic size and direction,
entering the same execution machinery as any other trade. The execution
semantics (Rule 7.1 and the CLMM segment dynamics of Section 5.5) are
independent of the identity of the flow origin (liquidation
vs.~voluntary trade). Therefore:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The price path \(l(t)\) is governed by the same local mesh and
  liquidity density, and hence the same mapping \(P(l)\).
\item
  The pool reserve deltas and order book updates follow exactly the same
  rules.
\item
  Substituting the liquidation with an equal-size aggressive order from
  an arbitrary external trader at the same log-price yields an identical
  execution; the only difference is how the resulting PnL is attributed
  to margin accounts.
\end{enumerate}

\(\square\)

This shows that perpetuals are \textbf{logically layered on top of},
rather than ``beside'', the spot CLMM + CLOB engine. All complexity of
perps (funding, margin, liquidation) ultimately reduces to:

\begin{itemize}
\tightlist
\item
  accounting changes in \(\mathcal{P}\), and
\item
  additional aggressive trades along the unified log-price axis.
\end{itemize}

\subsubsection{7.5 Summary of Unified
Semantics}\label{summary-of-unified-semantics}

The execution semantics developed in this section can be summarized as
follows:

\begin{itemize}
\item
  The \textbf{log-price process} \(l(t)\) is continuous, driven by a
  combination of:

  \begin{itemize}
  \tightlist
  \item
    discrete CLOB executions at mesh nodes (which do not move \(l\)),
    and
  \item
    continuous CLMM evolution along segments (which move \(l\)).
  \end{itemize}
\item
  At any node \(l_k\),

  \begin{itemize}
  \tightlist
  \item
    all \textbf{marketable CLOB volume at that node} is consumed first
    at price \(P(l_k)\),
  \item
    only then is the adjacent CLMM segment entered, ensuring \textbf{no
    CLOB-CLMM arbitrage at the node}.
  \end{itemize}
\item
  \textbf{CLOB orders} at price \(l_{0,j}\) are consumed at the instant
  the price path reaches \(l_{0,j}\), causing jumps in reserves and
  order book state but not in the log-price itself.
\item
  \textbf{Perpetuals}:

  \begin{itemize}
  \tightlist
  \item
    derive all pricing, margins, and liquidations from the same
    log-price axis via \(P(l)\),
  \item
    use mark-to-market equity functions \(E_m(t)\) expressed in \(l\),
  \item
    and implement liquidations as ordinary aggressive trades through the
    CLMM + CLOB engine.
  \end{itemize}
\end{itemize}

Thus, CLMM liquidity, CLOB depth, and perpetuals all share a
\textbf{single, coherent, execution semantics} on the log-price axis.
The low-level numerical realizations (fixed-point encoding, exp/log
routines, mesh refinement) covered in Section 6 do not alter these
semantics; they only approximate them with provably bounded error.

\subsection{8. Spot-Anchored Derivative Layer on the Log-Price
Axis}\label{spot-anchored-derivative-layer-on-the-log-price-axis}

In this section, we introduce a derivative layer (perpetual swaps,
expiring futures, and options) that is \emph{entirely anchored} to the
spot log-price process generated by the unified CLMM + CLOB engine. This
represents a \textbf{specialization} of the generic perpetual semantics
introduced in Section 7.4: we retain the same execution machinery (mark
price derived from \(l(t)\), liquidations as forced order flow, unified
CLMM + CLOB engine), but eliminate the funding rate mechanism entirely
by anchoring derivative prices directly to spot and hedging atomically
at trade time.

The key design principles are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  There is a \textbf{single price process} \(l(t)\), hence a single spot
  price process \(P(l(t)) = 2^{2 l(t)}\).
\item
  Derivatives \textbf{do not define a separate price curve}; their
  payoffs and mark-to-market values are functionals of \(P(l(t))\) only.
\item
  The protocol maintains \textbf{delta-neutrality} with respect to the
  underlying by hedging net derivative exposure via the same CLMM + CLOB
  spot engine.
\item
  LPs in the spot layer \textbf{do not warehouse derivative directional
  risk}; they see derivative hedging flow as additional spot order flow
  and earn corresponding fees.
\end{enumerate}

This yields a derivative architecture with:

\begin{itemize}
\tightlist
\item
  no separate ``perp price'',
\item
  no basis between spot and perps,
\item
  and no need for traditional funding-rate mechanics.
\end{itemize}

Throughout, we work with a fixed trading pair (\(A, B\)) and the
log-sqrt-price coordinate \(l(t)\) as in Sections 5-7.

\subsubsection{8.1 State and Account
Model}\label{state-and-account-model}

We first formalize the global state and the account structure required
for derivatives.

\paragraph{8.1.1 Global spot state}\label{global-spot-state}

We retain the unified spot state from Section 7. At time \(t\), the spot
engine is characterized by:

\begin{itemize}
\tightlist
\item
  log-sqrt price \(l(t) \in \mathbb{R}\),
\item
  spot price \(P(t) := P(l(t)) = 2^{2 l(t)}\),
\item
  CLMM reserves \((A_{\mathrm{pool}}(t), B_{\mathrm{pool}}(t))\),
\item
  CLOB order sets
  \({\mathcal{J}_k^{\mathrm{buy}}(t), \mathcal{J}_k^{\mathrm{sell}}(t)}\)
  on the mesh nodes \(l_k\),
\item
  liquidity density \(\lambda(l)\) as in Section 5.1.2.
\end{itemize}

The evolution of \(l(t)\) and pool reserves is governed by the unified
CLMM + CLOB execution semantics of Section 7.

\paragraph{8.1.2 Derivative accounts}\label{derivative-accounts}

Let \(\mathcal{M}\) be the set of derivative accounts (traders) indexed
by \(m \in \mathcal{M}\). Each account \(m\) has:

\begin{itemize}
\item
  a \textbf{margin balance} \(M_m(t) \geq 0\) in token \(A\),
\item
  a set of \textbf{perpetual positions}
  \(\{ q_{m, \alpha}(t) \}_{\alpha \in \mathcal{I}_{\mathrm{perp}}}\),
  where:

  \begin{itemize}
  \tightlist
  \item
    \(\alpha\) indexes derivative instruments (e.g.~product ID, market),
  \item
    \(q_{m, \alpha}(t) \in \mathbb{R}\) is the signed position size in
    units of token \(B\) (positive = long, negative = short),
  \end{itemize}
\item
  (optionally) a set of \textbf{futures} or \textbf{options} positions
  \(\{ \pi_{m, \beta}(t) \}_{\beta \in \mathcal{I}_{\mathrm{opt}}}\),
\item
  an accumulated \textbf{PnL and fee state} \(F_m(t) \in \mathbb{R}\) in
  units of token \(A\).
\end{itemize}

The exact indexing of instruments is not essential; we focus first on a
single perpetual instrument and later generalize.

\subsubsection{8.2 Spot-Anchored Perpetual
Swaps}\label{spot-anchored-perpetual-swaps}

We begin with a single perpetual swap on \((A, B)\) and define it as a
\textbf{delta-one claim} on the spot price process \(P(l(t))\), without
its own price curve.

\paragraph{8.2.1 Perpetual positions}\label{perpetual-positions}

Fix a single perpetual instrument and omit the \(\alpha\) index for
brevity. A perpetual position for account \(m\) at time \(t\) is
specified by:

\begin{itemize}
\tightlist
\item
  size \(q_m(t) \in \mathbb{R}\) in units of token \(B\),
\item
  an \textbf{effective entry price}
  \(P_{\mathrm{entry},m}(t) \in \mathbb{R}_{>0}\),
\item
  a margin balance \(M_m(t)\),
\item
  and accumulated PnL + fees \(F_m(t)\).
\end{itemize}

We assume that position updates (opens, partial closes, reversals) are
normalized so that at any time \(t\) there exists a well-defined
effective entry price \(P_{\mathrm{entry},m}(t)\), for instance via
volume-weighted average on notional.

\paragraph{8.2.2 Mark price and mark-to-market
equity}\label{mark-price-and-mark-to-market-equity}

Let the \textbf{mark log-price} at time \(t\) be the current spot
log-price:

\[
l_{\mathrm{mark}}(t) := l(t)
\]

and the \textbf{mark price} be the spot price:

\[
P_{\mathrm{mark}}(t) := P(l_{\mathrm{mark}}(t)) = 2^{2 l(t)}.
\]

The mark-to-market equity of account \(m\) in units of token \(A\) is:

\[
E_m(t) = M_m(t) + q_m(t)\big( P_{\mathrm{mark}}(t) - P_{\mathrm{entry},m}(t) \big) + F_m(t)
\]

There is no separate perp mid-price; the unique mark price is
\(P_{\mathrm{mark}}(t)\).

\textbf{Definition 8.1 (Spot-anchored perpetual swap).}

A spot-anchored perpetual swap on \((A, B)\) is a contract whose PnL for
account \(m\) is given by:

\[
\mathrm{PnL}_m(t) = q_m(t) \big( P(l(t)) - P_{\mathrm{entry},m}(t) \big) + F_m(t)
\]

with \textbf{mark price} equal to the spot price \(P(l(t))\) at all
times.

In particular, there is no funding term; all valuation is strictly tied
to the spot process.

\paragraph{8.2.3 Basis and absence of
funding}\label{basis-and-absence-of-funding}

In traditional perpetual swap designs
\autocite{bitmex2016perpetual,dydx2023v4,gmx2022technical,perp2021v2},
one distinguishes:

\begin{itemize}
\tightlist
\item
  a perp mark price \(P_{\mathrm{perp}}(t)\),
\item
  a spot price \(P_{\mathrm{spot}}(t)\),
\end{itemize}

and defines a \textbf{basis}:

\[
\mathrm{basis}(t) = P_{\mathrm{perp}}(t) - P_{\mathrm{spot}}(t)
\]

with funding designed to penalize non-zero basis.

In our design, we identify:

\[
P_{\mathrm{perp}}(t) := P_{\mathrm{mark}}(t) = P(l(t)), \quad P_{\mathrm{spot}}(t) := P(l(t))
\]

hence:

\textbf{Proposition 8.2 (Zero basis by construction).}

For a spot-anchored perpetual swap as in Definition 8.1, the basis is
identically zero:

\[
\mathrm{basis}(t) \equiv 0, \quad \forall t \ge 0
\]

and hence any traditional funding term proportional to
\(\mathrm{basis}(t)\) vanishes identically.

\textbf{\emph{Proof.}}

Immediate from the identifications
\(P_{\mathrm{perp}}(t) = P_{\mathrm{spot}}(t) = P(l(t))\) for all \(t\).
\(\square\)

In particular, the derivative layer introduces no independent price
curve; all economics are inherited from the spot log-price process.

\textbf{Figure 10: Spot-Anchored vs.~Traditional Perpetual Design}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    PERPETUAL SWAP DESIGN COMPARISON                          │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  TRADITIONAL PERP DESIGN (e.g., most CEX and DEX perps [@bitmex2016perpetual; @dydx2023v4; @gmx2022technical; @perp2021v2])   │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     P\_perp(t)  ──────────────────────┐                                     │}
\NormalTok{│     (perp mark price,               │                                      │}
\NormalTok{│      from order book                │                                      │}
\NormalTok{│      or TWAP oracle)                │  basis(t) = P\_perp {-} P\_spot         │}
\NormalTok{│                                     │             (can be ≠ 0)             │}
\NormalTok{│     P\_spot(t)  ─────────────────────┤                                      │}
\NormalTok{│     (spot price,                    │                                      │}
\NormalTok{│      from external                  │                                      │}
\NormalTok{│      oracle or AMM)                 │                                      │}
\NormalTok{│                                                                             │}
\NormalTok{│     ┌─────────────────────────────────────────────────────────────────┐    │}
\NormalTok{│     │  FUNDING RATE = f(basis) · position\_size                        │    │}
\NormalTok{│     │                                                                 │    │}
\NormalTok{│     │  • Longs pay shorts when basis \textgreater{} 0 (perp overpriced)           │    │}
\NormalTok{│     │  • Shorts pay longs when basis \textless{} 0 (perp underpriced)          │    │}
\NormalTok{│     │  • Applied periodically (e.g., every 8 hours)                  │    │}
\NormalTok{│     │  • Creates carry costs and complexity                          │    │}
\NormalTok{│     └─────────────────────────────────────────────────────────────────┘    │}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  SPOT{-}ANCHORED PERP DESIGN (this paper)                                    │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     P\_perp(t) = P\_spot(t) = P(l(t)) = 2\^{}\{2l(t)\}                           │}
\NormalTok{│                     │                                                       │}
\NormalTok{│                     │  ◄── SINGLE PRICE SOURCE                             │}
\NormalTok{│                     │      (the unified spot engine)                        │}
\NormalTok{│                     │                                                       │}
\NormalTok{│                     ▼                                                       │}
\NormalTok{│     ┌─────────────────────────────────────────────────────────────────┐    │}
\NormalTok{│     │  basis(t) ≡ 0    (by construction, for all t)                  │    │}
\NormalTok{│     │                                                                 │    │}
\NormalTok{│     │  FUNDING RATE ≡ 0  (no funding mechanism needed)               │    │}
\NormalTok{│     │                                                                 │    │}
\NormalTok{│     │  • No carry costs for holding positions                        │    │}
\NormalTok{│     │  • No oracle risk for mark price                               │    │}
\NormalTok{│     │  • PnL purely from spot price movement                         │    │}
\NormalTok{│     └─────────────────────────────────────────────────────────────────┘    │}
\NormalTok{│                                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│  HOW IT WORKS:                                                             │}
\NormalTok{│  ═══════════════════════════════════════════════════════════════════════   │}
\NormalTok{│                                                                             │}
\NormalTok{│     User opens long perp (+q)  ───────┐                                    │}
\NormalTok{│                                       │                                     │}
\NormalTok{│                                       ▼                                     │}
\NormalTok{│                         ┌─────────────────────────┐                        │}
\NormalTok{│                         │   Protocol Hedge        │                        │}
\NormalTok{│                         │   Sells q tokens spot   │                        │}
\NormalTok{│                         │   via CLMM + CLOB       │                        │}
\NormalTok{│                         └───────────┬─────────────┘                        │}
\NormalTok{│                                     │                                       │}
\NormalTok{│                                     ▼                                       │}
\NormalTok{│              Net protocol exposure: +q (perp) {-} q (spot) = 0              │}
\NormalTok{│                                                                             │}
\NormalTok{│     Result: Protocol is always delta{-}neutral; no funding needed to        │}
\NormalTok{│             incentivize balance between longs and shorts                   │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 10: Traditional perpetual designs maintain separate perp
and spot prices, creating a basis that must be managed via funding rate
payments. Our spot-anchored design uses the unified spot price P(l(t))
as the single source of truth for both spot and perp valuation. By
construction, basis ≡ 0, eliminating funding entirely. The protocol
maintains delta-neutrality by hedging perp exposure directly in the spot
engine, not by relying on funding to balance longs and shorts.}

\subsubsection{8.3 Protocol-Level Delta Hedging on the Log
Axis}\label{protocol-level-delta-hedging-on-the-log-axis}

To avoid warehousing net directional risk, the protocol maintains a
hedge in the underlying spot asset via the CLMM + CLOB engine. This
approach adapts classical delta-hedging techniques from options theory
\autocite{black1973pricing,merton1973theory} to the perpetual swap
context.

\paragraph{8.3.1 Net perp exposure and hedge
position}\label{net-perp-exposure-and-hedge-position}

Let

\[
Q_{\mathrm{net}}(t) = \sum_{m \in \mathcal{M}} q_m(t)
\]

be the aggregate perp exposure in units of token \(B\). The protocol
maintains a \textbf{spot hedge position}
\(H_{\mathrm{spot}}(t) \in \mathbb{R}\) in token \(B\) via trades in the
underlying spot engine.

We define the \textbf{delta-neutrality constraint}:

\[
H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}(t), \quad \forall t
\]

Thus, whenever a perp position changes (e.g.~a trade opens or closes),
the protocol adjusts its spot hedge by:

\[
\Delta H_{\mathrm{spot}} = - \Delta Q_{\mathrm{net}}
\]

by executing a corresponding spot trade through the CLMM + CLOB engine.

\paragraph{8.3.2 Atomic hedging as a composite
operation}\label{atomic-hedging-as-a-composite-operation}

At the level of the economic model, we view each perp trade as an
\textbf{atomic composite operation} consisting of:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Updating the perp position \(q_m\) and their entry prices
  \(P_{\mathrm{entry},m}\),
\item
  Adjusting the spot hedge \(H_{\mathrm{spot}}\) so that

  \[
  H_{\mathrm{spot}}^{\mathrm{post}} = H_{\mathrm{spot}}^{\mathrm{pre}} - \Delta Q_{\mathrm{net}}
  \]
\item
  Executing the hedge adjustment \(\Delta H_{\mathrm{spot}}\) as an
  aggressive spot trade via the unified CLMM + CLOB execution semantics
  (Section 7).
\end{enumerate}

We assume these steps occur at a common logical time \(t_0\) and at the
\textbf{current log-price} \(l(t_0)\), so that:

\begin{itemize}
\tightlist
\item
  the perp's entry/exit price equals \(P(l(t_0))\),
\item
  the hedge trade is priced according to the same spot engine and may
  move \(l(t)\) depending on size and available liquidity.
\end{itemize}

This leads to the following.

\textbf{Definition 8.3 (Atomic hedged perp trade).}

An atomic hedged perp trade at time \(t_0\) is a composite state update
\(\mathcal{S}(t_0^-) \to \mathcal{S}(t_0^+)\) satisfying:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For some account \(m\), \(q_m\) changes by \(\Delta q_m \neq 0\) with
  entry or exit price equal to \(P(l(t_0^-))\),
\item
  The net exposure changes by \(\Delta Q_{\mathrm{net}} = \Delta q_m\),
\item
  The protocol's spot hedge position is updated by
  \(\Delta H_{\mathrm{spot}} = - \Delta Q_{\mathrm{net}}\),
\item
  The change \(\Delta H_{\mathrm{spot}}\) is realized as an aggressive
  trade through the CLMM + CLOB engine starting from log-price
  \(l(t_0^-)\).
\end{enumerate}

At the modeling level, we treat this composite as instantaneous, with
resulting spot price \(l(t_0^+)\) determined by the unified execution
semantics.

\textbf{Figure 11: Atomic Hedged Perp Trade Mechanics}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{┌─────────────────────────────────────────────────────────────────────────────┐}
\NormalTok{│                    ATOMIC HEDGED PERP TRADE (Definition 8.3)                 │}
\NormalTok{├─────────────────────────────────────────────────────────────────────────────┤}
\NormalTok{│                                                                             │}
\NormalTok{│  BEFORE TRADE (time t₀⁻):                                                   │}
\NormalTok{│  ══════════════════════════════════════════════════════════════════════    │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────┐         ┌─────────────────────────┐           │}
\NormalTok{│  │     PERP POSITIONS      │         │     PROTOCOL HEDGE      │           │}
\NormalTok{│  ├─────────────────────────┤         ├─────────────────────────┤           │}
\NormalTok{│  │  User A: +10 (long)     │         │                         │           │}
\NormalTok{│  │  User B: {-}5  (short)    │         │  H\_spot = {-}Q\_net = {-}5   │           │}
\NormalTok{│  │  User C: 0              │         │  (short 5 tokens B)     │           │}
\NormalTok{│  ├─────────────────────────┤         │                         │           │}
\NormalTok{│  │  Q\_net = +5             │◄───────►│  Net exposure = 0       │           │}
\NormalTok{│  └─────────────────────────┘         └─────────────────────────┘           │}
\NormalTok{│                                                                             │}
\NormalTok{│  USER C OPENS LONG POSITION: Δq\_m = +20                                    │}
\NormalTok{│  ══════════════════════════════════════════════════════════════════════    │}
\NormalTok{│                                                                             │}
\NormalTok{│       ┌─────────────────────────────────────────────────────────────┐      │}
\NormalTok{│       │                   ATOMIC OPERATION                          │      │}
\NormalTok{│       │         (all steps at logical time t₀)                      │      │}
\NormalTok{│       └─────────────────────────────────────────────────────────────┘      │}
\NormalTok{│                               │                                             │}
\NormalTok{│                               │                                             │}
\NormalTok{│           ┌───────────────────┼───────────────────┐                        │}
\NormalTok{│           │                   │                   │                        │}
\NormalTok{│           ▼                   ▼                   ▼                        │}
\NormalTok{│   ┌───────────────┐   ┌───────────────┐   ┌───────────────────────┐       │}
\NormalTok{│   │  STEP 1:      │   │  STEP 2:      │   │  STEP 3:              │       │}
\NormalTok{│   │  Update perp  │   │  Compute      │   │  Execute spot hedge   │       │}
\NormalTok{│   │  position     │   │  hedge delta  │   │  via CLMM + CLOB      │       │}
\NormalTok{│   │               │   │               │   │                       │       │}
\NormalTok{│   │  q\_C: 0 → +20 │   │  ΔH\_spot =    │   │  Sell 20 tokens B     │       │}
\NormalTok{│   │  Entry price: │   │  {-}ΔQ\_net =    │   │  into the spot        │       │}
\NormalTok{│   │  P(l(t₀⁻))    │   │  {-}20          │   │  engine               │       │}
\NormalTok{│   └───────────────┘   └───────────────┘   └───────────────────────┘       │}
\NormalTok{│                                                   │                        │}
\NormalTok{│                                                   ▼                        │}
\NormalTok{│                                           Price may move:                  │}
\NormalTok{│                                           l(t₀⁻) → l(t₀⁺)                  │}
\NormalTok{│                                                                             │}
\NormalTok{│  AFTER TRADE (time t₀⁺):                                                   │}
\NormalTok{│  ══════════════════════════════════════════════════════════════════════    │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────┐         ┌─────────────────────────┐           │}
\NormalTok{│  │     PERP POSITIONS      │         │     PROTOCOL HEDGE      │           │}
\NormalTok{│  ├─────────────────────────┤         ├─────────────────────────┤           │}
\NormalTok{│  │  User A: +10 (long)     │         │                         │           │}
\NormalTok{│  │  User B: {-}5  (short)    │         │  H\_spot = {-}Q\_net = {-}25  │           │}
\NormalTok{│  │  User C: +20 (long) NEW │         │  (short 25 tokens B)    │           │}
\NormalTok{│  ├─────────────────────────┤         │                         │           │}
\NormalTok{│  │  Q\_net = +25            │◄───────►│  Net exposure = 0       │           │}
\NormalTok{│  └─────────────────────────┘         └─────────────────────────┘           │}
\NormalTok{│                                                                             │}
\NormalTok{│  ┌─────────────────────────────────────────────────────────────────────┐   │}
\NormalTok{│  │  INVARIANT: H\_spot(t) = {-}Q\_net(t)  always maintained                │   │}
\NormalTok{│  │  RESULT: Protocol has zero directional exposure at all times        │   │}
\NormalTok{│  └─────────────────────────────────────────────────────────────────────┘   │}
\NormalTok{│                                                                             │}
\NormalTok{└─────────────────────────────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 11: An atomic hedged perp trade updates the user's perp
position and the protocol's spot hedge in a single logical operation.
When User C opens a +20 long position, the protocol simultaneously sells
20 tokens B into the spot engine, maintaining the invariant H\_spot =
-Q\_net. The hedge trade executes through the same CLMM + CLOB engine as
any other spot trade, potentially moving the price. The protocol remains
delta-neutral at all times.}

\paragraph{8.3.3 Combined PnL of perps and
hedge}\label{combined-pnl-of-perps-and-hedge}

Let the \textbf{perp layer PnL} be:

\[
\mathrm{PnL}^{\mathrm{perp}}(t) = \sum_{m\in \mathcal{M}} \big( q_m(t)\big( P(l(t)) - P_{\mathrm{entry},m}(t)\big) + F_m(t) \big)
\]

and the \textbf{hedge PnL} (in units of token \(A\)) from the protocol's
spot hedge be denoted \(\mathrm{PnL}^{\mathrm{hedge}}(t)\), computed
from the sequence of spot trades
\(\{ \Delta H_{\mathrm{spot}}(\tau) \}\) executed along the spot price
path \(P(l(\tau))\).

Under continuous-time idealization and ignoring fees for the moment, if
the hedge position is maintained continuously as

\[
H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}(t)
\]

then the infinitesimal combined PnL change obeys:

\textbf{Lemma 8.4 (Infinitesimal delta-neutrality).}

Assume:

\begin{itemize}
\tightlist
\item
  the protocol adjusts \(H_{\mathrm{spot}}(t)\) continuously so that
  \(H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}(t)\) for all \(t\),
\item
  all trades occur at the spot price \(P(l(t))\) with no slippage or
  fees.
\end{itemize}

then, for any infinitesimal change in log-price \(dl\) (equivalently in
spot price \(dP\)), the combined PnL of perps + hedge satisfies:

\[
d\big( \mathrm{PnL}^{\mathrm{perp}}(t) + \mathrm{PnL}^{\mathrm{hedge}}(t) \big) = 0
\]

\textbf{\emph{Proof Sketch.}}

Under these assumptions, at time \(t\), the perp layer's infinitesimal
PnL change from a price move \(dP\) is:

\[
d\mathrm{PnL}^{\mathrm{perp}}(t) = Q_{\mathrm{net}}(t) \, dP
\]

The hedge PnL change is:

\[
d\mathrm{PnL}^{\mathrm{hedge}}(t) = H_{\mathrm{spot}}(t) \, dP
\]

Under the delta-neutrality constraint
\(H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}(t)\), we have:

\[
d\mathrm{PnL}^{\mathrm{perp}}(t) + d\mathrm{PnL}^{\mathrm{hedge}}(t) = Q_{\mathrm{net}}(t)\, dP - Q_{\mathrm{net}}(t)\, dP = 0
\]

\(\square\)

\begin{quote}
\textbf{Intuition:} Lemma 8.4 is the heart of the hedging strategy. It
says: if you hold a portfolio that's long \(X\) units of perp and
simultaneously short \(X\) units of spot, price movements don't affect
your total value---gains on one side exactly cancel losses on the other.
This is classic ``delta hedging'' from options theory
\autocite{black1973pricing,merton1973theory}, but applied to perpetuals.
The protocol uses this to offload directional risk: every time someone
opens a perp, the protocol immediately takes the opposite spot position,
keeping itself market-neutral.
\end{quote}

In discrete time with atomic hedged perp trades (Definition 8.3), the
same property holds between hedge adjustments, and any residual risk
arises only from re-hedging discretization and fees.

\subsubsection{8.4 LP Exposure and Fee
Sharing}\label{lp-exposure-and-fee-sharing}

We now formalize the statement that LPs in the spot engine do
\textbf{not} take on additional directional risk from the derivative
layer; they only interact with hedging and liquidation flow as ordinary
spot flow.

\paragraph{8.4.1 Order flow
decomposition}\label{order-flow-decomposition}

Consider the spot engine viewed as a pure CLMM + CLOB market as in
Sections 5-7. Let us conceptually decompose all spot trades over some
time interval \([0, T]\) into:

\begin{itemize}
\tightlist
\item
  \textbf{exogenous spot flow}: trades originating from non-derivative
  users (ordinary swaps, spot limit orders),
\item
  \textbf{derivative hedge flow}: trades originating from the protocol's
  spot hedge adjustments for perps, futures, or options (including
  liquidations).
\end{itemize}

Formally, we can write the \textbf{total net traded amount in token
\(B\)} seen by the spot engine to time \(T\) as:

\[
\Delta B_{\mathrm{total}}(0\to T) = \Delta B_{\mathrm{exo}}(0\to T) + \Delta B_{\mathrm{hedge}}(0\to T)
\]

where \(\Delta B_{\mathrm{hedge}}\) is the signed sum of all hedge
trades \(\Delta H_{\mathrm{spot}}\) and liquidation-induced trades.

From the spot engine's perspective, there is no intrinsic distinction
between these two sources; both are just sequences of market and limit
orders executed via the unified CLMM + CLOB semantics.

\paragraph{8.4.2 LP wealth as a functional of spot
flow}\label{lp-wealth-as-a-functional-of-spot-flow}

Let \(\mathcal{W}_{\mathrm{LP}}(T)\) denote the (vector of) LP wealth at
time \(T\), i.e.~the values of all LP positions in tokens \(A\) and
\(B\) plus accumulated fees, expressed in some numeraire. Under the CLMM
+ CLOB model, for a fixed path \(l(t)\) and fixed sequences of spot
trades hitting the pool, \(\mathcal{W}_{\mathrm{LP}}(T)\) is completely
determined by:

\begin{itemize}
\tightlist
\item
  the \textbf{initial LP positions} (band ranges, amounts, order
  placements),
\item
  the \textbf{path of spot price} \(l(t)\),
\item
  the \textbf{sequence of spot trades} (sizes and directions) routed
  through the engine.
\end{itemize}

Importantly, the derivative layer does not introduce any new state
variable into this dependence; it only changes the composition of spot
order flow.

We can thus write:

\[
\mathcal{W}_{\mathrm{LP}}(T) = \Phi\big( l(\cdot), { \Delta B_{\mathrm{total}}(\tau)}\_{\tau\in [0,T]} \big)
\]

for some functional \(\Phi\) induced by the CLMM + CLOB dynamics.

\paragraph{8.4.3 No additional directional derivative risk for
LPs}\label{no-additional-directional-derivative-risk-for-lps}

We now formalize that LPs do not ``carry the other side'' of perp
positions.

Consider two worlds:

\begin{itemize}
\item
  \textbf{World A (With derivatives):} The system includes the
  spot-anchored perp layer with protocol-level hedging as in Section
  8.3. The spot engine sees total order flow
  \(\Delta B_{\mathrm{total}} = \Delta B_{\mathrm{exo}} + \Delta B_{\mathrm{hedge}}\).
\item
  \textbf{World B (Without derivatives):} There is no perp layer;
  instead, the spot engine receives an exogenous sequence of spot trades
  whose net token \(B\) flow matches \(\Delta B_{\mathrm{total}}\)
  exactly.
\end{itemize}

\textbf{Proposition 8.5 (LP risk equivalence).}

Fix an initial CLMM + CLOB state and a spot price path \(l(t)\). Suppose
that in World A and World B the spot engine sees the \textbf{same total
spot flow} \(\Delta B_{\mathrm{total}}\) over \([0,T]\). Then, the LP
wealth at time \(T\) is identical in both worlds:

\[
\mathcal{W}_{\mathrm{LP}}^{A}(T) = \mathcal{W}_{\mathrm{LP}}^{B}(T)
\]

\textbf{\emph{Proof Sketch.}}

In both worlds, the CLMM + CLOB engine starts from the same initial
state, sees the same sequence of spot trades (sizes and directions) and
the same price path \(l(t)\), governed by the unified execution rules.
The engine does not distinguish whether a particular trade originated
from a hedging operation, a liquidation, or an ordinary user. The update
rules for LP positions and fees depend only on the sequence of trades
and price path, which are identical by assumption. Therefore the
resulting LP wealth functional \(\Phi\) has the same arguments in both
worlds, yielding
\(\mathcal{W}_{\mathrm{LP}}^{A}(T) = \mathcal{W}_{\mathrm{LP}}^{B}(T)\).
\(\square\)

This shows that, relative to any given spot price path and aggregate
order flow, LPs do not incur \textbf{additional directional risk} simply
because a derivative layer exists; they are not systematically on the
other side of perp bets. They only see more (or differently structured)
spot flow and corresponding fee opportunities.

\begin{quote}
\textbf{Intuition:} Proposition 8.5 answers a critical question: ``Do
LPs get burned by the derivatives layer?'' The answer is no. From an
LP's perspective, a trade is a trade---they don't know or care whether
it came from someone swapping tokens, or from the protocol hedging a
perpetual position. What matters is the total volume and direction.
Since the protocol's hedges are executed as ordinary spot trades through
the same AMM, LPs earn the same fees and face the same impermanent loss
as they would from any other order flow of equal size. The derivatives
layer gives LPs \emph{more} trading volume (and thus more fees) without
changing their fundamental risk profile.
\end{quote}

In particular, the protocol may allocate to LPs a \textbf{share of
derivative-layer fees} (e.g.~a fraction of perp open/close fees) as
compensation for providing the underlying price discovery and liquidity,
without implying that LPs bear the derivative layer's net exposure.

\subsubsection{8.5 Margin, Liquidations, and Forced
Flow}\label{margin-liquidations-and-forced-flow}

We briefly specialize the generic liquidation logic from Section 7.4 to
the spot-anchored perp layer.

\paragraph{8.5.1 Margin and liquidation
condition}\label{margin-and-liquidation-condition}

For each account \(m\), given position \(q_m(t)\) and equity \(E_m(t)\)
as in Section 8.2, we assume:

\begin{itemize}
\tightlist
\item
  an \textbf{initial margin} requirement \(\mathrm{IM}_m(q_m)\),
\item
  a \textbf{maintenance margin} requirement \(\mathrm{MM}_m(q_m)\),
\end{itemize}

both nonnegative functions of position size and, possibly, other risk
factors.

Account \(m\) is eligible for liquidation at time \(t\) when:

\[
E_m(t) \leq \mathrm{MM}_m(q_m)
\]

Using \(P(l(t)) = 2^{2 l(t)}\), this defines for each \(m\) a
\textbf{liquidation region} in log-price space:

\[
\mathcal{L}_m = { l \in \mathbb{R} : M_m + q_m(2^{2l} - P_{\mathrm{entry},m}) + F_m \le \mathrm{MM}_m(q_m) }
\]

Under monotonicity of \(P(l)\), this is typically an interval (e.g.~for
a long position, liquidation when \(l\) falls below a critical level).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{           Equity E\_m(l)}
\NormalTok{               │}
\NormalTok{               │         ╱}
\NormalTok{   IM ─────────┼────────╱────────────────────  Initial Margin}
\NormalTok{               │       ╱}
\NormalTok{               │      ╱}
\NormalTok{   MM ─────────┼─────╱───────────────────────  Maintenance Margin}
\NormalTok{               │    ╱}
\NormalTok{               │   ╱}
\NormalTok{    0 ─────────┼──╱──────────────────────────}
\NormalTok{               │ ╱}
\NormalTok{         ██████│╱                              Liquidation Zone}
\NormalTok{         ██████│                               (E\_m ≤ MM)}
\NormalTok{         ██████│}
\NormalTok{        ───────┼──────────────────────────► log{-}price l}
\NormalTok{               │}
\NormalTok{          l\_liq│   l\_entry}
\NormalTok{               │}
\NormalTok{               ▼}

\NormalTok{    For a LONG position (q\_m \textgreater{} 0):}
\NormalTok{    ┌─────────────────────────────────────────────────────┐}
\NormalTok{    │  E\_m(l) = M\_m + q\_m·(P(l) {-} P\_entry) + F\_m          │}
\NormalTok{    │                                                     │}
\NormalTok{    │  • Equity increases as l increases (price rises)    │}
\NormalTok{    │  • Liquidation region: l \textless{} l\_liq (shaded zone)      │}
\NormalTok{    │  • At l\_liq: E\_m = MM\_m (liquidation threshold)     │}
\NormalTok{    │  • Position opened at l\_entry with margin M\_m       │}
\NormalTok{    └─────────────────────────────────────────────────────┘}

\NormalTok{    For a SHORT position (q\_m \textless{} 0):}
\NormalTok{    ┌─────────────────────────────────────────────────────┐}
\NormalTok{    │  Equity DECREASES as l increases (price rises)      │}
\NormalTok{    │  Liquidation region: l \textgreater{} l\_liq (high prices)        │}
\NormalTok{    └─────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 12:} Margin thresholds and liquidation region for a long
perpetual position. Equity \(E_m(l)\) varies linearly with log-price
\(l\) (via \(P(l) = 2^{2l}\)). When equity falls below the maintenance
margin (MM), the position enters the liquidation zone (shaded). Initial
margin (IM) is required to open a position; MM is the threshold for
forced closure.\_

\paragraph{8.5.2 Liquidation as aggressive hedged
trades}\label{liquidation-as-aggressive-hedged-trades}

When the liquidation condition is met for an account \(m\), the protocol
may initiate a \textbf{forced close} of all or part of \(q_m\). In the
simplest case, the protocol closes the full position size \(q_m\) via:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  An aggressive perp trade \(\Delta q_m = - q_m\),
\item
  An equal and opposite hedge update
  \(\Delta H_{\mathrm{spot}} = - \Delta Q_{\mathrm{net}} = q_m\),
\item
  Execution of \(\Delta H_{\mathrm{spot}}\) as an aggressive spot trade
  via the unified CLMM + CLOB engine.
\end{enumerate}

By Definition 8.3, this is an atomic hedged perp trade. The resulting
spot price path during liquidation is determined entirely by the
existing spot liquidity and the forced trade size; no additional
liquidation-specific microstructure is needed at the derivative layer.

This reinforces the view that liquidations are \textbf{just another
source of aggressive spot order flow} along the log-price axis.

\subsubsection{8.6 Extension to Expiring Futures and
Options}\label{extension-to-expiring-futures-and-options}

The same approach extends naturally to expiring futures and options
whose payoffs are functions of the log-price at expiry.

\paragraph{8.6.1 Expiring futures}\label{expiring-futures}

An expiring future on \((A, B)\) with expiry \(T\) and strike \(K\) (in
units of \(A\)) is defined by payoff:

\[
\mathrm{Payoff}_m^{\mathrm{fut}} = q_m \big( P(l(T)) - K \big)
\]

with mark-to-market equity updated continuously against the spot price
\(P(l(t))\), for example via standard futures margining:

\[
E_m(t) = M_m(t) + q_m(t)\big( P(l(t)) - P_{\mathrm{ref}}(t) \big) + F_m(t)
\]

where \(P_{\mathrm{ref}}(t)\) is an appropriate reference (e.g.~prior
settlement).

The protocol may maintain delta-neutrality in the same way as for perps,
by setting:

\[
H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}^{\mathrm{fut}}(t)
\]

and executing hedge adjustments via the spot engine.

\paragraph{8.6.2 European options}\label{european-options}

A European option with expiry \(T\) and payoff \(\Phi(P(l(T)))\)
(e.g.~\max{P(l(T)) - K, 0} for a call) can be represented as a position
\(\pi_m\) with terminal payoff:

\[
\mathrm{Payoff}_m^{\mathrm{opt}} = \pi_m \cdot \Phi(P(l(T)))
\]

The protocol may choose to:

\begin{itemize}
\tightlist
\item
  remain unhedged (warehousing option risk),
\item
  or implement \textbf{delta-hedging} strategies based on the derivative
  of \(\Phi\) with respect to \(P\), i.e.~using the Greeks (\(\Delta\),
  \(\Gamma\), etc.) from classical option pricing theory
  \autocite{black1973pricing,merton1973theory} computed against the same
  spot process \(P(l(t))\).
\end{itemize}

In the latter case, each hedging update is again just a spot trade via
the CLMM + CLOB engine, and the analysis of LP risk exposure carries
over.

\subsubsection{8.7 Summary}\label{summary-1}

This section has defined a \textbf{spot-anchored derivative layer} in
which:

\begin{itemize}
\tightlist
\item
  all derivatives (perps, futures, options) are priced and margined
  exclusively against the spot price \(P(l(t)) = 2^{2 l(t)}\) on the
  log-price axis,
\item
  there is no independent derivative price curve and hence no basis or
  funding term is needed,
\item
  the protocol maintains delta-neutrality by hedging net derivative
  exposure via the same unified CLMM + CLOB engine, executing hedges as
  ordinary spot trades,
\item
  LPs in the spot layer do not warehouse net derivative directional
  risk; from their perspective, derivative activity appears only as
  additional spot flow, and their wealth depends solely on the spot path
  and aggregate order flow,
\item
  liquidations are realized as forced aggressive trades along the
  log-price axis, requiring no special matching mechanism beyond the
  existing execution semantics.
\end{itemize}

This establishes that the three-layer log-domain spot architecture
(Sections 5-7) naturally supports a fourth, derivative layer that is
economically coherent, platform-agnostic, and structurally closer to
traditional centralized exchanges (single unified price, shared
liquidity, atomic hedging) than existing on-chain perpetual and options
designs
\autocite{bitmex2016perpetual,dydx2023v4,gmx2022technical,perp2021v2,drift2023v2,synthetix2020litepaper}.

\subsection{9. Formal Guarantees of the Derivative
Layer}\label{formal-guarantees-of-the-derivative-layer}

In this section, we formalize the stochastic structure, no-arbitrage
properties, residual hedging risk, execution validity, fee invariants,
and computational complexity of the spot-anchored derivative layer
introduced in Section 8. Throughout, we assume the three-layer
log-domain spot architecture of Section 5-7 and the spot-anchored
perpetual construction of Section 8.

Unless otherwise stated, all quantities are expressed in units of token
\(A\).

\subsubsection{9.1 Log-Price Process as a Stochastic
Object}\label{log-price-process-as-a-stochastic-object}

We begin by formalizing the log-price process \(l(t)\) generated by the
unified CLMM + CLOB engine.

\paragraph{9.1.1 Probability space and
filtration}\label{probability-space-and-filtration}

Let \((\Omega, \mathcal{F}, \mathbb{P})\) be a probability space endowed
with a filtration \(\{ \mathcal{F}_t \}_{t \ge 0}\) satisfying the usual
conditions (right-continuity, completeness)
\autocite{shreve2004stochastic}. We view:

\begin{itemize}
\tightlist
\item
  \textbf{Exogenous order flow} (external spot orders, user perp
  positions, etc.) as a collection of adapted processes \(\Xi(t)\)
  taking values in a suitable state space \(\mathcal{X}\) of order
  streams,
\item
  \textbf{Oracle inputs} (if any, e.g., volatility feeds) as adapted
  processes \(\mathcal{O}(t)\).
\end{itemize}

We assume that the CLMM + CLOB engine and derivative layer define a
measurable \textbf{execution operator}:

\[
\mathcal{E}: (\Xi(\cdot), \mathcal{O}(\cdot)) \mapsto (l(\cdot), \mathcal{S}(\cdot))
\]

where \(\mathcal{S}(t)\) denotes the full on-chain state at time \(t\)
(pool reserves, order books, positions, margins, etc.).

\paragraph{9.1.2 Log-price path
regularity}\label{log-price-path-regularity}

We model the log-price path \(l(t)\) as:

\begin{itemize}
\tightlist
\item
  \textbf{adapted}: \(l(t)\) is \(\mathcal{F}_t\)-measurable for all
  \(t\),
\item
  \textbf{càdlàg}: right-continuous with left limits
  \autocite{shreve2004stochastic},
\item
  \textbf{piecewise monotone} between trade events.
\end{itemize}

Intuitively:

\begin{itemize}
\tightlist
\item
  between executions, \(l(t)\) is constant;
\item
  when a (possibly aggregated) trade executes, \(l(t)\) moves
  monotonically along the log-axis according to the CLMM + CLOB
  execution semantics of Section 7, possibly crossing finitely many CLOB
  nodes, and mesh segments;
\item
  at each trade time \(\tau\), we allow \(l(t)\) to have a jump
  discontinuity at \(\tau\), corresponding to the end-point of executed
  path.
\end{itemize}

For convenience, we collect these properties.

\textbf{Assumption 9.1 (Execution-induced price path).}

The unified CLMM + CLOB execution engine induces a log-price process
\(l(t)_{t \ge 0}\) such that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(l(t)\) is (\(\mathcal{F}_t\))-adapted and càdlàg,
\item
  There exists a countable (locally finite) set of trade times
  \({ \tau_n }_{n \in \mathbb{N}}\) with \(\tau_n \uparrow \infty\),
  such that:

  \begin{itemize}
  \tightlist
  \item
    on each interval \((\tau_n, \tau_{n+1})\), \(l(t)\) is constant,
  \item
    at each \(\tau_n\), \(l(t)\) moves along a piecewise-monotone path
    in \(l\)-space determined by the corresponding order flow in
    \(\Xi(\tau_n)\), with finitely many node crossings.
  \end{itemize}
\end{enumerate}

This is consistent with the Layer-2 mesh semantics of Section 5.3 and
the per-trade execution rules of Section 7.

\subsubsection{9.2 No-Arbitrage and Uniqueness of the Spot-Anchored Mark
Price}\label{no-arbitrage-and-uniqueness-of-the-spot-anchored-mark-price}

We now show that, in the presence of frictionless trading in the spot
engine, the spot-anchored mark price used in Section 8 is the unique
choice compatible with absence of static arbitrage between spot and
perps.

\paragraph{9.2.1 Setup}\label{setup}

Fix a time \(t\) and suppress time subscripts for clarity. Let:

\begin{itemize}
\tightlist
\item
  \(P_{\mathrm{spot}} := P(l(t)) = 2^{2 l(t)}\) be the spot price
  determined by the unified CLMM + CLOB engine,
\item
  \(P_{\mathrm{mark}}\) be the \textbf{perp mark price} used to value
  and margin perp positions at that time.
\end{itemize}

We assume the following:

\begin{itemize}
\tightlist
\item
  Traders can open or close perp positions at execution prices equal (up
  to small fees and slippage, which we momentarily ignore) to the
  current mark price \(P_{\mathrm{mark}}\),
\item
  Traders can trade the underlying spot via the CLMM + CLOB engine at
  the prevailing spot price \(P_{\mathrm{spot}}\), again ignoring small
  bid-ask spreads for the arbitrage argument.
\item
  Perp PnL is settled (continuously or discretely) against the mark
  price.
\end{itemize}

\paragraph{9.2.2 Arbitrage construction for misaligned
marks}\label{arbitrage-construction-for-misaligned-marks}

We now formalize the intuitive statement that
\(P_{\mathrm{mark}} \neq P_{\mathrm{spot}}\) allows an instantaneous
arbitrage.

\textbf{Proposition 9.2 (Uniqueness of spot-anchored mark price).}

Suppose the markets support frictionless trading as above and that the
perp mark price \(P_{\mathrm{mark}}\) is used both for execution and for
PnL/margin. If \(P_{\mathrm{mark}} \neq P_{\mathrm{spot}}\), then there
exists a self-financing trading strategy with non-negative initial cost
and strictly positive terminal wealth with positive probability. In
particular, absence of such static arbitrage implies:

\[
P_{\mathrm{mark}} = P_{\mathrm{spot}} = P(l(t))
\]

\textbf{\emph{Proof Sketch.}}

Consider two cases.

\textbf{Case 1: \(P_{\mathrm{mark}} > P_{\mathrm{spot}}\).}

Consider an agent who:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  At time \(t\), \textbf{shorts} one unit of the perp at price
  \(P_{\mathrm{mark}}\). This yields an effective short exposure of (-1)
  in units of \(B\), with mark-to-market at \(P_{\mathrm{mark}}\).
\item
  Simultaneously, \textbf{buys} one unit of the underlying via the spot
  engine at price \(P_{\mathrm{spot}}\), paying \(P_{\mathrm{spot}}\)
  units of \(A\).
\end{enumerate}

Net initial cash flow:

\begin{itemize}
\tightlist
\item
  From step 1: effectively zero net cash if we assume symmetric margin
  (or positive if initial margin is posted in a separate account and not
  fully funded).
\item
  From step 2: \(- P_{\mathrm{spot}}\)
\end{itemize}

Now consider an instantaneous re-marketing at the same time \(t\). The
perp short's PnL, when marking at \(P_{\mathrm{mark}}\), is zero at
inception; however, the \textbf{economic value} of the position relative
to the spot hedge is:

\begin{itemize}
\item
  The agent is short ``one unit of \(B\) at \(P_{\mathrm{mark}}\)'' and
  long one unit of \(B\) at \(P_{\mathrm{spot}}\). If they close both
  legs at spot price \(P_{\mathrm{spot}}\), they:

  \begin{itemize}
  \tightlist
  \item
    buy back the perp exposure (by going long one unit) at the mark
    \(P_{\mathrm{mark}}\),
  \item
    sell their spot unit at \(P_{\mathrm{spot}}\).
  \end{itemize}
\end{itemize}

At closure, the combined payoff (ignoring margin mechanics) is:

\[
\Pi = P_{\mathrm{mark}} - P_{\mathrm{spot}} > 0
\]

since they synthetically sold at \(P_{\mathrm{mark}}\) and bought at
\(P_{\mathrm{spot}}\). Thus, a round-trip strategy yields strictly
positive profit with zero net risk.

\textbf{Case 2: \(P_{\mathrm{mark}} < P_{\mathrm{spot}}\).}

The agent reverses the strategy:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Long} one unit of perp at \(P_{\mathrm{mark}}\),
\item
  \textbf{Short} one unit of spot at \(P_{\mathrm{spot}}\).
\end{enumerate}

Closing at spot yields payoff:

\[
\Pi = P_{\mathrm{spot}} - P_{\mathrm{mark}} > 0
\]

In both cases, an instantaneous arbitrage exists if
\(P_{\mathrm{mark}} \neq P_{\mathrm{spot}}\). Therefore, in any model
excluding such arbitrage, we must have:

\[
P_{\mathrm{mark}} = P_{\mathrm{spot}} = P(l(t))
\]

\(\square\)

In Section 8, we set \(P_{\mathrm{mark}} := P(l(t))\); Proposition 9.2
shows this is not merely a design choice but the \textbf{unique}
no-arbitrage prescription under frictionless trading between spot and
perps.

\begin{quote}
\textbf{Intuition:} Proposition 9.2 says that if the perpetual's mark
price ever drifts away from the spot price, even briefly, traders can
instantly profit by going long on the cheaper market and short on the
more expensive one. Since both positions have the same underlying
exposure, the mismatch creates free money. The only way to prevent this
is to lock the mark price to the spot price at all times---which is
exactly what the spot-anchored design does.
\end{quote}

\subsubsection{9.3 Residual Hedging Risk Under Discrete
Execution}\label{residual-hedging-risk-under-discrete-execution}

In Section 8.3, we idealized hedging as continuous and exact. We now
quantify the error introduced by \textbf{discrete hedging} and finite
mesh resolution.

\paragraph{9.3.1 Discrete hedging
schedule}\label{discrete-hedging-schedule}

Let \(\{ \tau_n \}_{n \in \mathbb{N}}\) be the (possibly random) times
at which the protocol updates its spot hedge for perps, with
\(0 = \tau_0 < \tau_1 < \tau_2 < \cdots \leq T\). On each interval
\((\tau_n, \tau_{n+1})\), the protocol maintains a hedge position:

\[
H_{\mathrm{spot}}(t) = H_n, \quad t \in [\tau_n,\tau_{n+1})
\]

while the net perp exposure \(Q_{\mathrm{net}}(t)\) may vary due to user
trades.

Define the \textbf{hedging error} at time \(T\) as:

\[
\mathrm{HE}(T) := \mathrm{PnL}^{\mathrm{perp}}(T) + \mathrm{PnL}^{\mathrm{hedge}}(T)
\]

i.e.~the combined PnL of perps and hedge. In the continuous ideal from
Lemma 8.4, we have \(\mathrm{HE}(T) = 0\); here we bound
\(\mathrm{HE}(T)\) in the discrete case.

For analytic convenience, we work at the level of infinitesimal
dynamics. Let \(P(t) = P(l(t))\) and suppose \(P\) is of finite
variation on \([0,T]\) (this is natural under the trade-driven execution
model of Section 9.1). Then the combined PnL can be written as:

\[
\mathrm{HE}(T)
= \int_0^T Q_{\mathrm{net}}(t)\, dP(t) + \int_0^T H_{\mathrm{spot}}(t)\, dP(t)
\]

Under continuous hedging with
\(H_{\mathrm{spot}}(t) = - Q_{\mathrm{net}}(t)\), we have
\(\mathrm{HE}(T) = 0\). Under discrete hedging, we instead have
piecewise constant \(H_n\).

\paragraph{9.3.2 Hedging error
decomposition}\label{hedging-error-decomposition}

On each interval \([\tau_n, \tau_{n+1})\), we have:

\[
Q_{\mathrm{net}}(t) + H_{\mathrm{spot}}(t) = Q_{\mathrm{net}}(t) + H_n
\]

Introduce the \textbf{exposure mismatch}:

\[
\Delta_n(t) := Q_{\mathrm{net}}(t) + H_n
\]

so that:

\[
\mathrm{HE}(T) = \sum_{n=0}^{N-1} \int_{\tau_n}^{\tau_{n+1}} \Delta_n(t) \, dP(t)
\]

We now bound this sum under mild regularity assumptions.

\paragraph{9.3.3 Lipschitz continuity in
log-space}\label{lipschitz-continuity-in-log-space}

From the log-price mapping \(P(l) = 2^{2 l}\), we have:

\[
\frac{dP}{dl} = 2^{2 l} \cdot 2 \ln(2) = 2 \ln(2) P(l)
\]

so on any bounded log-price interval \([l_{\min}, l_{\max}]\), we obtain
the Lipschitz bound:

\[
|P(l_2) - P(l_1)| \le L_P |l_2 - l_1|, \quad L_P := 2 (\ln 2) \sup_{l \in [l_{\min}, l_{\max}]} P(l)
\]

From the mesh convergence and fixed-point error analysis in Section 6,
we know that:

\begin{itemize}
\tightlist
\item
  the numerical log-price \(\hat l(t)\) deviates from the ideal
  log-price by at most
  \(O(1/\sigma + \varepsilon_{\exp_2} + \varepsilon_{\mathrm{arith}})\),
\item
  and the mesh step \(\delta = \max_k (l_{k+1} - l_k)\) is chosen small.
\end{itemize}

We now aggregate these into a single \textbf{effective log-resolution}
\(\bar\delta\), defined as:

\[
\bar\delta := \delta + C_{\mathrm{num}} \Big( \tfrac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}} \Big)
\]

for a constant \(C_{\mathrm{num}}>0\) depending only on the bounds of
Section 6.6.

\paragraph{9.3.4 Residual risk bound}\label{residual-risk-bound}

Assume:

\begin{itemize}
\tightlist
\item
  the log-price \(l(t)\) remains in a bounded interval
  \([l_{\min}, l_{\max}]\) on \([0,T]\),
\item
  on each hedging interval \([\tau_n, \tau_{n+1})\), the mismatch
  \(\Delta_n(t)\) is uniformly bounded:
\end{itemize}

\[
|\Delta_n(t)| \leq \Delta_{\max}, \quad \forall t\in[\tau_n,\tau_{n+1}), \forall n
\]

\begin{itemize}
\tightlist
\item
  the total variation of \(l(t)\) is bounded by \(V_l\), i.e.
\end{itemize}

\[
\mathrm{TV}_0^T(l) := \sup_{\Pi} \sum_{i} |l(t_{i+1}) - l(t_i)| \leq V_l
\]

where the supremum is over partitions \(\Pi\).

We can now state the main bound.

\textbf{Theorem 9.3 (Residual hedging error under discrete hedging).}

Under the assumptions above, the absolute combined PnL of perps and
hedge satisfies:

\[
|\mathrm{HE}(T)| \le \Delta_{\max} \cdot L_P \cdot \bar\delta \cdot N_{\mathrm{eff}}
\]

where

\begin{itemize}
\tightlist
\item
  \(L_P = 2 (\ln 2) \sup_{l \in [l_{\min}, l_{\max}]} P(l)\) is the
  Lipschitz constant of \(P(l)\),
\item
  \(\bar\delta\) is the effective log-resolution as defined above,
\item
  \(N_{\mathrm{eff}} \leq \mathrm{TV}_0^T(l) / \bar\delta\) is an upper
  bound on the effective number of log-steps.
\end{itemize}

Equivalently, there exists a constant \(C>0\), depending only on \(V_l\)
and the price bounds, such that:

\[
|\mathrm{HE}(T)| \le C \cdot \Delta_{\max} \Big( \delta + \tfrac{1}{\sigma} + \varepsilon_{\exp_2} + \varepsilon_{\log_2} + \varepsilon_{\mathrm{arith}} \Big)
\]

\textbf{\emph{Proof Sketch.}}

On each interval \([\tau_n, \tau_{n+1})\):

\[
\left|\int_{\tau_n}^{\tau_{n+1}} \Delta_n(t)\, dP(t)\right|
\le \sup_{t\in[\tau_n,\tau_{n+1})} |\Delta_n(t)| \cdot \mathrm{TV}_{\tau_n}^{\tau_{n+1}}(P)
\]

where \(\mathrm{TV}_{a}^{b}(P)\) denotes total variation of \(P\) on
\([a,b]\). Using \(|\Delta_n(t)| \leq \Delta_{\max}\) and the Lipschitz
bound for \(P\) in terms of \(l\), we get:

\[
\mathrm{TV}_{\tau_n}^{\tau_{n+1}}(P) \le L_P \cdot \mathrm{TV}_{\tau_n}^{\tau_{n+1}}(l)
\]

From the mesh and numerical discretization, each effective price move on
the mesh is at most \(\bar\delta\) in log-space; thus the total number
of effective steps required to achieve the total variation \(V_l\) is at
most \(N_{\mathrm{eff}} \leq V_l / \bar\delta\). Summing over all
intervals:

\[
|\mathrm{HE}(T)|
\le \sum_n \Delta_{\max} L_P \mathrm{TV}_{\tau_n}^{\tau_{n+1}}(l)
\le \Delta_{\max} L_P \cdot V_l
\le \Delta_{\max} L_P \bar\delta \cdot \frac{V_l}{\bar\delta}
\le \Delta_{\max} L_P \bar\delta N_{\mathrm{eff}}
\]

The final inequality with constant \(C\) is obtained by absorbing
\(L_P V_l\) into \(C\) and substituting the expression for
\(\bar\delta\). \(\square\)

\begin{quote}
\textbf{Intuition:} Theorem 9.3 quantifies ``how much money could the
protocol lose'' by not hedging continuously. The answer depends on (1)
how badly out-of-sync the hedge gets (\(\Delta_{\max}\)), (2) how
granular the price mesh is (\(\bar\delta\)), and (3) how volatile the
market is (\(V_l\)). The bound says: if you hedge frequently enough and
use fine enough price resolution, the accumulated error stays small. In
practice, this means the protocol can tune mesh granularity and hedge
frequency to achieve any desired level of hedging accuracy---at the cost
of more computation.
\end{quote}

Thus, residual hedging risk can be made arbitrarily small by refining:

\begin{itemize}
\tightlist
\item
  the mesh resolution \(\delta\),
\item
  the fixed-point scaling \(\sigma\),
\item
  and the numerical routines \(\exp_2, \log_2\),
\end{itemize}

consistent with the convergence results of Theorem 6.8.

\subsubsection{9.4 Liquidity Stress and Execution Validity Under Hedge
Flow}\label{liquidity-stress-and-execution-validity-under-hedge-flow}

We now show that large hedge trades, routed through the spot engine,
respect the structural invariants of the CLMM + CLOB execution model:
monotone price movement, non-negative reserves, and node-by-node
traversal.

We work under the execution semantics of Section 7 (CLOB at nodes, CLMM
along segments), extended to include hedge-originated market orders.

\textbf{Lemma 9.4 (Monotone execution under large market orders).}

Let a hedge trade of size \(\Delta B\) (in token \(B\), sign included)
be executed as an aggressive order through the CLMM + CLOB engine at
current log-price \(l_*\). Assume:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The total available liquidity (CLOB + CLMM) in the direction of the
  trade is strictly positive on the relevant log-interval
  \([l_{\min}, l_{\max}]\),
\item
  The per-segment CLMM formulas (Section 5.5) and node execution
  ordering (Section 7.1) are observed.
\end{enumerate}

Then the resulting log-price path \(l(\cdot)\) during the execution of
this market order is \textbf{piecewise monotone}, and each mesh node or
CLOB level is crossed at most once.

\textbf{\emph{Proof Sketch.}}

Within a CLMM segment \([l_k, l_{k+1}]\) with liquidity \(L_k > 0\), the
per-segment execution formulas (Section 5.5.1) express token deltas as
monotone functions of \(l\); for a fixed trade direction, \(l\) moves
monotonically until either the segment liquidity is exhausted or the
requested quantity is filled. At mesh nodes, the node execution ordering
processes CLOB orders at that node at a single price level, without
reversing direction. The composition of these monotone moves - segments
followed by nodes followed by segments - yields a piecewise monotone
path. Since each segment or node is crossed only while moving in a
single direction, it cannot be revisited within the execution of the
same market order. \(\square\)

\textbf{Lemma 9.5 (Reserve non-negativity under hedge flow).}

Assume that for all CLMM segments and bands, the initial reserves and
liquidity satisfy the conditions for the standard CLMM formulas (Section
5.4). Let a hedge trade of size \(\Delta B\) execute as above, and
suppose that the available liquidity is sufficient to absorb
\(\Delta B\) without exhausting the pool. Then, at every intermediate
step of execution, pool reserves remain non-negative.

\textbf{\emph{Proof Sketch.}}

On each segment, the CLMM update rules are identical to those of a
standard constant-liquidity region, which preserve non-negative provided
the segment is not over-traded. At CLOB nodes, reserve changes arise
from matching against limit orders whose settlement is accounted for in
the pool and user balances; these updates are merely transfers and
cannot create negative reserves provided sufficient balances exist.
Global sufficiency of liquidity ensures that no segment or aggregate
reserve is over-drawn. \(\square\)

Together, Lemmas 9.4-9.5 show that:

\begin{itemize}
\tightlist
\item
  even under large hedging flow,
\item
  the spot engine executes trades along valid, monotone paths,
\item
  without violating invariant constraints.
\end{itemize}

In particular, hedging cannot ``break'' the spot engine; it behaves
exactly as an ordinary large market order.

\subsubsection{9.5 Liquidation Correctness on the Log-Price
Axis}\label{liquidation-correctness-on-the-log-price-axis}

We now formalize that liquidations in the perp layer (Section 8.5)
correspond to valid aggressive trades in spot and do not introduce
anomalous behavior such as price flicker or inconsistent execution.

\paragraph{9.5.1 Liquidation events as structured
orders}\label{liquidation-events-as-structured-orders}

Fix an account \(m\) and suppose that at time \(t_0\) its equity falls
below maintenance margin, triggering liquidation. We consider a simple
full liquidation policy: the protocol submits a \textbf{liquidation
instruction} to:

\begin{itemize}
\tightlist
\item
  close a fraction \(\theta \in (0,1]\) of the perp position
  \(q_m(t_0)\),
\item
  adjust the global hedge \(H_{\mathrm{spot}}\) accordingly,
\item
  execute the corresponding spot trade via the CLMM + CLOB engine.
\end{itemize}

As in Section 8.5, this can be viewed as an atomic hedged trade of size
\(\Delta q_m = - \theta q_m(t_0)\).

\paragraph{9.5.2 Price path and fairness}\label{price-path-and-fairness}

We define \textbf{fair liquidation price} informally as:

\begin{itemize}
\tightlist
\item
  the (volume-weighted) average spot execution price along the actual
  price path generated by the liquidation trade, given the current
  liquidity.
\end{itemize}

More precisely, if the liquidation trade executes over a log-interval
\([l_{\mathrm{start}}, l_{\mathrm{end}}]\) and consumes both CLOB and
CLMM liquidity according to the execution rules, then the realized
average price is:

\[
\bar P_{\mathrm{liq}} = \frac{ \text{total cost in token } A }{ \text{total quantity in token } B }
\]

We now state correctness.

\textbf{Theorem 9.6 (Liquidation correctness and path regularity).}

Under the execution semantics of Section 7 and Assumptions 9.1, any
liquidation event implemented as an atomic hedged trade (Section 8.5)
satisfies:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The liquidation's spot leg executes along a piecewise monotone
  log-price path \(l(\cdot)\) with at most finitely many node crossings
  (Lemma 9.4),
\item
  Pool reserves remain non-negative throughout execution (Lemma 9.5),
\item
  The realized liquidation price \(\bar P_{\mathrm{liq}}\) is exactly
  the volume-weighted average price over the path, computed from the
  CLMM + CLOB liquidity actually consumed.
\item
  There is no ``flicker'' price: the observable spot price just after
  liquidation, \(P(l(t_0^+))\), is the terminal spot price after the
  final segment of the path; there is no instantaneous reversion.
\end{enumerate}

\textbf{\emph{Proof Sketch.}}

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\tightlist
\item
  and (2) follow directly from Lemmas 9.4-9.5, applied to the
  liquidation's spot leg. (3) is by construction: the liquidation trade
  is executed using the same accounting as any spot market order, so the
  realized price is by definition the ratio of total token \(A\) spent
  to token \(B\) obtained (or vice versa). (4) follows from Assumption
  9.1: \(l(t)\) is updated by the execution operator to the final value
  of the path and remains at this value after the trade; there is no
  independent post-trade re-marking that could change the price
  discontinuously. \(\square\)
\end{enumerate}

Thus, liquidations are economically indistinguishable from large market
orders initiated by an external trader, except that they are triggered
by margin conditions rather than explicit user intent.

\subsubsection{9.6 Fee Allocation and Wealth
Invariants}\label{fee-allocation-and-wealth-invariants}

We now formalize the fee model and show that LP fee sharing is
compatible with wealth conservation and the absence of hidden
directional risk transfer.

\paragraph{9.6.1 Fee functional}\label{fee-functional}

Let \(\mathcal{E}_t\) denote the set of execution events (spot trades,
perp opens/closes, liquidations) at time \(t\). We define a \textbf{fee
functional}:

\[
\mathcal{F}: \mathcal{E}_t \mapsto \mathbb{R}_{\ge 0}^3
\]

which maps each event \(e \in \mathcal{E}_t\) to a triple:

\[
\mathcal{F}(e) = \big( f_{\mathrm{LP}}(e), f_{\mathrm{proto}}(e), f_{\mathrm{ins}}(e) \big)
\]

corresponding to:

\begin{itemize}
\tightlist
\item
  \(f_{\mathrm{LP}}(e)\): fee paid to liquidity providers (spot LPs),
\item
  \(f_{\mathrm{proto}}(e)\): protocol revenue,
\item
  \(f_{\mathrm{ins}}(e)\): contributions to an insurance/reserve fund.
\end{itemize}

We assume non-negativity:

\[
f_{\mathrm{LP}}(e), f_{\mathrm{proto}}(e), f_{\mathrm{ins}}(e) \ge 0
\]

and a simple proportional model, e.g.:

\begin{itemize}
\item
  for a spot trade of notional \(V_e\) in token \(A\):

  \[
  f_{\mathrm{spot}}(e) = \phi_{\mathrm{spot}} V_e, \quad f_{\mathrm{LP}}(e) = \alpha_{\mathrm{spot}} f_{\mathrm{spot}}(e)
  \]

  \[
  f_{\mathrm{proto}}(e) = \beta_{\mathrm{spot}} f_{\mathrm{spot}}(e), \quad f_{\mathrm{ins}}(e) = \gamma_{\mathrm{spot}} f_{\mathrm{spot}}(e)
  \]

  with
  \(\alpha_{\mathrm{spot}} + \beta_{\mathrm{spot}} + \gamma_{\mathrm{spot}} = 1\),
\item
  for a perp open/close of notional \(V_e^{\mathrm{perp}}\):

  \[
  f_{\mathrm{perp}}(e) = \phi_{\mathrm{perp}} V_e^{\mathrm{perp}}, \quad f_{\mathrm{LP}}(e) = \alpha_{\mathrm{perp}} f_{\mathrm{perp}}(e)
  \]

  and similarly for \(f_{\mathrm{proto}}, f_{\mathrm{ins}}\).
\end{itemize}

The exact values of
\(\phi_{\mathrm{spot}}, \phi_{\mathrm{perp}}, \alpha, \beta, \gamma\)
are protocol parameters.

\paragraph{9.6.2 Wealth accounting}\label{wealth-accounting}

Let:

\begin{itemize}
\tightlist
\item
  \(\mathcal{W}_{\mathrm{LP}}(t)\) be the aggregate wealth of all LPs,
\item
  \(\mathcal{W}_{\mathrm{tr}}(t)\) be the aggregate wealth of all
  traders (spot + derivatives),
\item
  \(\mathcal{W}_{\mathrm{proto}}(t)\) be the protocol-held wealth
  (treasury, fee balances),
\item
  \(\mathcal{W}_{\mathrm{ins}}(t)\) be the insurance fund wealth.
\end{itemize}

We define the \textbf{total internal wealth}:

\[
\mathcal{W}_{\mathrm{tot}}(t) = \mathcal{W}_{\mathrm{LP}}(t) + \mathcal{W}_{\mathrm{tr}}(t) + \mathcal{W}_{\mathrm{proto}}(t) + \mathcal{W}_{\mathrm{ins}}(t)
\]

And treat any external deposits/withdrawals or cross-asset conversions
as exogenous.

\textbf{Proposition 9.7 (Internal wealth conservation with fees).}

Ignoring external deposits/withdrawals and valuation changes in
reference numeraire, the total internal wealth satisfies:

\[
\mathcal{W}_{\mathrm{tot}}(T) = \mathcal{W}_{\mathrm{tot}}(0) - \sum_{e \in \mathcal{E}[0,T]} f_{\mathrm{slip}}(e)
\]

where \(f_{\mathrm{slip}}(e) \geq 0\) denotes price impact/slippage
losses incurred by traders relative to a hypothetical frictionless
execution at mid-price. In particular, fee allocation via
\(\mathcal{F}\) is a pure redistribution internal to
\(\mathcal{W}_{\mathrm{tot}}\); it does not create or destroy wealth.

\textbf{\emph{Proof Sketch.}}

Each execution event \(e\) consists of a set of transfers of tokens
\(A, B\) between participants (traders, LPs, protocol, insurance fund).
By construction:

\begin{itemize}
\item
  \(\sum\) of balances over all internal accounts changes only by:

  \begin{itemize}
  \tightlist
  \item
    execution price deviations from mid (slippage / impact),
  \item
    plus any external inflow/outflow.
  \end{itemize}
\end{itemize}

Fees \(f_{\mathrm{LP}}(e), f_{\mathrm{proto}}(e), f_{\mathrm{ins}}(e)\)
are accounted as explicit transfers from traders' wealth to
LPs/protocol/insurance. Hence, they cancel out in the sum
\(\mathcal{W}_{\mathrm{tot}}\). The only net loss relative to an ideal
frictionless setting is due to slippage relative to mid, captured by
\(\sum_e f_{\mathrm{slip}}(e)\). \(\square\)

Combined with Proposition 8.5, this shows:

\begin{itemize}
\tightlist
\item
  LPs can be rewarded with a share of perp fees
  \(\alpha_{\mathrm{perp}} f_{\mathrm{perp}}(e)\),
\item
  without implying that they carry the net directional exposure of the
  derivative layer.
\end{itemize}

Their additional revenue is justified by their role in providing the
shared spot liquidity through which hedges and liquidations are
executed.

\subsubsection{9.7 Computational Complexity of Atomic Hedged Perp
Trades}\label{computational-complexity-of-atomic-hedged-perp-trades}

We now sketch an asymptotic bound on the computational complexity of
atomic hedged perp trades on top of the three-layer log-domain
architecture.

\paragraph{9.7.1 Data structures}\label{data-structures}

Recall:

\begin{itemize}
\item
  Layer 1 defines a global slot lattice indexed by integers
  \(s \in \mathbb{Z}\) with anchors
  \(l_s = l_{\mathrm{ref}} + s \Delta l\),
\item
  each slot stores:

  \begin{itemize}
  \tightlist
  \item
    a list \(\mathcal{I}_s\) of LP bands overlapping the slot (Section
    5.2.3),
  \item
    a list
    \(\mathcal{J}_s^{\mathrm{buy}}, \mathcal{J}_s^{\mathrm{sell}}\) of
    limit orders nearest to that slot (Section 5.2.4),
  \end{itemize}
\item
  Layer 2 constructs a local mesh
  \(\mathcal{M} = \{l_0 < \ldots < l_N\}\) and per-segment liquidity
  \(L_{AMM,k}\) over an interval \(I_{\mathrm{path}}\) (Section 5.3).
\end{itemize}

We assume slot indices, CLOB queues, and LP sets are stored in data
structures supporting:

\begin{itemize}
\tightlist
\item
  \(O(1)\) or \(O(\log S)\) access to the current slot index given
  \(l\),
\item
  \(O(\log | \mathcal{J}_s|)\) access to best price orders in each slot,
\item
  iteration over neighboring slots in amortized constant time.
\end{itemize}

\paragraph{9.7.2 Complexity bound}\label{complexity-bound}

Consider a single atomic hedged perp trade (Definition 8.3) of notional
size \(V\). It consists of:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Internal perp accounting (update \(q_m, P_{\mathrm{entry}, m}, M_m\))
  - \(O(1)\),
\item
  Computation of hedge size \(\Delta H_{\mathrm{spot}}\) - \(O(1)\),
\item
  Execution of an aggressive spot trade of size
  \(\Delta H_{\mathrm{spot}}\) through the CLMM + CLOB engine.
\end{enumerate}

We focus on step (3). Let:

\begin{itemize}
\tightlist
\item
  \(N\) be the number of mesh nodes in the relevant price interval
  \(I_{\mathrm{path}}\),
\item
  \(M\) be the number of LP bands intersecting \(I_{\mathrm{path}}\),
\item
  \(J\) be the number of active limit orders in \(I_{\mathrm{path}}\).
\end{itemize}

Under the monotone execution semantics (Section 7 and Lemma 9.4), the
hedge trade traverses a \textbf{contiguous sub-path} of the mesh nodes,
crossing at most \(K\) segments and nodes, where \(K\) is proportional
to the log-price range induced by \(\Delta H_{\mathrm{spot}}\) and
inversely proportional to local liquidity density. In particular, for a
given slippage tolerance and liquidity profile, we can bound \(K\) by a
protocol parameter \(K_{\max}\).

\textbf{Theorem 9.8 (Amortized complexity of atomic hedged perp
trades).}

Let a single atomic hedged perp trade induce a hedge of size
\(\Delta H_{\mathrm{spot}}\), resulting in traversal of at most \(K\)
mesh segments and nodes. Assume:

\begin{itemize}
\tightlist
\item
  slot index lookup for the starting node is \(O(1)\) or \(O(\log S)\),
\item
  per-node access to best CLOB orders and LP lists is \(O(1)\) amortized
  (e.g.~heap or linked list structures).
\end{itemize}

Then the amortized time complexity of the spot execution step is:

\[
T_{\mathrm{exec}} = O(K + \log S)
\]

and under a protocol-chosen bound \(K \leq K_{\max}\), this is
\(O(\log S)\) per atomic hedged perp trade.

\textbf{\emph{Proof Sketch.}}

Execution proceeds by:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Locating the starting slot or node for \(l_*\): \(O(1)\) or
  \(O(\log S)\),
\item
  At each node:

  \begin{itemize}
  \tightlist
  \item
    matching against at most a constant number of best-price orders
    (orderbook top of book can be maintained in \(O(1)\) amortized),
  \item
    computing the maximum CLMM capacity along the next segment
    (constant-time arithmetic using precomputed \(L_{AMM,k}\)),
  \item
    moving to the next node in the direction of price movement.
  \end{itemize}
\end{enumerate}

Since the path is monotone and traverses at most \(K\) segments/nodes,
and each step is \(O(1)\) amortized, the total cost is
\(O(K) + O(\log S)\). Bounding \(K\) by a protocol parameter
\(K_{\max}\) yields the final claim. \(\square\)

This suggests that, for reasonable bounds on per-trade slippage and path
length, the cost of integrating atomic hedged perp trades into the CLMM
+ CLOB engine is essentially the same asymptotic order as ordinary large
spot market orders, and scales logarithmically with global slot count.

\subsubsection{9.8 Funding-Rate Elimination in Spot-Anchored
Perpetuals}\label{funding-rate-elimination-in-spot-anchored-perpetuals}

We now formalize the intuition that, in the spot-anchored construction
of Section 8, \textbf{funding rates are not needed} to keep perps
aligned with spot, and in fact the \emph{fair} funding rate is
identically zero.

\paragraph{9.8.1 Stylized continuous-time
model}\label{stylized-continuous-time-model}

Work on the filtered probability space
\((\Omega, \mathcal{F}, \{ \mathcal{F}_t \}_{t \ge 0}, \mathbb{P})\) of
Section 9.1. Let

\begin{itemize}
\tightlist
\item
  \(P(t) := P(l(t))\) be the spot price of token \(B\) in units of
  \(A\),
\item
  \(B_t\) be the risk-free bank account in token \(A\), with dynamics:
\end{itemize}

\[
dB_t = r_t B_t \, dt
\]

where \(r_t\) is a (bounded) short-rate process, adapted to
\((\mathcal{F}_t)\).

Assume that under the physical measure \(\mathbb{P}\), the spot follows
an Itô process \autocite{shreve2004stochastic}:

\[
dP_t = \mu_t P_t \, dt + \sigma_t P_t \, dW_t
\]

with adapted drift \(\mu_t\) and volatility \(\sigma_t > 0\), and a
Brownian motion \(W_t\) \autocite{shreve2004stochastic}. These
assumptions are standard in continuous-time asset pricing and serve as a
stylized approximation to the discrete trade-driven dynamics of Section
9.1.

Under \textbf{no-arbitrage} \autocite{delbaen1994general} and mild
technical conditions (e.g.~boundedness, Novikov), there exists an
\textbf{equivalent martingale measure} \(\mathbb{Q}\)
\autocite{shreve2004stochastic,delbaen1994general} such that the
\textbf{discounted spot}:

\[
\tilde P_t := \frac{P_t}{B_t}
\]

is a \(\mathbb{Q}\)-martingale:

\[
d\tilde P_t = \tilde \sigma_t \tilde P_t \, dW_t^{\mathbb{Q}}
\]

for some volatility \(\tilde \sigma_t\) and \(\mathbb{Q}\)-Brownian
motion \(W^{\mathbb{Q}}_t\). This is the standard risk-neutralization
argument \autocite{shreve2004stochastic}.

\paragraph{9.8.2 Perpetual swap under spot
anchoring}\label{perpetual-swap-under-spot-anchoring}

Consider a \textbf{perpetual swap contract} with the following
properties:

\begin{itemize}
\tightlist
\item
  At any time \(t\), a unit long position has instantaneous PnL (in
  token \(A\)):
\end{itemize}

\[
d\Pi_t^{\mathrm{perp}} = dP_t
\]

i.e.~identical to holding one unit of the underlying.

\begin{itemize}
\tightlist
\item
  There is \textbf{no separate funding rate process} \(f_t\).
\item
  The contract has no fixed maturity; positions can be opened and closed
  at any time at the prevailing mark price.
\end{itemize}

Under the \textbf{spot-anchored design}, execution price and mark price
are both equal to spot:

\[
P^{\mathrm{mark}}_t = P_t
\]

Thus, holding a unit of perp has the same cashflow behavior as holding a
unit of spot, in every infinitesimal interval.

We denote by \(F_t\) the \textbf{fair value process} (in token \(A\)) of
one unit of perp at time \(t\).

\paragraph{9.8.3 Risk-neutral pricing of the
perp}\label{risk-neutral-pricing-of-the-perp}

In a frictionless, fully collateralized setting, a long-one-unit perp
position has the same instantaneous payoff as a long-one-unit spot
position, with no additional cashflows. Under the risk-neutral measure
\(\mathbb{Q}\) \autocite{shreve2004stochastic}, any self-financing
portfolio's discounted value must be a martingale
\autocite{delbaen1994general}. Since the perp is fully replicable by
holding one unit of spot (and vice versa), we expect \(F_t = P_t\).

We now formalize this.

\textbf{Theorem 9.9 (Funding-rate elimination under spot anchoring).}

Assume:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  There exists an equivalent martingale measure \(\mathbb{Q}\) under
  which the discounted spot \(\tilde P_t = P_t / B_t\) is a martingale,
\item
  The perp contract has infinitesimal PnL
  \(d\Pi_t^{\mathrm{perp}} = dP_t\) per unit, with no separate funding
  term.
\item
  The perp is tradable at price \(F_t\), and any self-financing strategy
  must have discounted wealth that is a \(\mathbb{Q}\)-martingale.
\end{enumerate}

Then the unique no-arbitrage price of the perpetual swap is:

\[
F_t = P_t, \quad \forall t
\]

and any non-zero funding process is unnecessary in equilibrium.

\textbf{\emph{Proof Sketch.}} Let \(\tilde F_t := F_t / B_t\) be the
discounted perp price. Under risk-neutral pricing, \(\tilde F_t\) must
be a \(\mathbb{Q}\)-martingale for any tradeable asset without exogenous
cashflows. Meanwhile, perp's PnL per unit is exactly \(dP_t\), matching
the underlying.

Consider two portfolios:

\begin{itemize}
\tightlist
\item
  \textbf{Portfolio A}: long one unit of perp,
\item
  \textbf{Portfolio B}: long one unit of spot.
\end{itemize}

Both have the same infinitesimal payoff in units of \(A\), namely
\(dP_t\). Thus, their discounted wealth processes \(\tilde F_t\) and
\(\tilde P_t\) must satisfy the same SDE under \(\mathbb{Q}\). In
particular, the process:

\[
X_t := \tilde F_t - \tilde P_t
\]

satisfies:

\[
dX_t = d\tilde F_t - d\tilde P_t = 0
\]

since any non-zero drift or diffusion in \(X_t\) would contradict the
self-financing martingale property (we could form a zero-cost strategy
long A, short B, and earn free money). Therefore, \(X_t\) is
\(\mathbb{Q}\)-almost surely constant. By no arbitrage at inception, we
must have \(F_0 = P_0\), hence \(X_0 = 0\). Thus, \(X_t \equiv 0\) for
all \(t\), so:

\[
\tilde F_t = \tilde P_t \quad \Rightarrow \quad F_t = P_t, \quad \forall t
\]

Suppose we introduce a non-zero funding process \(f_t\) such that the
perp PnL becomes:

\[
d\Pi_t^{\mathrm{perp}} = dP_t + f_t,dt
\]

If \(f_t \neq 0\) on a set of positive measure, then the discounted perp
wealth deviates from that of spot, allowing a self-financing strategy
long one and short the other to generate a drift in discounted terms,
violating the martingale condition. Thus, in an arbitrage-free
equilibrium consistent with assumptions (1)-(3), we must have
\(f_t \equiv 0\) and \(F_t = P_t\). \(\square\)

\textbf{Interpretation.} In the spot-anchored design, the perp is
\textbf{literally the underlying} from a cashflow perspective. Funding
rates in traditional perps compensate for a deviation between perp price
and spot; here, by construction and by no-arbitrage, that deviation is
zero, so the fair funding rate is identically zero.

\begin{quote}
\textbf{Intuition:} Traditional perpetual swaps
\autocite{bitmex2016perpetual,dydx2023v4,gmx2022technical,perp2021v2}
need funding rates because their prices can drift away from spot---longs
pay shorts (or vice versa) to nudge the perp price back toward the
underlying. Theorem 9.9 shows that in our spot-anchored design, this
drift is mechanically impossible: holding a perp gives you exactly the
same dollar-for-dollar exposure as holding the spot asset. Since there's
no gap to close, there's no need for a funding payment. This eliminates
a major source of complexity and unpredictable costs for traders.
\end{quote}

\subsubsection{9.9 Risk-Neutral Measure and Market Completeness
(Stylized)}\label{risk-neutral-measure-and-market-completeness-stylized}

We now sketch how the unified spot + perp system fits into the standard
framework of risk-neutral pricing and market completeness.

\paragraph{9.9.1 Basic traded assets}\label{basic-traded-assets}

We consider the following traded assets:

\begin{itemize}
\tightlist
\item
  Bank account \(B_t\) (numeraire),
\item
  Spot token \(B\) with price \(P_t\),
\item
  Perp contracts, each equivalent to a linear exposure to \(P_t\)
  (Theorem 9.9).
\end{itemize}

Under the assumptions of Section 9.9, the pair \((B_t, P_t)\) forms a
standard two-asset market with one source of uncertainty (Brownian
motion), hence is \textbf{complete} in the usual Itô sense
\autocite{shreve2004stochastic}: any contingent claim with maturity
\(T\) and payoff \(\Phi(P_T)\) can be replicated by dynamic trading in
spot and bank account.

Perpetual swaps are then \textbf{redundant} assets in the classical
replication sense: they do not introduce new span of payoffs beyond what
spot provides.

\paragraph{9.9.2 Existence of a risk-neutral
measure}\label{existence-of-a-risk-neutral-measure}

We record the standard result we rely on, in this context.

\textbf{Assumption 9.10 (NFLVR and EMM existence).}

We assume the unified spot market generated by the CLMM + CLOB engine
has \textbf{no free lunch with vanishing risk} (NFLVR) in the sense of
Delbaen-Schachermayer \autocite{delbaen1994general} when abstracted into
the continuous-time model of Section 9.9. Then there exists at least one
equivalent martingale measure \(\mathbb{Q}\) under which all discounted
traded asset prices are \(\mathbb{Q}\)-martingales.

Under Assumption 9.10 and the dynamics of Section 9.9, the pair
\((B_t, P_t)\) defines a \textbf{complete} market, and the derivative
layer does not change completeness: it merely exposes a different
interface (margining, leverage, cash-settled PnL) to the same underlying
\(P_t\).

\subsubsection{9.10 Stability Under Adversarial Order
Flow}\label{stability-under-adversarial-order-flow}

We next address robustness: can an adversary manipulate perp valuations
\textbf{without} paying real cost in the spot engine? The answer, by
design, is no.

\paragraph{9.10.1 Adversary model}\label{adversary-model}

Let an adversary \(\mathcal{A}\) be any (possibly adaptive) strategy
that:

\begin{itemize}
\tightlist
\item
  submits arbitrary spot orders (market or limit) to the CLMM + CLOB
  engine,
\item
  submits arbitrary perp instructions (opens, closes, liquidations via
  oracle manipulation attempts, etc.),
\item
  but cannot modify protocol rules or bypass the requirement that all
  hedge trades and liquidations execute via the spot engine.
\end{itemize}

We assume the adversary is capital-constrained: its token holdings must
remain non-negative for all time; otherwise, we could ignore budget
constraints and trivialize market manipulation.

\paragraph{9.10.2 No perp-only manipulation
theorem}\label{no-perp-only-manipulation-theorem}

We now formalize the statement:

\begin{quote}
You cannot move perp PnL or perp marks independently from spot, unless
you actually move spot by consuming liquidity.
\end{quote}

Recall from Theorem 9.9 that fair perp value equals spot: \(F_t = P_t\)
and from Proposition 9.2 that any deviation would yield an arbitrage.

\textbf{Theorem 9.11 (No perp-only manipulation).}

Suppose:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The perp mark price is spot-anchored: \(P^{\mathrm{mark}}_t = P_t\),
\item
  Hedge trades and liquidations are executed as real spot orders through
  the CLMM + CLOB engine,
\item
  The adversary \(\mathcal{A}\) is capital-constrained and cannot bypass
  hedge execution.
\end{enumerate}

Then any change in the adversary's perp PnL must coincide with a
realized change in spot price \(P_t\), generated by actual composition
of liquidity. In particular, \(\mathcal{A}\) cannot alter perp marks or
PnL without incurring real trading costs in the spot engine.

\textbf{\emph{Proof Sketch.}}

At any time \(t\), the perp PnL for the adversary's position is:

\[
\Pi_t^{\mathrm{perp}} = \int_0^t Q_{\mathcal{A}}(u) \, dP_u
\]

where \(Q_{\mathcal{A}}(u)\) is the adversary's net perp exposure. This
expression holds because:

\begin{itemize}
\tightlist
\item
  PnL is defined using mark price \(P^{\mathrm{mark}}_u = P_u\),
\item
  and each incremental PnL unit is exactly
  \(Q_{\mathcal{A}}(u) , dP_u\).
\end{itemize}

The process \(P_u\) itself is defined by the CLMM + CLOB execution
engine (Section 9.1). Any change in \(P_u\) is induced by net order flow
through the spot engine, including possibly the adversary's own hedge
trades and manipulative spot orders.

In particular:

\begin{itemize}
\tightlist
\item
  If the adversary only trades perps and does \textbf{not} cause any net
  spot execution (because hedges are required and executed on users'
  behalf by the protocol in the spot engine), then the spot price path
  \(P_u\) is unaffected by these perp-only actions; hence \(dP_u = 0\)
  for those actions, and they yield no PnL.
\item
  If the adversary submits spot orders (either directly or through
  induced hedges) which move \(P_u\), then all such moves correspond to
  real trades against the CLMM + CLOB liquidity. Any incremental perp
  PnL gained by the adversary is accompanied by a corresponding cost in
  buying high / selling low in the spot engine.
\end{itemize}

Thus, there is no degree of freedom to ``push'' perp marks
independently: by definition and by execution design, the perp state is
a deterministic functional of the spot price path \(P(\cdot)\), and
\(P(\cdot)\) itself is only updated through real trades with the pool or
other traders. A capital-constrained adversary cannot sustain profitable
manipulation loops without eventually paying those trading costs.
\(\square\)

\textbf{Corollary 9.12 (Oracle manipulation resistance).}

If all derivative valuation uses the on-chain spot axis \(l(t)\) and its
induced price \(P_t = P(l(t))\), then there is no separate ``price
oracle'' to manipulate. Any price impact must come from consuming real
on-chain liquidity.

\subsubsection{9.11 Extensions to Futures and Options on the Log
Axis}\label{extensions-to-futures-and-options-on-the-log-axis}

We briefly outline how \textbf{dated futures} and \textbf{options} fit
into the same spot-anchored framework, and why standard replication
pricing applies.

\paragraph{9.11.1 Dated futures}\label{dated-futures}

Fix a maturity \(T > 0\). A \textbf{dated futures contract} on token
\(B\) with maturity \(T\) and unit notional has payoff:

\[
\Phi^{\mathrm{fut}}(P_T) = P_T
\]

Under the same assumptions as Section 9.9 (complete market, risk-neutral
measure \(\mathbb{Q}\)), the no-arbitrage futures price \(F_t^{(T)}\) at
time \(t \leq T\) is given by the standard risk-neutral pricing formula
\autocite{shreve2004stochastic}:

\[
F_t^{(T)} = B_t \, \mathbb{E}^{\mathbb{Q}}\!\left[ \frac{P_T}{B_T} \,\bigg|\, \mathcal{F}_t \right]
\]

If the underlying has no carry and the short rate (r\_t) is
deterministic, the classical result gives:

\[
F_t^{(T)} = P_t \exp\left( \int_t^T r_u \, du \right)
\]

and in a zero-rate or token-\(A\)-numeraire, this reduces to
\(F_t^{(T)} = P_t\).

Implementation-wise, the unified CLMM + CLOB engine provides direct
access to \(P_t = P(l(t))\), so the futures can be:

\begin{itemize}
\tightlist
\item
  margin-settled using the same mark price,
\item
  delta-hedged using the spot engine,
\item
  priced in a risk-neutral sense using the stored log-process.
\end{itemize}

\paragraph{9.11.2 Options}\label{options}

Let a \textbf{European option} with maturity \(T\) have payoff:

\[
\Phi^{\mathrm{opt}}(P_T) = \phi(P_T)
\]

for some measurable function \(\phi:\mathbb{R}_+ \to \mathbb{R}_+\)
(e.g.~\(\max\{P_T - K, 0\}\) for a call, \(\max\{K - P_T, 0\}\) for a
put). The risk-neutral price at time \(t\) is given by
\autocite{black1973pricing,shreve2004stochastic}:

\[
C_t = B_t \, \mathbb{E}^{\mathbb{Q}}\!\left[ \frac{\phi(P_T)}{B_T} \,\bigg|\, \mathcal{F}_t \right]
\]

If we further assume a log-normal diffusion for \(P_t\) under
\(\mathbb{Q}\), e.g.

\[
dP_t = r P_t dt + \sigma P_t dW_t^{\mathbb{Q}}
\]

then we recover the classical Black-Scholes PDE
\autocite{black1973pricing,merton1973theory} in the \textbf{log-price
variable} \(l_t = \frac{1}{2} \log_2 P_t\). To see this, apply Itô's
lemma to \(l_t = \frac{1}{2} \log_2 P_t = \frac{\ln P_t}{2 \ln 2}\):

\[
dl_t = \frac{1}{2 \ln 2} \left( \frac{dP_t}{P_t} - \frac{1}{2} \frac{(dP_t)^2}{P_t^2} \right) = \frac{1}{2 \ln 2} \left( (r - \tfrac{1}{2}\sigma^2) dt + \sigma dW_t^{\mathbb{Q}} \right)
\]

Defining \(\tilde\mu(l,t) := \frac{r - \frac{1}{2}\sigma^2}{2 \ln 2}\)
and \(\tilde\sigma(l,t) := \frac{\sigma}{2 \ln 2}\), the option price
\(u(t, l) = C_t\) satisfies the PDE with generator:

\[
\partial_t u + \frac{1}{2}\tilde\sigma^2(l,t) \partial_{ll} u + \tilde\mu(l,t) \partial_l u - r u = 0
\]

with terminal condition \(u(T,l) = \phi(P(l))\). The key point is that:

\begin{itemize}
\tightlist
\item
  the unified log-axis \(l\),
\item
  the spot engine,
\item
  and the risk-neutral measure \(\mathbb{Q}\),
\end{itemize}

allow us to define standard derivative pricing in the usual way.

\paragraph{9.11.3 Mesh-based
approximation}\label{mesh-based-approximation}

On-chain, any option or futures can be:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Represented as a function of the log-price \(l\),
\item
  Approximated on the Layer-2 mesh via nodal values \(\phi(P(l_k))\),
\item
  Priced by numerical schemes (finite differences, Monte Carlo) on
  \(l\)-space, leveraging the same log-domain representation used for
  CLMM dynamics.
\end{enumerate}

Convergence of these approximations to the continuous model follows from
standard numerical analysis arguments, combined with the convergence
guarantees in Section 5 and the log-price regularity in Section 9.1.

\subsubsection{9.12 Margin Dynamics and Collateral
Invariants}\label{margin-dynamics-and-collateral-invariants}

We now formalize the \textbf{margin process} for perp traders and show
that equity is well-behaved (pathwise solvent under the protocol's
liquidation rule) and convex in the underlying price.

\paragraph{9.12.1 Accounts and positions}\label{accounts-and-positions}

Fix a trader index \(i\). For a single perpetual market on token \(B\)
(quoted in \(A\)), define:

\begin{itemize}
\item
  \(q_i(t) \in \mathbb{R}\): net perp position at time \(t\)

  \begin{itemize}
  \tightlist
  \item
    \(q_i(t) > 0\): net long,
  \item
    \(q_i(t) < 0\): net short.
  \end{itemize}
\item
  \(M_i(t) \geq 0\): margin balance in token \(A\) (collateral) at time
  \(t\),
\item
  \(P(t) = P(l(t))\): spot/mark price as in Section 7-8 (unified
  log-price axis).
\item
  \(E_i(t)\): equity (or net account value) of trader \(i\) in token
  \(A\), defined by:
\end{itemize}

\[
E_i(t) = M_i(t) + q_i(t) \cdot P(t)
\]

We ignore cross-collateralization across markets here; it can be added
by summing over markets with appropriate haircuts, but the single-market
case captures the essential structure.

\paragraph{9.12.2 Margin requirements}\label{margin-requirements}

Let:

\begin{itemize}
\tightlist
\item
  \(\Gamma_{\mathrm{init}}(\cdot)\): initial margin requirement
  function,
\item
  \(\Gamma_{\mathrm{maint}}(\cdot)\): maintenance margin requirement
  function,
\end{itemize}

We model these as:

\[
\Gamma^{\mathrm{init}}(P_t, q_i(t)) = \alpha_{\mathrm{init}} \, |q_i(t)| P_t
\]

\[
\Gamma^{\mathrm{maint}}(P_t, q_i(t)) = \alpha_{\mathrm{maint}} \, |q_i(t)| P_t
\]

with constants
\(0 < \alpha_{\mathrm{maint}} < \alpha_{\mathrm{init}} < 1\). More
general state-dependent \(\alpha(\cdot)\) (e.g.~volatility-based) are
possible but not necessary for the formal properties below.

We say that account \(i\) is:

\begin{itemize}
\item
  \textbf{initially admissible} at opening time \(t_0\) if:

  \[
  E_i(t_0) \ge \Gamma^{\mathrm{init}}(P_{t_0}, q_i(t_0))
  \]
\item
  \textbf{maintained} at time \(t\) if:

  \[
  E_i(t) \ge \Gamma^{\mathrm{maint}}(P_t, q_i(t))
  \]
\end{itemize}

\paragraph{9.12.3 Equity dynamics}\label{equity-dynamics}

Under the spot-anchored design, per-unit perp PnL is \(dP_t\) (Theorem
9.9). If the trader's net position is \(q_i(t)\), the incremental change
in equity satisfies:

\[
dE_i(t) = dM_i(t) + q_i(t) \, dP_t + P_t \, dq_i(t)
\]

\begin{itemize}
\tightlist
\item
  Changes in \textbf{margin} \(dM_i(t)\) come from deposits/withdrawals
  and realized PnL (settlements).
\item
  Changes in \textbf{position} \(dq_i(t)\) come from opening/closing
  perps (executed at price \(P_t\) with fees).
\item
  The term \(q_i(t) \, dP_t\) is unrealized PnL.
\end{itemize}

Assuming no external deposits/withdrawals in \([t, t+dt]\) and no
immediate realization of PnL, we have:

\[
dM_i(t) = 0, \quad dq_i(t) = 0 \quad \Rightarrow \quad dE_i(t) = q_i(t) \, dP_t
\]

Thus for fixed \(q_i\) over a time window:

\[
E_i(t) = E_i(t_0) + q_i \cdot (P_t - P_{t_0})
\]

\textbf{Lemma 9.13 (Equity linearity).}

Fix \(q_i\) constant on \([t_0, t_1]\). Then \(E_i(t)\) is an affine
(linear + constant) function of \(P_t\) on that interval:

\[
E_i(t) = M_i(t_0) + q_i P_t, \quad t\in [t_0,t_1]
\]

In particular, for a long \(q_i > 0\), equity is strictly increasing in
\(P_t\); for a short \(q_i < 0\), equity is strictly decreasing in
\(P_t\).

\textbf{\emph{Proof Sketch.}}

Immediate from the definition \(E_i = M_i + q_i P_t\) and constant
\(q_i, M_i\) over the interval. \(\square\)

\paragraph{9.12.4 Liquidation rule and
invariants}\label{liquidation-rule-and-invariants}

We formalize a simple liquidation rule:

\begin{itemize}
\item
  If at some time \(\tau\):

  \[
  E_i(\tau) < \Gamma^{\mathrm{maint}}(P_\tau, q_i(\tau))
  \]

  then the account is flagged for liquidation.
\item
  The protocol issues a \textbf{liquidation order} of size \(q_i(\tau)\)
  (full close) or some partial amount \(q^{\mathrm{liq}}_i(\tau)\) that
  restores margin above maintenance.
\item
  The liquidation order is hedged through the spot engine (CLMM + CLOB)
  as described in Section 9, with final executed average price
  \(\overline{P}^{\mathrm{liq}}_i(\tau)\) and fees.
\end{itemize}

Let \(\varphi_i\) denote the (deterministic, protocol-specified)
function that maps the pre-liquidation state
\((P_\tau, q_i(\tau), M_i(\tau))\) and execution price
\(\overline{P}^{\mathrm{liq}}_i(\tau)\) into post-liquidation state
\((q_i(\tau^+), M_i(\tau^+))\). For a full liquidation we have
\(q_i(\tau^+) = 0\) and:

\[
M_i(\tau^+) = E_i(\tau) + \Delta^{\mathrm{slip+fee}}_i(\tau)
\]

where \(\Delta^{\mathrm{slip+fee}}_i(\tau)\) is the net cost of slippage
and fees for hedging the position via spot.

We model:

\[
\Delta^{\mathrm{slip+fee}}_i(\tau) \ge -C_{\max} |q_i(\tau)| P_\tau
\]

for some protocol-chosen constant \(C_{\max} \ge 0\) capturing
worst-case adverse execution (bounded slippage + fees due to mesh
resolution, fixed-point error, and limited depth). The existence of such
a bound follows from the convergence and error control results in
Section 5 and finite-capacity structure of the CLMM segments (Section
5.5).

\textbf{Proposition 9.14 (Pathwise non-negative post-liquidation equity,
absent tail loss).}

Assume:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  At trade inception,
  \(E_i(t_0) \ge \Gamma^{\mathrm{init}}(P_{t_0}, q_i(t_0))\).
\item
  The account is only liquidated when
  \(E_i(\tau) < \Gamma^{\mathrm{maint}}(P_\tau, q_i(\tau))\).
\item
  The slippage+fee term satisfies
  \(\Delta^{\mathrm{slip+fee}}_i(\tau) \ge -C_{\max} |q_i(\tau)| P_\tau\).
\item
  Maintenance margin satisfies \(\alpha_{\mathrm{maint}} > C_{\max}\).
\end{enumerate}

Then, after full liquidation at time \(\tau\):

\[
E_i(\tau^+) = M_i(\tau^+) \ge 0
\]

\textbf{\emph{Proof Sketch.}}

At liquidation time \(\tau\), pre-liquidation equity is:

\[
E_i(\tau) = M_i(\tau) + q_i(\tau)P_\tau
\]

After closing position fully:

\[
E_i(\tau^+) = M_i(\tau^+) = E_i(\tau) + \Delta^{\mathrm{slip+fee}}_i(\tau)
\]

By assumption (3):

\[
E_i(\tau^+) \ge E_i(\tau) - C_{\max}|q_i(\tau)|P_\tau
\]

At the moment of liquidation, we have
\(E_i(\tau) < \Gamma^{\mathrm{maint}}(P_\tau,q_i(\tau)) = \alpha_{\mathrm{maint}} |q_i(\tau)|P_\tau\),
but by definition of the trigger the account has not defaulted yet, so
we still assume \(E_i(\tau) \ge 0\). We can bound:

\[
E_i(\tau^+) \ge - C_{\max}|q_i(\tau)|P_\tau
\]

To guarantee \(E_i(\tau^+) \ge 0\), we impose a \textbf{solvency margin
condition}:

\[
E_i(\tau) \ge C_{\max}|q_i(\tau)|P_\tau
\]

at the liquidation trigger. This is equivalent to:

\[
\Gamma^{\mathrm{maint}}(P_\tau,q_i(\tau)) = \alpha_{\mathrm{maint}}|q_i(\tau)|P_\tau \ge C_{\max}|q_i(\tau)|P_\tau
\quad \Rightarrow \quad
\alpha_{\mathrm{maint}} \ge C_{\max}
\]

Thus if \(\alpha_{\mathrm{maint}} > C_{\max}\), then even in the
worst-case slippage+fee realization, the account's equity after
liquidation is non-negative. \(\square\)

\textbf{Interpretation.} As long as maintenance margin is chosen
strictly above worst-case per-unit liquidation cost, the protocol
enforces \textbf{pathwise solvency}: in the absence of systemic tail
events beyond modeled \(C_{\max}\), individual accounts cannot go
negative; i.e., no ``socialized loss'' arises from normal liquidations.

\begin{quote}
\textbf{Intuition:} Think of the maintenance margin as a ``safety
buffer'' that the protocol requires you to keep. Proposition 9.14 says:
if this buffer is bigger than the worst-case cost of closing your
position (slippage + fees), then even if you get liquidated, there's
always enough collateral left to cover the close. No debt gets passed to
other users. The key insight is that by setting margin requirements high
enough relative to execution costs, the protocol guarantees that
liquidations are always ``clean''---they never leave a hole in the
system.
\end{quote}

The remaining residual risk (failures of the \(C_{\max}\) bound, oracle
halts, extreme gaps) is handled by the insurance fund in the next
subsection.

\subsubsection{9.13 Insurance Fund, Bankruptcy Model, and Tail
Bounds}\label{insurance-fund-bankruptcy-model-and-tail-bounds}

We now formalize the insurance fund and show how it absorbs \textbf{tail
liquidation shortfalls} that exceed the worst-case execution bound
modeled in Section 9.12.

\paragraph{9.13.1 Liquidation deficit and
bankruptcy}\label{liquidation-deficit-and-bankruptcy}

Define the \textbf{liquidation deficit} for trader \(i\) at time
\(\tau\) as:

\[
\Delta_i^{\mathrm{def}}(\tau) := \max{0, -E_i(\tau^+)}
\]

Under the idealized assumptions of Proposition 9.14 and
\(\alpha_{\mathrm{maint}} > C_{\max}\), we have
\(\Delta_i^{\mathrm{def}}(\tau) = 0\). In reality, extreme conditions
may violate the bound implicitly encoded in \(C_{\max}\), leading to
\(E_i(\tau^+) < 0\). In such cases:

\begin{itemize}
\tightlist
\item
  The protocol \textbf{declares the account bankrupt},
\item
  The negative equity is covered by the \textbf{insurance fund}.
\end{itemize}

Let \(I(t) \ge 0\) denote the insurance fund balance (in token \(A\)) at
time \(t\). Let \(\tau\) be a liquidation time. We update:

\[
I(\tau^+) = I(\tau) - \sum_{i \in \mathcal{B}_\tau} \Delta_i^{\mathrm{def}}(\tau)
\]

where \(\mathcal{B}_\tau\) is the set of accounts that incur deficits at
\(\tau\). We require:

\[
I(\tau^+) \ge 0
\]

for all \(\tau\) in normal operation; if not, the protocol enters an
\textbf{emergency mode} (e.g.~halt perps, haircuts profits, or uses
backstop liquidity).

\paragraph{9.13.2 Aggregate bound from execution
error}\label{aggregate-bound-from-execution-error}

From Section 6 and 9, total liquidation error can be decomposed into:

\begin{itemize}
\tightlist
\item
  mesh discretization error,
\item
  fixed-point error,
\item
  exp/log approximation error,
\item
  and finite liquidity-induced slippage.
\end{itemize}

We can package these contributions into a per-unit error bound
\(\varepsilon_{\mathrm{liq}}\), such that for a trader with position
\(q_i\):

\[
E_i(\tau^+) \ge - \varepsilon_{\mathrm{liq}} |q_i(\tau)| P_\tau
\]

Thus:

\[
\Delta_i^{\mathrm{def}}(\tau) \le \varepsilon_{\mathrm{liq}} |q_i(\tau)| P_\tau
\]

Summing across all liquidated accounts in an event \(\tau\):

\[
\Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau) := \sum_{i \in \mathcal{B}_\tau} \Delta_i^{\mathrm{def}}(\tau)
\le \varepsilon_{\mathrm{liq}} \sum_{i \in \mathcal{B}_\tau} |q_i(\tau)| P_\tau
\]

Define the \textbf{liquidated open interest} at \(\tau\):

\[
\mathrm{LOI}(\tau) := \sum_{i \in \mathcal{B}_\tau} |q_i(\tau)|
\]

then:

\[
\Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau) \le \varepsilon_{\mathrm{liq}} \, \mathrm{LOI}(\tau) \, P_\tau
\]

\paragraph{9.13.3 Insurance fund solvency
condition}\label{insurance-fund-solvency-condition}

We can now specify a sufficient condition for insurance-fund solvency.

\textbf{Theorem 9.15 (Insurance fund solvency under bounded liquidation
error).}

Suppose that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  At time \(0\), the insurance fund has level \(I(0)\).
\item
  For all liquidation events \(\tau \in [0,T]\), the aggregate deficit
  satisfies:

  \[
  \Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau) \le \varepsilon_{\mathrm{liq}} \, \mathrm{LOI}(\tau) \, P_\tau
  \]

  where \(\varepsilon_{\mathrm{liq}}\) is a global bound determined by
  mesh resolution and numerical precision.
\item
  The total liquidated open interest over the horizon is bounded by:

  \[
  \sum_{\tau \le T} \mathrm{LOI}(\tau) \le \mathrm{LOI}_{\max}
  \]

  for some protocol parameter \(\mathrm{LOI}_{\max}\).
\end{enumerate}

If the initial insurance fund satisfies:

\[
I(0) \ge \varepsilon_{\mathrm{liq}} \, \mathrm{LOI}_{\max} \, P_{\max}
\]

where \(P_{\max}\) is an upper bound on spot over \([0,T]\), then:

\[
I(t) \ge 0 \quad \forall t \in [0,T]
\]

\textbf{\emph{Proof Sketch.}}

Each liquidation event \(\tau\) reduces the fund by at most
\(\Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau)\), which is bounded by
\(\varepsilon_{\mathrm{liq}} \, \mathrm{LOI}(\tau) \, P_\tau \leq \varepsilon_{\mathrm{liq}} \, \mathrm{LOI}(\tau) \, P_{\max}\).
Thus the cumulative reduction over \([0,T]\) is at most:

\[
\sum_{\tau \le T} \Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau)
\le \varepsilon_{\mathrm{liq}} P_{\max} \sum_{\tau \le T} \mathrm{LOI}(\tau)
\le \varepsilon_{\mathrm{liq}} P_{\max} \, \mathrm{LOI}_{\max}
\]

If \(I(0)\) is at least this amount, then for all \(t \in [0,T]\), we
have:

\[
I(t) \ge I(0) - \sum_{\tau \le t} \Delta^{\mathrm{def}}_{\mathrm{tot}}(\tau) \ge 0
\]

\(\square\)

\textbf{Interpretation.}

The bound \(\varepsilon_{\mathrm{liq}}\) is directly linked to:

\begin{itemize}
\tightlist
\item
  mesh diameter \(\delta\),
\item
  fixed-point scaling \(\sigma\),
\item
  numerical errors
  \(\varepsilon_{\exp_2}, \varepsilon_{\log_2}, \varepsilon_{\mathrm{arith}}\),
\item
  and liquidity depth along the log-axis.
\end{itemize}

By tuning these parameters and bounding total liquidated OI, the
protocol can \emph{provably} size the insurance fund so that tail
liquidation deficits do not bankrupt the system over a target horizon.

\begin{quote}
\textbf{Intuition:} Theorem 9.15 gives the protocol a concrete
``insurance budget'' formula. It says: if you know (1) how big the
worst-case execution error is (\(\varepsilon_{\mathrm{liq}}\)), (2) the
maximum price you might see (\(P_{\max}\)), and (3) the total amount of
positions that could get liquidated in a bad scenario
(\(\mathrm{LOI}_{\max}\)), then multiply them together---that's how much
money you need in the insurance fund to stay solvent. This transforms
risk management from guesswork into engineering: pick your target safety
horizon, estimate the parameters, fund the insurance accordingly.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{                     INSURANCE FUND DYNAMICS}
\NormalTok{    ════════════════════════════════════════════════════════}

\NormalTok{                         ┌─────────────┐}
\NormalTok{         INFLOWS         │             │         OUTFLOWS}
\NormalTok{                         │  Insurance  │}
\NormalTok{    ┌──────────────┐     │    Fund     │     ┌──────────────┐}
\NormalTok{    │ Trading Fees │────►│    I(t)     │────►│  Liquidation │}
\NormalTok{    │   (portion)  │     │             │     │   Deficits   │}
\NormalTok{    └──────────────┘     │             │     │  Δ\^{}def(τ)    │}
\NormalTok{                         │             │     └──────────────┘}
\NormalTok{    ┌──────────────┐     │             │}
\NormalTok{    │ Liquidation  │────►│             │}
\NormalTok{    │   Penalties  │     │             │}
\NormalTok{    └──────────────┘     └──────────────┘}

\NormalTok{    ════════════════════════════════════════════════════════}

\NormalTok{    FUND BALANCE EVOLUTION:}
\NormalTok{    ┌─────────────────────────────────────────────────────────┐}
\NormalTok{    │                                                         │}
\NormalTok{    │  I(t) = I(0) + Σ inflows {-} Σ Δ\^{}def(τ)                   │}
\NormalTok{    │                τ≤t         τ≤t                          │}
\NormalTok{    │                                                         │}
\NormalTok{    └─────────────────────────────────────────────────────────┘}

\NormalTok{    SOLVENCY CONDITION (Theorem 9.15):}
\NormalTok{    ┌─────────────────────────────────────────────────────────┐}
\NormalTok{    │                                                         │}
\NormalTok{    │  I(0) ≥ ε\_liq · P\_max · LOI\_max                         │}
\NormalTok{    │         ▲        ▲         ▲                            │}
\NormalTok{    │         │        │         └─ Max liquidated open       │}
\NormalTok{    │         │        │            interest over horizon     │}
\NormalTok{    │         │        └─ Maximum price in period             │}
\NormalTok{    │         └─ Worst{-}case execution error                   │}
\NormalTok{    │                                                         │}
\NormalTok{    │  ═══════════════════════════════════════════════════    │}
\NormalTok{    │  ⟹  I(t) ≥ 0  for all t ∈ [0, T]  (fund stays solvent) │}
\NormalTok{    │                                                         │}
\NormalTok{    └─────────────────────────────────────────────────────────┘}

\NormalTok{    PARAMETER DEPENDENCIES:}
\NormalTok{    ┌───────────────┐}
\NormalTok{    │    ε\_liq      │◄─── Mesh diameter δ}
\NormalTok{    │  (execution   │◄─── Fixed{-}point scaling σ}
\NormalTok{    │    error)     │◄─── Numerical errors ε\_exp2, ε\_log2}
\NormalTok{    │               │◄─── Liquidity depth along log{-}axis}
\NormalTok{    └───────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 13: Insurance fund dynamics and solvency condition. The
fund receives inflows from trading fees and liquidation penalties, and
pays out deficits when liquidations execute at prices worse than equity.
Theorem 9.15 provides a closed-form lower bound for initial
capitalization to guarantee solvency over horizon \([0,T]\).}

\subsubsection{9.14 Compositionality and Determinism of Concurrent
Liquidations}\label{compositionality-and-determinism-of-concurrent-liquidations}

We now show that \textbf{multiple liquidations / hedge flows in the same
interval} can be treated compositionally, and that the unified log-axis
execution yields a deterministic final state independent (in a precise
sense) of the internal ordering of these hedges.

\paragraph{9.14.1 Aggregate hedge flow}\label{aggregate-hedge-flow}

Consider a collection of liquidation events within a short time window
\([t, t+\Delta]\):

\[
\mathcal{L} = \{ (i, q_i^{\mathrm{liq}}) \}_{i \in \mathcal{I}}
\]

where each \(q_i^{\mathrm{liq}}\) is the perp position to be closed
(sign indicating long vs short). The protocol translates each
liquidation into a \textbf{hedge order} in the spot engine:

\[
\Delta B^{\mathrm{hedge}}_i = -q_i^{\mathrm{liq}}, \quad \Delta A^{\mathrm{hedge}}_i = -q_i^{\mathrm{liq}} P_{\mathrm{exec},i}
\]

where \(P_{\mathrm{exec},i}\) is the effective execution price for the
hedge. On the log-axis, this corresponds to a signed quantity to be
traded along the path in \(l\)-space.

Let:

\[
q^{\mathrm{agg}} := \sum_{i \in \mathcal{I}} q_i^{\mathrm{liq}}
\]

be the \textbf{net hedge size} (in units of \(B\)) of all liquidations
in this window. For definiteness, suppose \(q^{\mathrm{agg}} < 0\): net
selling of \(B\) into the CLMM + CLOB engine (downward price pressure).
The case \(q^{\mathrm{agg}} > 0\) is symmetric.

\paragraph{9.14.2 Path-independence in the
CLMM}\label{path-independence-in-the-clmm}

Recall from Section 5.4 that for AMM execution along a log-path from
\(l_a\) to \(l_b\), the pool deltas are:

\[
\Delta A(l_a \to l_b; \lambda) = -(\ln 2) \int_{l_a}^{l_b} \lambda(l) 2^{-l} dl
\]

\[
\Delta B(l_a \to l_b; \lambda) = (\ln 2) \int_{l_a}^{l_b} \lambda(l) 2^{l} dl
\]

If the total trade size in token \(B\) is \(\Delta B\), the final
log-price \(l_b\) is determined by solving:

\[
\Delta B = (\ln 2) \int_{l_a}^{l_b} \lambda(l) 2^{l} dl
\]

This integral is \textbf{additive} across multiple trades: if we apply
trades with sizes \(\Delta B_1, \Delta B_2\) sequentially in the same
direction, the total move is determined by:

\[
\Delta B_1 + \Delta B_2 = (\ln 2) \int_{l_a}^{l_c} \lambda(l) 2^{l} dl
\]

for some \(l_c\). This does not depend on the internal ordering of
\(\Delta B_1, \Delta B_2\); only on their sum. This is the standard
path-independence of integrating a deterministic function
\(\lambda(l) 2^{l}\) along a one-dimensional axis.

\textbf{Lemma 9.16 (CLMM aggregate execution equivalence).}

Let \(l_0\) be the starting log-price, and let \({\Delta B_j}_{j=1}^n\)
be a finite set of trade sizes in the same direction (all buy or all
sell). Let \(l^{(1)}_n\) be the final log-price after executing them
sequentially in any order, and let \(l^{(2)}\) be the final log-price
after executing a single aggregated trade of size
\(\Delta B^{\mathrm{agg}} = \sum_j \Delta B_j\). Then:

\[
l^{(1)}_n = l^{(2)}
\]

\textbf{\emph{Proof Sketch.}}

The CLMM dynamics on the log-axis are described by a first-order ODE in
price vs.~cumulative \(\Delta B\), with right-hand side determined by
\(\lambda(l)\). For trades in the same direction, the solution mapping
from cumulative size to final log-price is monotone and uniquely
determined by integrating \(\lambda(l) 2^l\). The order of partitioning
a fixed total \(\Delta B^{\mathrm{agg}}\) does not change the integral's
endpoint; hence the final \(l\) is independent of the split/order.
\(\square\)

\paragraph{9.14.3 CLOB node aggregation}\label{clob-node-aggregation}

At CLOB nodes, we must respect price-time priority. However, for a given
set of hedge orders \(\mathcal{L}\) executed in the same batch, the
effective CLOB consumption is fully determined by:

\begin{itemize}
\tightlist
\item
  the total net size \(q^{\mathrm{agg}}\),
\item
  the existing resting orders and their fixed priorities.
\end{itemize}

Given that the CLOB book at node \(l_k\) is specified as a sorted list
(by price, then time), the \textbf{total amount filled} at each node for
the aggregate size \(q^{\mathrm{agg}}\) is independent of the internal
ordering of the hedging ``sub-orders'', as long as all hedges are
treated as arriving at the same block-time and are matched as a single
meta-order.

This can be enforced at the protocol level by:

\begin{itemize}
\tightlist
\item
  aggregating all liquidation hedges in a block into one batch per
  direction per market,
\item
  applying matching deterministically to that aggregated size.
\end{itemize}

\paragraph{9.14.4 Determinism theorem}\label{determinism-theorem}

We combine AMM path-independence and CLOB aggregation.

\textbf{Theorem 9.17 (Deterministic final state for concurrent
liquidations).}

Let \(\mathcal{L}\) be a finite set of liquidation orders in a block,
inducing hedge sizes \(\{q_i^{\mathrm{liq}}\}_{i \in \mathcal{I}}\) in
the same direction (net selling or net buying). Suppose the protocol:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aggregates all these hedges into a single net size
  \(q^{\mathrm{agg}} = \sum_{i} q_i^{\mathrm{liq}}\),
\item
  Executes this net hedge via the unified CLMM + CLOB engine, respecting
  CLOB price-time priority for the pre-existing resting book.
\end{enumerate}

Then:

\begin{itemize}
\tightlist
\item
  The final log-price \(l_{\mathrm{final}}\),
\item
  The final CLMM reserves \((A_{\mathrm{pool}}, B_{\mathrm{pool}})\),
\item
  The set of fully/partially filled resting CLOB orders,
\end{itemize}

are uniquely determined by:

\begin{itemize}
\tightlist
\item
  the initial state (CLMM liquidity \(\lambda(l)\), resting CLOB book),
\item
  and the net hedge size \(q^{\mathrm{agg}}\),
\end{itemize}

and are \textbf{independent} of internal ordering or identity of the
individual liquidations in \(\mathcal{L}\).

\textbf{\emph{Proof Sketch.}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{CLOB part.}

  Aggregating hedges into a single meta-order reduces the problem to
  matching a single order of size \(q^{\mathrm{agg}}\) against a fixed,
  static CLOB book. Price-time priority and deterministic tie-breaking
  guarantee uniqueness of the resulting matched set and remaining book.
\item
  \textbf{CLMM part.}

  Any portion of the net hedge not filled on the CLOB side is executed
  via the CLMM along the log-axis. By Lemma 9.16, the final log-price
  and pool reserves depend only on the total AMM \(\Delta B\), not on
  how it is partitioned among sub-orders.
\item
  \textbf{Composition.}

  Combined CLOB+CLMM flow is a composition of two deterministic maps
  applied to the aggregate size. Since the protocol explicitly
  aggregates hedges before execution and the initial state is fixed, the
  final state is uniquely determined.
\end{enumerate}

Identity of which liquidator is assigned which slice of the aggregate
execution and what average price each gets can then be calculated as a
pure accounting step, without affecting the global state. \(\square\)

\textbf{Interpretation.}

From the perspective of the \emph{global state} (price, pool reserves,
order book), concurrent liquidations in a block are equivalent to a
single, deterministic net hedge. This makes the perp layer
\textbf{serializable}, which is important for both implementation and
formal verification.

\begin{quote}
\textbf{Intuition:} Imagine 100 traders all getting liquidated in the
same block. You might worry that the order in which these liquidations
happen affects the final price---maybe the first liquidations get better
prices, and later ones get worse. Theorem 9.17 says: it doesn't matter.
Because the AMM's response to trades depends only on the total volume
(not who sent it or in what order), you can mentally ``combine'' all 100
liquidations into one big trade. The final price and reserves are the
same regardless of sequencing. This is crucial for blockchain systems
where transaction ordering within a block can be unpredictable.
\end{quote}

\subsubsection{9.15 Dynamic Stability and Leverage
Constraints}\label{dynamic-stability-and-leverage-constraints}

We address \textbf{system-level stability}: ensuring that leverage in
the perp layer does not induce unbounded feedback loops into the spot
engine.

\paragraph{9.15.1 Effective leverage and
depth}\label{effective-leverage-and-depth}

Let:

\begin{itemize}
\tightlist
\item
  \(D^{\downarrow}(l)\): aggregate \emph{downward} spot depth at
  log-price \(l\), i.e.~maximum amount of token \(B\) that can be sold
  (net) starting from \(l\) before price drops by a given log-interval
  \(\Delta l\). Analogously, \(D^{\uparrow}(l)\) for upward moves.
\item
  For simplicity, restrict attention to downward risk; upward is
  symmetric.
\end{itemize}

We define \textbf{local effective depth} at \(l\):

\[
\mathcal{L}^{\downarrow}(l; \Delta l) := \int_l^{l - \Delta l} \lambda(u) (\ln 2)2^{u}du + \text{CLOB depth in }[l-\Delta l,l]
\]

measured in units of token \(B\). This is the maximum net sell quantity
that can be absorbed while moving price from \(l\) to \(l - \Delta l\).

Let \(\{q_i\}\) be the open perp positions at log-price \(l\), and
define the \textbf{notional} of position \(i\):

\[
N_i(l) := |q_i| P(l)
\]

Define effective \textbf{leverage} of account \(i\):

\[
\ell_i(l) := \frac{N_i(l)}{E_i(l)} = \frac{|q_i| P(l)}{E_i(l)}
\]

Let \(\mathfrak{L}(l)\) be an aggregate leverage measure, e.g.:

\[
\mathfrak{L}(l) := \sum_i \ell_i(l) \wedge \ell_{\max}
\]

with some hard cap \(\ell_{\max}\).

\paragraph{9.15.2 Stability condition}\label{stability-condition}

Intuitively, a downward price move triggers liquidations; liquidations
execute hedges; hedges sell more into spot, causing further downward
pressure. To avoid runaway spirals, we need to keep \textbf{total forced
sell volume} from any shock bounded by the absorbing capacity of the
depth profile.

We formalize a simplified, conservative condition.

Let \(\Delta l_{\max}^{\mathrm{liq}}\) be a protocol-targeted
\textbf{maximum allowed log-price drop} due to liquidation cascades from
a bounded shock (e.g., a 10\% move). Assume that:

\begin{itemize}
\tightlist
\item
  Any liquidation event at \(l\) closes at most a fraction \(\beta\) of
  total notional (due to partial liquidation rules or
  collateralization),
\item
  The worst-case liquidation volume (in token \(B\)) generated by a
  one-sided move of size \(\Delta l_{\max}^{\mathrm{liq}}\) is bounded
  by:
\end{itemize}

\[
V^{\mathrm{liq}}_{\downarrow}(l; \Delta l_{\max}^{\mathrm{liq}}) \le \beta \sum_i |q_i|
\]

The system remains dynamically stable if this worst-case liquidation
volume does not exceed the total absorbing depth over the same interval:

\[
V^{\mathrm{liq}}_{\downarrow}(l; \Delta l_{\max}^{\mathrm{liq}}) \le \mathcal{L}^{\downarrow}(l; \Delta l_{\max}^{\mathrm{liq}})
\]

This yields a \textbf{leverage constraint}:

\textbf{Definition 9.18 (Stability-compatible leverage).}

We say that the system is \textbf{stability-compatible} at log-price
\(l\) if for some chosen \(\Delta l_{\max}^{\mathrm{liq}} > 0\):

\[
\beta \sum_i |q_i| \le \mathcal{L}^{\downarrow}(l; \Delta l_{\max}^{\mathrm{liq}})
\]

Equivalently, in notional terms:

\[
\beta \sum_i N_i(l) \le P(l) \cdot \mathcal{L}^{\downarrow}(l; \Delta l_{\max}^{\mathrm{liq}})
\]

This inequality can be enforced via per-account leverage caps or dynamic
margin multipliers as a function of observable depth.

\paragraph{9.15.3 Stability theorem (no unbounded liquidation
cascades)}\label{stability-theorem-no-unbounded-liquidation-cascades}

We now state a stylized result: if the above inequality holds at each
step, a liquidation cascade cannot produce an unbounded sequence of
price jumps.

\textbf{Theorem 9.19 (Bounded liquidation cascades under leverage
constraint).}

Suppose:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  At log-price \(l_0\), the market is stability-compatible in the sense
  of Definition 9.18 with some \(\Delta l_{\max}^{\mathrm{liq}}\).
\item
  A downward external shock moves log-price from \(l_0\) to
  \(l_0 - \delta l\), with
  \(0 < \delta l \le \Delta l_{\max}^{\mathrm{liq}}\).
\item
  All liquidations triggered by this move are executed via hedges in the
  spot engine, generating additional net sell volume
  \(V^{\mathrm{liq}}_{\downarrow}\) in token \(B\) which satisfies:
\end{enumerate}

\[
V^{\mathrm{liq}}_{\downarrow} \le \beta \sum_i |q_i|
\]

Then the \textbf{total additional log-price movement} due purely to
liquidation hedges is bounded from below
\(-\Delta l_{\max}^{\mathrm{liq}}\); i.e., the post-cascade log-price
\(l_{\mathrm{final}}\) satisfies:

\[
l_0 - 2 \Delta l_{\max}^{\mathrm{liq}} \le l_{\mathrm{final}} \le l_0
\]

In particular, the cascade cannot produce an unbounded collapse in a
single shock step.

\textbf{\emph{Proof Sketch.}}

The initial external shock moves price from \(l_0\) to
\(l_0 - \delta l\). At the new price, some positions breach maintenance
margin and are liquidated. By assumption, total liquidation volume is at
most \(\beta \sum_i |q_i|\). Spot depth over the interval
\([l_0, l_0 - \Delta l_{\max}^{\mathrm{liq}}]\) can absorb at least
\(\mathcal{L}^{\downarrow}(l_0; \Delta l_{\max}^{\mathrm{liq}})\)
volume. Stability-compatibility guarantees:

\[
\beta \sum_i |q_i| \le \mathcal{L}^{\downarrow}(l_0; \Delta l_{\max}^{\mathrm{liq}})
\]

Thus, executing the liquidation hedges from \(l_0 - \delta l\) cannot
push the price below \(l_0 - \Delta l_{\max}^{\mathrm{liq}}\): the total
volume of forced sells is insufficient to exhaust the entire depth down
to that level.

Therefore, the post-liquidation price \(l_{\mathrm{final}}\) lies in the
interval \([l_0 - \Delta l_{\max}^{\mathrm{liq}}, l_0 - \delta l]\). The
total movement from the pre-shock price \(l_0\) is then at most
\(-\Delta l_{\max}^{\mathrm{liq}} - \delta l \ge -2 \Delta l_{\max}^{\mathrm{liq}}\).
A more refined argument using local depth and updated leverage can
further tighten the bound, but this coarse bound suffices to show
non-divergence. \(\square\)

\textbf{Interpretation.}

The protocol can treat \(\Delta l_{\max}^{\mathrm{liq}}\) as a
\textbf{design parameter} (e.g.~corresponding to a 10-20\% move) and
calibrate maximum leverage / margin floors such that the inequality in
Definition 9.18 holds. This gives a formal, tunable guarantee that:

\begin{itemize}
\tightlist
\item
  A single shock cannot trigger an unbounded liquidation spiral,
\item
  The spot engine has enough depth to absorb the induced hedges.
\end{itemize}

This is \emph{not} a statement that price cannot move further over time
(new shocks may arrive), but that the \textbf{feedback loop between
leverage and spot depth is controlled} at each stage.

\begin{quote}
\textbf{Intuition:} This theorem addresses the nightmare scenario: price
drops → liquidations fire → liquidation hedges sell into the market →
price drops more → more liquidations → and so on in a death spiral. The
key insight is that if the total leveraged position size is small
relative to the market's absorbing capacity (how much selling the AMM +
order book can handle), then even if all positions get liquidated at
once, there's ``enough liquidity'' to absorb them without pushing the
price to zero. By capping leverage based on available depth, the
protocol mathematically bounds how far any cascade can go.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    LIQUIDATION CASCADE FEEDBACK LOOP (WITHOUT CONSTRAINT)}
\NormalTok{    ═══════════════════════════════════════════════════════}

\NormalTok{       ┌──────────────┐         ┌──────────────┐}
\NormalTok{       │   External   │         │   Price      │}
\NormalTok{       │    Shock     │────────►│   Drops      │}
\NormalTok{       │   (Δl \textless{} 0)   │         │   l → l {-} δl │}
\NormalTok{       └──────────────┘         └──────┬───────┘}
\NormalTok{                                       │}
\NormalTok{                                       ▼}
\NormalTok{       ┌──────────────┐         ┌──────────────┐}
\NormalTok{       │   Further    │         │  Positions   │}
\NormalTok{       │    Price     │◄────────│  Breach MM   │}
\NormalTok{       │    Drop      │         │ (Liquidate)  │}
\NormalTok{       └──────┬───────┘         └──────┬───────┘}
\NormalTok{              │                        │}
\NormalTok{              │    DANGER:             ▼}
\NormalTok{              │    FEEDBACK      ┌──────────────┐}
\NormalTok{              │    LOOP!         │  Hedge Sells │}
\NormalTok{              │                  │   Execute    │}
\NormalTok{              └──────────────────│ (V\^{}liq vol)  │}
\NormalTok{                                 └──────────────┘}


\NormalTok{    STABILITY{-}COMPATIBLE SYSTEM (WITH CONSTRAINT)}
\NormalTok{    ═══════════════════════════════════════════════════════}

\NormalTok{        LEVERAGE CONSTRAINT (Definition 9.18):}
\NormalTok{        ┌─────────────────────────────────────────────────┐}
\NormalTok{        │                                                 │}
\NormalTok{        │   β · Σ|q\_i|  ≤  𝓛↓(l; Δl\_max\^{}liq)             │}
\NormalTok{        │   ▲                    ▲                        │}
\NormalTok{        │   │                    │                        │}
\NormalTok{        │   Worst{-}case           Spot depth that can      │}
\NormalTok{        │   liquidation          absorb selling over      │}
\NormalTok{        │   volume               interval Δl\_max\^{}liq      │}
\NormalTok{        │                                                 │}
\NormalTok{        └─────────────────────────────────────────────────┘}

\NormalTok{        DEPTH ABSORBS LIQUIDATION FLOW:}
\NormalTok{        ┌─────────────────────────────────────────────────────┐}
\NormalTok{        │                                                     │}
\NormalTok{        │   Price l                                           │}
\NormalTok{        │      │                                              │}
\NormalTok{        │  l\_0 ┼───────────●  ◄─── Pre{-}shock price            │}
\NormalTok{        │      │           ║                                  │}
\NormalTok{        │      │           ║  External shock (δl)             │}
\NormalTok{        │      │           ▼                                  │}
\NormalTok{        │      ┼───────────●  ◄─── Post{-}shock, liq triggered  │}
\NormalTok{        │      │       ████║████                              │}
\NormalTok{        │      │       ████║████  Depth 𝓛↓ absorbs V\^{}liq     │}
\NormalTok{        │      │       ████▼████                              │}
\NormalTok{        │      ┼───────●───────   ◄─── l\_final (bounded!)     │}
\NormalTok{        │      │       ▲                                      │}
\NormalTok{        │      │       │                                      │}
\NormalTok{        │      │  Δl\_max\^{}liq (max allowed drop from cascade)  │}
\NormalTok{        │      │                                              │}
\NormalTok{        └─────────────────────────────────────────────────────┘}

\NormalTok{        THEOREM 9.19 GUARANTEE:}
\NormalTok{        ┌─────────────────────────────────────────────────────┐}
\NormalTok{        │                                                     │}
\NormalTok{        │   l\_0 {-} 2·Δl\_max\^{}liq  ≤  l\_final  ≤  l\_0           │}
\NormalTok{        │                                                     │}
\NormalTok{        │   ⟹  Cascade CANNOT produce unbounded collapse     │}
\NormalTok{        │   ⟹  Feedback loop is CONTROLLED at each stage     │}
\NormalTok{        │                                                     │}
\NormalTok{        └─────────────────────────────────────────────────────┘}

\NormalTok{        PROTOCOL CALIBRATION:}
\NormalTok{        ┌────────────────────────────────────────────────────┐}
\NormalTok{        │  Choose Δl\_max\^{}liq (e.g. 10{-}20\% price move)        │}
\NormalTok{        │                 ▼                                  │}
\NormalTok{        │  Measure spot depth 𝓛↓ over that interval         │}
\NormalTok{        │                 ▼                                  │}
\NormalTok{        │  Set leverage caps: β·Σ|q\_i| ≤ 𝓛↓                 │}
\NormalTok{        │                 ▼                                  │}
\NormalTok{        │  RESULT: Formal guarantee against death spirals    │}
\NormalTok{        └────────────────────────────────────────────────────┘}
\end{Highlighting}
\end{Shaded}

\emph{Figure 14: Leverage constraint and liquidation cascade stability.
Without constraints (top), liquidations can create a dangerous feedback
loop where hedges cause further price drops triggering more
liquidations. The stability condition (Definition 9.18) ensures that
worst-case liquidation volume is bounded by spot market depth,
preventing unbounded cascades. Theorem 9.19 guarantees that the total
price movement remains bounded even under maximum stress.}

\subsection{10. Related Work}\label{related-work}

This section surveys prior work across four areas relevant to our
design: constant function market maker (CFMM) theory, tick-based versus
continuous price representations, on-chain perpetual swap protocols, and
numerical methods for log-domain computation in trading systems.

\subsubsection{10.1 Constant Function Market
Makers}\label{constant-function-market-makers}

The theoretical foundations of automated market makers were established
by early work on prediction markets and subsequently formalized in the
context of decentralized exchanges. Uniswap v1 and v2
\autocite{adams2020uniswap} popularized the constant product invariant
\(x \cdot y = k\), where reserves of two tokens are constrained to lie
on a hyperbola. Subsequent theoretical analysis formalized CFMM
behavior, including price oracle properties
\autocite{angeris2020improved}, market dynamics and equilibrium
\autocite{angeris2021analysis}, and the relationship between curvature
and market making \autocite{angeris2022tail}. This elegantly simple
design provides liquidity across all prices but suffers from capital
inefficiency: most liquidity sits at prices far from the current market
rate.

Uniswap v3 \autocite{adams2021uniswap} introduced \textbf{concentrated
liquidity}, allowing liquidity providers to specify price ranges
\([p_a, p_b]\) within which their capital is active. The core innovation
is to represent positions via the square-root price \(\sqrt{P}\) and to
discretize the price axis into \textbf{ticks} spaced at fixed percentage
intervals. Each tick \(i\) corresponds to a price \(P_i = 1.0001^i\),
giving approximately 1 basis point granularity. The virtual reserves
within a tick follow a local constant-product curve, and crossing a tick
boundary triggers discrete liquidity updates.

Our log-axis model can be viewed as a continuous generalization of
Uniswap v3's tick system \autocite{adams2021uniswap}. Where v3 uses
discrete ticks at \(P_i = 1.0001^i\), we work directly with the
log-sqrt-price \(l = \log_2 \sqrt{P}\) as a continuous coordinate. The
relationship is:

\[
l = \frac{1}{2} \log_2 P = \frac{i \cdot \log_2(1.0001)}{2} \approx 7.2 \times 10^{-5} \cdot i
\]

Our approach eliminates the discrete tick-crossing logic in favor of
smooth integration over a liquidity density function \(\lambda(l)\).
This simplifies the mathematical treatment and enables tighter error
bounds, though both approaches converge to the same economic behavior as
tick spacing shrinks.

The economics of liquidity provision under AMMs have been studied
extensively, including LP returns in geometric mean markets
\autocite{evans2020liquidity} and the phenomenon of
loss-versus-rebalancing (LVR), which quantifies the cost to LPs from
trading against informed arbitrageurs
\autocite{milionis2022automated,milionis2023automated}. Our log-domain
representation does not eliminate LVR---it is inherent to any AMM
design---but provides a clean framework for analyzing its magnitude.

\textbf{Balancer} \autocite{martinelli2019balancer} generalizes the
two-token constant product to weighted pools with \(n\) assets and
arbitrary weights \(w_i\), maintaining the invariant
\(\prod_i R_i^{w_i} = k\). This enables index-fund-like products but
does not address concentrated liquidity.

\textbf{Curve Finance} \autocite{egorov2019stableswap} pioneered the
\textbf{StableSwap} invariant, which interpolates between
constant-product and constant-sum behavior. For stablecoin pairs
expected to trade near parity, this concentrates liquidity around the
peg while still providing deep markets if prices diverge. The Curve v2
design \autocite{egorov2021automatic} extends this to volatile asset
pairs using an internal oracle to dynamically recenter the liquidity
concentration. Our log-axis representation is orthogonal to such
invariant design choices and could in principle accommodate
StableSwap-like curves by defining an appropriate \(\lambda(l)\)
profile.

\textbf{Orca Whirlpools} \autocite{orca2022whirlpools} and
\textbf{Raydium} \autocite{raydium2023clmm} implement concentrated
liquidity on Solana, closely following Uniswap v3's tick-based model but
adapted for Solana's account structure and compute constraints. The
design uses 64-bit fixed-point arithmetic for \(\sqrt{P}\) (the
\texttt{sqrt\_price\_x64} representation) and maintains per-tick
liquidity in a sparse data structure. Our work differs by (i) using a
log-domain representation that converts multiplicative price moves to
additive shifts, (ii) providing explicit fixed-point error analysis with
convergence guarantees, and (iii) integrating spot and derivative
execution into a unified framework.

\subsubsection{10.2 Tick-Based Designs vs.~Log-Axis
Models}\label{tick-based-designs-vs.-log-axis-models}

The dominant paradigm in concentrated liquidity AMMs is the
\textbf{tick-based} model, where the price axis is discretized into a
lattice of ticks and liquidity is specified per-tick or per-tick-range.
Uniswap v3 \autocite{adams2021uniswap}, Orca Whirlpools
\autocite{orca2022whirlpools}, Raydium \autocite{raydium2023clmm}, and
similar designs all follow this pattern. The choice of tick spacing
(e.g., 1 bp, 5 bp, 30 bp, 100 bp) trades off between granularity and
gas/compute cost.

Our \textbf{log-axis} model takes a different approach: rather than
discretizing prices into ticks, we treat the log-sqrt-price \(l\) as a
continuous coordinate and represent liquidity as a density function
\(\lambda(l)\). Swap execution is computed by integrating this density,
and the on-chain representation uses high-precision fixed-point encoding
of \(l\) rather than a tick index.

The practical differences are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Granularity.} Tick-based systems have inherent price
  granularity determined by tick spacing. Our log-axis model can
  represent prices at arbitrary precision limited only by the
  fixed-point encoding (e.g., 64 or 96 fractional bits).
\item
  \textbf{Liquidity representation.} Tick-based systems store liquidity
  per tick, requiring \(O(T)\) storage for \(T\) active ticks. Our model
  can represent smooth liquidity profiles with \(O(1)\) parameters
  (e.g., uniform liquidity in a range) or use band-based discretization
  when desired.
\item
  \textbf{Execution logic.} Tick-based systems must handle tick-crossing
  events, updating active liquidity at each boundary. Our model
  integrates continuously over \(\lambda(l)\), with discrete bands as an
  optional optimization rather than a fundamental constraint.
\item
  \textbf{Error analysis.} Our fixed-point specification (Section 6)
  provides explicit error bounds showing that on-chain execution
  converges to the continuous model as precision increases. Tick-based
  systems have implicit discretization error from tick spacing but
  typically lack formal convergence guarantees.
\end{enumerate}

The log-axis representation also has natural connections to
\textbf{geometric Brownian motion} models in finance, where log-prices
follow arithmetic random walks. This makes our framework amenable to
standard stochastic calculus techniques \autocite{shreve2004stochastic},
as exploited in Section 9.

\subsubsection{10.3 On-Chain Perpetual
Protocols}\label{on-chain-perpetual-protocols}

Perpetual swaps originated in centralized cryptocurrency exchanges
(notably BitMEX \autocite{bitmex2016perpetual} in 2016) and have since
been adapted for on-chain execution. We survey the major approaches and
contrast them with our spot-anchored design.

\paragraph{10.3.1 Oracle-based
perpetuals}\label{oracle-based-perpetuals}

\textbf{GMX} \autocite{gmx2022technical} (Arbitrum, Avalanche) and
\textbf{GNS/Gains Network} use external price oracles (typically
Chainlink) to determine mark prices for perpetual positions. Traders
open leveraged long/short positions against a shared liquidity pool,
with PnL settled against pool reserves. Key characteristics include:

\begin{itemize}
\tightlist
\item
  \textbf{No on-chain price discovery:} The mark price is imported from
  external oracles, not determined by on-chain trading activity.
\item
  \textbf{Funding rate:} GMX \autocite{gmx2022technical} uses hourly
  funding payments to balance long/short open interest, similar to
  centralized exchange perps.
\item
  \textbf{Liquidity pool as counterparty:} The GLP (GMX Liquidity
  Provider) pool absorbs trader PnL, creating an adversarial dynamic
  between traders and LPs.
\end{itemize}

Our spot-anchored model differs fundamentally: the mark price equals the
on-chain spot price by construction, eliminating basis risk and the need
for funding rate mechanisms. The protocol hedges derivative positions in
real-time against the spot market, so LPs are not directly exposed to
directional trader PnL.

\paragraph{10.3.2 vAMM-based perpetuals}\label{vamm-based-perpetuals}

\textbf{Perpetual Protocol} \autocite{perp2021v2} (v1 and v2) pioneered
the \textbf{virtual AMM} (vAMM) approach, where perpetual positions are
priced against a virtual constant-product curve that exists only for
price discovery---no actual token swaps occur in the vAMM. Key
characteristics:

\begin{itemize}
\tightlist
\item
  \textbf{Synthetic price curve:} The vAMM maintains virtual reserves
  \(x_v, y_v\) satisfying \(x_v \cdot y_v = k_v\). Opening a long
  position ``buys'' from the vAMM, moving its virtual price.
\item
  \textbf{Funding rate:} Positions pay/receive funding based on the
  difference between vAMM price and an external index (oracle) price,
  incentivizing convergence.
\item
  \textbf{Insurance fund:} Covers shortfalls when liquidations are
  unprofitable.
\end{itemize}

The v2 design (on Optimism) introduced \textbf{concentrated liquidity
vAMMs} using Uniswap v3-style mechanics, allowing market makers to
provide virtual liquidity in ranges.

Our approach avoids the vAMM construction entirely. Because derivative
positions are atomically hedged against the real spot market, the mark
price is anchored to spot by mechanism design rather than by funding
rate incentives. This eliminates the basis risk inherent in vAMM
systems, where the vAMM price can diverge from fair value during periods
of high demand.

\paragraph{10.3.3 Order book perpetuals}\label{order-book-perpetuals}

\textbf{dYdX} \autocite{dydx2023v4} operates an off-chain order book
with on-chain settlement (originally on Ethereum L1, now on a dedicated
Cosmos appchain). This provides a centralized-exchange-like experience
with:

\begin{itemize}
\tightlist
\item
  \textbf{Limit order book:} Prices are determined by order matching,
  not AMM curves.
\item
  \textbf{Funding rate:} Standard 8-hour funding payments based on
  mark-index spread.
\item
  \textbf{Hybrid custody:} Orders are matched off-chain, with periodic
  settlement and proofs posted on-chain.
\end{itemize}

\textbf{Drift Protocol} \autocite{drift2023v2} (Solana) implements a
hybrid model combining a central limit order book (CLOB) with a backstop
AMM. The CLOB provides price discovery and tight spreads when active
market makers are present; the AMM ensures liquidity is always
available.

Our unified execution model (Section 7) is closest in spirit to Drift's
hybrid approach, combining CLOB and CLMM liquidity. The key difference
is our log-axis representation, which provides a consistent coordinate
system across both venues, and our spot-anchored derivative design,
which eliminates funding rates.

\paragraph{10.3.4 Basis and funding rate
mechanisms}\label{basis-and-funding-rate-mechanisms}

A central challenge for perpetual swaps is maintaining price convergence
to the underlying spot market. Traditional funding rate mechanisms (used
by BitMEX \autocite{bitmex2016perpetual}, Binance, dYdX
\autocite{dydx2023v4}, GMX \autocite{gmx2022technical}, Perpetual
Protocol \autocite{perp2021v2}, etc.) impose periodic payments between
longs and shorts based on the mark-index spread:

\[
\text{FundingPayment} = \text{PositionSize} \times \text{FundingRate} \times \text{IndexPrice}
\]

where the funding rate is typically proportional to the time-weighted
average premium/discount of the perp price to the index. This mechanism
relies on \textbf{arbitrageurs} to enforce convergence: when the perp
trades at a premium, longs pay shorts, incentivizing arbitrageurs to
short the perp and long the spot.

Our spot-anchored model eliminates funding rates entirely (Theorem 9.9).
Because each derivative trade is atomically hedged against the spot
market, the perp mark price equals the post-trade spot price by
construction. There is no basis to arbitrage and no funding payments to
administer. The economic cost of this design is that derivative trades
incur execution costs in the spot market, which are passed through to
traders as part of the transaction.

\subsubsection{10.4 Log-Domain Representations and Fixed-Point
Arithmetic}\label{log-domain-representations-and-fixed-point-arithmetic}

The use of logarithmic representations for prices and quantities has a
long history in quantitative finance and high-frequency trading systems.

\paragraph{10.4.1 Log-price models in
finance}\label{log-price-models-in-finance}

The Black-Scholes-Merton framework
\autocite{black1973pricing,merton1973theory} and its descendants model
asset prices as geometric Brownian motion, which is equivalent to
arithmetic Brownian motion in the log-price. This makes log-prices the
natural coordinate for:

\begin{itemize}
\tightlist
\item
  \textbf{Volatility estimation:} Log-returns are approximately normally
  distributed under GBM, simplifying statistical analysis.
\item
  \textbf{Option pricing:} The Black-Scholes formula is most naturally
  expressed in terms of \(\log(S/K)\) and \(\sigma\sqrt{T}\).
\item
  \textbf{Risk management:} Value-at-Risk and related metrics are
  typically computed using log-return distributions.
\end{itemize}

Standard textbook treatments of these topics include Hull
\autocite{hull2021options} and Wilmott et al.
\autocite{wilmott1995mathematics}. Our choice of log-sqrt-price
\(l = \log_2 \sqrt{P}\) follows this tradition while adapting to the
specific needs of on-chain AMM execution.

\paragraph{10.4.2 Fixed-point arithmetic in trading
systems}\label{fixed-point-arithmetic-in-trading-systems}

High-frequency trading systems have long used fixed-point arithmetic to
avoid the latency and non-determinism of floating-point operations. Key
considerations include:

\begin{itemize}
\tightlist
\item
  \textbf{Determinism:} Fixed-point operations produce identical results
  across all hardware, essential for consensus in blockchain systems.
\item
  \textbf{Precision:} The number of fractional bits determines the
  granularity of representable values. Our analysis (Section 6) shows
  that 64-96 fractional bits provide sufficient precision for practical
  AMM applications.
\item
  \textbf{Overflow:} Fixed-point multiplication can overflow; careful
  range analysis is required. Our encoding bounds \(|L| \le 2^{63}\)
  (for 64-bit signed integers) correspond to price ratios up to
  approximately \(2^{2^{63}/\sigma}\), which is astronomically large for
  reasonable \(\sigma\).
\end{itemize}

\textbf{Uniswap v3} \autocite{adams2021uniswap} uses \texttt{Q64.64} and
\texttt{Q128.128} fixed-point formats for intermediate calculations,
with the square-root price stored as \texttt{sqrtPriceX96} (a Q64.96
format). Our approach differs by storing the \emph{log} of the
square-root price, which converts multiplicative price updates to
additive operations and simplifies the analysis of compounding errors.

\paragraph{10.4.3 Exponential and logarithm
implementations}\label{exponential-and-logarithm-implementations}

Computing \(2^x\) and \(\log_2(x)\) efficiently in fixed-point
arithmetic is a well-studied problem \autocite{muller2016elementary}.
Common approaches include:

\begin{itemize}
\tightlist
\item
  \textbf{Table lookup with interpolation:} Precompute \(2^{k/N}\) for
  \(k = 0, \ldots, N-1\) and use linear or polynomial interpolation
  \autocite{tang1990logarithm,sablier2021prbmath}. This is fast but
  requires \(O(N)\) storage.
\item
  \textbf{Polynomial approximation:} Use minimax polynomials (e.g.,
  Remez algorithm) to approximate \(2^x\) on \([0, 1)\) and reduce
  arbitrary arguments via \(2^{n+f} = 2^n \cdot 2^f\). This is the
  approach used in most high-performance implementations
  \autocite{muller2016elementary}.
\item
  \textbf{CORDIC-style algorithms:} Iterative shift-and-add algorithms
  that converge to exponentials/logarithms. Less common in modern
  implementations due to latency.
\end{itemize}

Our specification (Section 6) abstracts over the choice of algorithm,
requiring only that the implemented \(\exp_2\) and \(\log_2\) functions
satisfy explicit error bounds. This allows implementers flexibility
while providing the formal guarantees needed for our convergence
theorems.

\paragraph{10.4.4 Prior work on DeFi
numerics}\label{prior-work-on-defi-numerics}

Several projects have addressed numerical precision in DeFi protocols:

\begin{itemize}
\tightlist
\item
  \textbf{Balancer v2} \autocite{balancer2021math} provides extensive
  documentation on fixed-point math for weighted pool calculations,
  including error analysis for power functions.
\item
  \textbf{Yield Protocol} uses fixed-point representations for
  yield-bearing tokens with careful attention to rounding.
\item
  \textbf{PRBMath} \autocite{sablier2021prbmath} and
  \textbf{ABDKMath64x64} \autocite{abdk2019math64x64} are Solidity
  libraries providing fixed-point logarithms and exponentials, widely
  used in DeFi development.
\end{itemize}

Our contribution extends this line of work by (i) providing a complete
formal specification linking on-chain fixed-point execution to a
continuous mathematical model, (ii) proving explicit convergence bounds,
and (iii) integrating the numerical framework with a unified
spot+derivative execution engine.

\subsubsection{10.5 Summary of
Distinctions}\label{summary-of-distinctions}

To summarize the key distinctions between our approach and prior work:

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1212}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.6182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2606}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Prior Art
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Our Approach
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Price representation & Square-root price (Uni v3
\autocite{adams2021uniswap}), tick index & Log-sqrt-price as continuous
coordinate \\
Liquidity model & Per-tick discrete (Uni v3 \autocite{adams2021uniswap},
Orca \autocite{orca2022whirlpools}, Raydium \autocite{raydium2023clmm})
& Density function \(\lambda(l)\) over log-axis \\
Perp mark price & Oracle (GMX \autocite{gmx2022technical}), vAMM (Perp
\autocite{perp2021v2}), order book (dYdX \autocite{dydx2023v4}) &
Spot-anchored (equals post-trade spot) \\
Basis convergence & Funding rate mechanism & Eliminated by
construction \\
Derivative hedging & External arbitrageurs & Protocol-level atomic
hedging \\
Numerical framework & Ad-hoc fixed-point & Formal spec with convergence
proofs \\
CLOB+AMM integration & Hybrid (Drift \autocite{drift2023v2}) & Unified
execution on log-axis \\
\end{longtable}
}

The combination of log-domain representation, spot-anchored derivatives,
and formal numerical guarantees distinguishes our design from existing
protocols and provides a foundation for rigorous analysis of complex
DeFi mechanisms.

\subsection{11. Conclusion and Future
Work}\label{conclusion-and-future-work}

\subsubsection{11.1 Summary of
Contributions}\label{summary-of-contributions}

This paper has presented a unified framework for decentralized exchange
design based on logarithmic price representation and spot-anchored
derivatives. We summarize the main conceptual and technical
contributions:

\textbf{Logarithmic price axis.} We introduced the log-sqrt-price
coordinate \(l = \log_2 \sqrt{P}\) as the fundamental representation for
prices throughout the system. This choice transforms multiplicative
price movements into additive shifts, simplifies the mathematics of
liquidity provision and swap execution, and provides a natural
coordinate system compatible with stochastic calculus
\autocite{shreve2004stochastic}. The continuous log-axis generalizes the
discrete tick-based models used in existing concentrated liquidity AMMs
while enabling tighter theoretical analysis.

\textbf{Three-layer architecture.} We defined a principled separation
between the continuous mathematical model (Layer 0), the discretized
on-chain representation (Layer 1), and the approximation routines for
transcendental functions (Layer 2). This layered approach clarifies the
sources of numerical error and enables modular analysis: properties
proved at the continuous level carry over to the discrete implementation
with explicit, bounded degradation.

\textbf{Formal fixed-point specification.} We provided abstract
specifications for the \(\exp_2\) and \(\log_2\) routines required by
on-chain execution, along with explicit error bounds. The main
convergence theorem (Theorem 6.8) establishes that the discrete
fixed-point implementation approaches the continuous model as precision
increases, with error scaling as \(O(2^{-F})\) in the number of
fractional bits.

\textbf{Unified execution semantics.} We developed a unified execution
model that combines concentrated liquidity market maker (CLMM) and
central limit order book (CLOB) liquidity on a common price axis. The
deterministic node execution ordering rule (Rule 7.1) ensures
consistent, arbitrage-free execution across both venues, while the price
path continuity lemma (Lemma 7.3) guarantees that execution traces are
well-behaved.

\textbf{Spot-anchored perpetuals.} We introduced a novel derivative
design in which perpetual swap positions are marked to the on-chain spot
price and hedged atomically against the spot market at trade time. This
construction eliminates basis risk and funding rate mechanisms by design
(Theorem 9.9), transferring the burden of price convergence from
external arbitrageurs to the protocol itself.

\textbf{Formal guarantees.} We established a comprehensive set of formal
results for the derivative layer, including:

\begin{itemize}
\tightlist
\item
  No-arbitrage uniqueness of the spot-anchored mark price (Proposition
  9.2)
\item
  Residual hedging error bounds under discrete execution (Theorem 9.3)
\item
  Liquidation correctness and path regularity (Theorem 9.6)
\item
  Fee allocation and wealth conservation invariants (Proposition 9.7)
\item
  Computational complexity bounds for hedged perp trades (Theorem 9.8)
\item
  Margin dynamics and collateral invariants (Section 9.12)
\item
  Insurance fund solvency conditions (Theorem 9.15)
\item
  Determinism of concurrent liquidations (Theorem 9.17)
\item
  Dynamic stability under leverage constraints (Theorem 9.19)
\end{itemize}

Together, these results provide a rigorous foundation for implementing
and reasoning about complex DeFi mechanisms.

\subsubsection{11.2 Limitations}\label{limitations}

We acknowledge several limitations of the present work that scope the
applicability of our results:

\textbf{Single trading pair.} The formal model considers a single token
pair \((A, B)\) throughout. Real DEX deployments support hundreds or
thousands of trading pairs, often with shared quote assets and routing
through intermediate tokens. Extending the framework to multi-pair
settings introduces cross-market effects (e.g., triangular arbitrage
constraints, correlated liquidations across pairs) that are not captured
by our single-pair analysis.

\textbf{Idealized execution model.} We assume that trades execute
atomically and instantaneously at the prices determined by the AMM curve
and order book state. In practice, on-chain execution involves:

\begin{itemize}
\tightlist
\item
  \textbf{Transaction ordering:} Transactions within a block may be
  reordered by block producers, creating opportunities for front-running
  and sandwich attacks.
\item
  \textbf{MEV (Maximal Extractable Value):} Sophisticated actors can
  extract value by observing pending transactions and strategically
  inserting their own orders
  \autocite{daian2020flash,flashbots2021mev,kulkarni2022theory,babel2023clockwork}.
\item
  \textbf{Latency and finality:} Cross-chain or L2 deployments introduce
  additional latency between order submission and execution.
\end{itemize}

Our model abstracts away these concerns, treating execution as
deterministic given the pre-trade state. A complete implementation must
address MEV resistance through mechanisms such as encrypted mempools,
batch auctions, or commit-reveal schemes.

\textbf{Gas and compute costs.} We analyze computational complexity in
terms of asymptotic operation counts (Theorem 9.8) but do not model the
specific gas costs or compute unit budgets of any particular blockchain.
The practical feasibility of our design depends on the target execution
environment:

\begin{itemize}
\tightlist
\item
  \textbf{EVM chains:} Gas costs for storage reads/writes and arithmetic
  operations constrain the complexity of on-chain logic.
\item
  \textbf{Solana:} Compute unit limits and account data constraints
  impose different tradeoffs.
\item
  \textbf{App-specific chains:} Custom execution environments (e.g.,
  Cosmos SDK chains) may relax some constraints while introducing
  others.
\end{itemize}

\textbf{Continuous liquidity assumption.} Several results assume a
continuous, well-behaved liquidity density \(\lambda(l)\). In practice,
liquidity is provided by discrete LPs who may withdraw at any time,
creating potential gaps or discontinuities in the liquidity profile.
While our band-based discretization addresses this to some extent,
extreme market conditions could violate the smoothness assumptions
underlying some error bounds.

\textbf{Simplified market microstructure.} The model does not capture
several features of real market microstructure:

\begin{itemize}
\tightlist
\item
  \textbf{Informed vs.~uninformed order flow:} We do not distinguish
  between noise traders and informed traders, nor model adverse
  selection costs to LPs.
\item
  \textbf{Dynamic LP behavior:} LPs are assumed to passively provide
  liquidity according to a fixed profile, rather than actively
  repositioning in response to market conditions.
\item
  \textbf{Cross-venue arbitrage:} Interactions with external markets
  (centralized exchanges, other DEXs) are not modeled.
\end{itemize}

\textbf{Funding rate elimination scope.} The funding rate elimination
theorem (Theorem 9.9) applies to our specific spot-anchored construction
where hedging occurs atomically at trade time. Alternative derivative
designs with delayed or batched hedging would reintroduce basis dynamics
and potentially require funding mechanisms.

\subsubsection{11.3 Future Directions}\label{future-directions}

We outline several directions for future research and development:

\paragraph{11.3.1 Multi-asset extension}\label{multi-asset-extension}

Extending the framework to support multiple trading pairs introduces
several challenges:

\textbf{Shared liquidity and routing.} Many DEX designs allow liquidity
to be shared across pairs (e.g., through a common quote asset) and
support multi-hop routing (e.g., trading \(X \to Y\) via
\(X \to A \to Y\)). The log-axis representation would need to be
extended to a multi-dimensional space or a graph of pairwise log-price
coordinates.

\textbf{Cross-pair derivatives.} Derivatives on baskets, spreads, or
indices (e.g., a BTC/ETH ratio perpetual) require mark prices derived
from multiple spot markets. The spot-anchoring principle could be
extended by hedging against a portfolio of underlying assets.

\textbf{Correlated risk management.} Margin and liquidation systems must
account for correlations between positions across pairs. A portfolio
margin system based on log-price coordinates could leverage the additive
structure of our representation.

\textbf{Triangular arbitrage constraints.} For three tokens \(A\),
\(B\), \(C\), the log-prices must satisfy consistency constraints:
\(l_{A,B} + l_{B,C} + l_{C,A} = 0\) (up to fees). Incorporating these
constraints into the execution and hedging logic is an open problem.

\paragraph{11.3.2 Implementation on specific
platforms}\label{implementation-on-specific-platforms}

The abstract specification in this paper is designed to be
platform-agnostic. Concrete implementations would need to address
platform-specific concerns:

\textbf{Solana.} The high throughput and low latency of Solana
\autocite{yakovenko2018solana} make it attractive for implementing the
unified CLOB+CLMM execution model. Key considerations include:

\begin{itemize}
\tightlist
\item
  Account structure for storing liquidity bands and order book state
\item
  Compute unit budgets for complex swap and hedging operations
\item
  Integration with existing Solana DeFi infrastructure (e.g.,
  Serum/OpenBook \autocite{openbook2022} order books, Orca
  \autocite{orca2022whirlpools} and Raydium \autocite{raydium2023clmm}
  pools)
\end{itemize}

\textbf{Ethereum L2s.} Optimistic and ZK rollups provide lower gas costs
while inheriting Ethereum's \autocite{wood2014ethereum} security.
Considerations include:

\begin{itemize}
\tightlist
\item
  Storage costs for liquidity state
\item
  Proving costs for ZK implementations
\item
  Sequencer centralization and its implications for MEV
\end{itemize}

\textbf{App-specific chains.} Building a dedicated blockchain (e.g.,
using Cosmos SDK or Substrate) allows custom execution logic but
requires bootstrapping validator sets and liquidity. This approach may
be suitable for specialized derivative applications.

\textbf{Formal verification.} The layered specification in this paper is
designed to facilitate formal verification of implementations. Future
work could develop machine-checked proofs (e.g., in Coq, Lean, or
Isabelle) that concrete smart contract code satisfies the abstract
specification.

\paragraph{11.3.3 Empirical validation and
backtesting}\label{empirical-validation-and-backtesting}

The theoretical guarantees in this paper should be validated against
empirical data:

\textbf{Historical backtesting.} Simulating the protocol against
historical price and volume data would reveal:

\begin{itemize}
\tightlist
\item
  Realized hedging errors versus theoretical bounds
\item
  Insurance fund accumulation/depletion under various market conditions
\item
  Liquidation cascade dynamics during historical stress events (e.g.,
  March 2020, May 2021, November 2022)
\end{itemize}

\textbf{Agent-based simulation.} Modeling strategic behavior by LPs,
traders, and liquidators could reveal emergent dynamics not captured by
the single-agent analysis:

\begin{itemize}
\tightlist
\item
  LP repositioning strategies and their impact on liquidity depth
\item
  Arbitrageur behavior and MEV extraction
\item
  Attack vectors and their profitability
\end{itemize}

\textbf{Testnet deployment.} Deploying the protocol on testnets with
synthetic or forked mainnet state would provide practical experience
with implementation challenges and edge cases.

\paragraph{11.3.4 Extensions to options and structured
products}\label{extensions-to-options-and-structured-products}

Section 9.11 sketched extensions to dated futures and options. A full
treatment would include:

\textbf{Option pricing and hedging.} Adapting Black-Scholes
\autocite{black1973pricing,merton1973theory} or local volatility models
to the log-axis representation, with explicit treatment of discrete
hedging and fixed-point errors.

\textbf{Volatility surfaces.} Representing implied volatility as a
function of log-moneyness \(l - l_{\text{atm}}\) and time to expiry,
with appropriate interpolation and extrapolation schemes.

\textbf{Exotic derivatives.} Path-dependent options (barriers,
lookbacks, Asians) require careful treatment of the discrete execution
model and its interaction with continuous-time pricing theory.

\textbf{Structured products.} Combining spot, perp, and option positions
into structured products (e.g., principal-protected notes, yield
enhancement strategies) with formal risk characterization.

\paragraph{11.3.5 MEV resistance and fair
ordering}\label{mev-resistance-and-fair-ordering}

Addressing the MEV concerns noted in Section 11.2 is critical for
practical deployment:

\textbf{Batch auctions.} Collecting orders over a time window and
executing them at a uniform clearing price can eliminate front-running
within batches.

\textbf{Encrypted mempools.} Threshold encryption schemes can hide order
details until block finalization, preventing content-based MEV
extraction.

\textbf{Fair ordering protocols.} Consensus mechanisms that enforce fair
ordering (e.g., based on commit timestamps) can reduce sequencer
discretion.

\textbf{MEV redistribution.} Mechanisms that capture and redistribute
MEV to users or LPs (e.g., MEV-Share, OEV auctions) could be integrated
with the protocol.

\paragraph{11.3.6 Governance and parameter
optimization}\label{governance-and-parameter-optimization}

The protocol involves numerous parameters (precision bits \(F\), margin
ratios, leverage caps, fee rates, insurance fund targets) that affect
system behavior:

\textbf{Parameter sensitivity analysis.} Understanding how outcomes
depend on parameter choices, and identifying robust parameter regimes.

\textbf{Adaptive parameters.} Mechanisms for adjusting parameters in
response to market conditions (e.g., increasing margin requirements
during high volatility).

\textbf{Decentralized governance.} Designing governance mechanisms for
parameter updates that balance responsiveness with stability and
resistance to capture.

\subsubsection{11.4 Closing Remarks}\label{closing-remarks}

The design space for decentralized exchanges remains vast and largely
unexplored. This paper contributes a formal framework that unifies spot
and derivative markets on a common mathematical foundation, with
explicit attention to the numerical realities of on-chain execution. We
hope this work provides a useful reference for researchers and
practitioners seeking to build more rigorous, transparent, and efficient
DeFi infrastructure.

The logarithmic representation at the heart of our design is not merely
a technical convenience but reflects a deep connection between the
multiplicative nature of financial prices and the additive structure
amenable to digital computation. By making this connection explicit and
proving that it can be preserved through layers of discretization and
approximation, we aim to bridge the gap between elegant mathematical
models and practical blockchain implementations.

As decentralized finance continues to mature, we believe that formal
methods and rigorous specification will become increasingly
important---not as academic exercises, but as practical tools for
building systems that users can trust. The stakes are high: DeFi
protocols collectively secure billions of dollars in user assets, and
failures can be catastrophic and irreversible. We offer this work as a
step toward a more principled approach to DeFi protocol design.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\printbibliography

\end{document}
